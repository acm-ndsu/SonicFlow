package {
    import mx.resources.*;

    public class en_US$rpc_properties extends ResourceBundle {

        public function en_US$rpc_properties(){
            super("en_US", "rpc");
        }
        override protected function getContent():Object{
            var _local1:Object = {
                noBaseSchemaAddress:"Cannot resolve relative schema import without a fully qualified base address.",
                unrecognizedPortTypeName:"The WSDL parser couldn't find a portType named '{0}' in namespace '{1}'",
                noListenerForHeader:"No event listener for header {0}",
                cannotConnectToDestination:"Couldn't establish a connection to '{0}'",
                unexpectedException:"Runtime exception {0}",
                noServiceElement.details:"No <wsdl:service> elements found in WSDL at {0}.",
                unableToLoadWSDL:"Unable to load WSDL. If currently online, please verify the URI and/or format of the WSDL ({0})",
                errorWhileLoadingFromParent:"Error while loading imported schema from parent location: {0}",
                unexpectedSchemaException:"Error while importing schema: {0}",
                unrecognizedBindingName:"The WSDL parser couldn't find a binding named '{0}' in namespace '{1}'",
                cannotResetService:"Cannot reset the service of an Operation",
                mustSpecifyWSDLLocation:"You must specify the WSDL location with useProxy set to false.",
                urlNotSpecified:"A URL must be specified with useProxy set to false.",
                unexpectedInputParameter:"Unexpected parameter '{0}' found in input arguments.",
                noBaseWSDLAddress:"Cannot resolve relative WSDL import without a fully qualified base address.",
                noListenerForEvent:"An event was received for which no listener was defined. Please add an event listener. {0}",
                unknownSchemaVersion:"Unknown schema version",
                missingInputParameter:"Array of input arguments did not contain a required parameter at position {0}",
                unrecognizedNamespace:"The WSDL parser had no registered document for the namespace '{0}'",
                multiplePortsFound:"A valid port was not specified. Unable to select a default port as there are multiple ports in the WSDL file.",
                wsdlDefinitionsNotFirst:"Definitions must be the first element in a WSDL document",
                xmlEncodeReturnNoXMLNode:"xmlEncode did not return XMLNode",
                xmlDecodeReturnNull:"xmlDecode returned null",
                tooFewInputParameters:"Too few parameters - expected at least {0} but found {1}",
                noPortsInWSDL:"There are no valid ports in the WSDL file for the {0} service.",
                invalidResultFormat:"Invalid resultFormat '{0}' valid formats are [{1}, {2}, {3}, {4}, {5}]",
                unrecognizedMessageName:"The WSDL parser couldn't find a message named '{0}' in namespace '{1}'",
                operationsNotAllowedInService:"Cannot assign operations into an RPC Service ({0})",
                badSchemaNode:"Bad schema node",
                noSuchServiceInWSDL:"The requested service '{0}' was not found in the WSDL file.",
                destinationOrWSDLNotSpecified:"A destination and/or WSDL must be specified.",
                noBaseWSDLAddress.details:"Please specify the location of the WSDL document for the WebService.",
                missingInputParameterWithName:"Required parameter '{0}' not found in input arguments.",
                badElement:"Element {0}:{1} not resolvable",
                overloadedOperation:"The WSDL contains an overloaded operation ({0}) - we do not currently support this usage.",
                defaultDecoderFailed:"Default decoder could not decode result",
                faultyWSDLFormat:"Faulty WSDL format",
                soapVersionMismatch:"Request implements version: {0}, Response implements version {1}",
                badType:"Type {0} not resolvable",
                noSuchService:"Couldn't find service '{0}'",
                cannotResetOperationName:"Cannot reset the name of an Operation",
                unknownSchemaElement:"Unknown element: {0}",
                pendingCallExists:"Attempt to invoke while another call is pending.  Either change concurrency options or avoid multiple calls.",
                noServiceAndPort:"Couldn't find a matching port (service = '{0}', port = '{1}')",
                noServices:"There are no valid services in the WSDL file.",
                unknownProtocol:"Unknown protocol '{0}'",
                unknownSchemaType:"Unknown schema type system",
                invalidSoapResultFormat:"Invalid resultFormat '{0}'. Valid formats are 'object', 'xml', and 'e4x'",
                xmlEncodeReturnNull:"xmlEncode returned null",
                cannotFindType:"Cannot find type for: {0}",
                noServiceElement:"Could not load WSDL"
            };
            return (_local1);
        }

    }
}//package 
﻿package {
    import flash.events.*;
    import com.grooveshark.jsonrpc.events.*;
    import com.grooveshark.jsQueue.*;
    import flash.display.*;
    import com.grooveshark.framework.playback.*;
    import com.grooveshark.jsonrpc.*;
    import com.adobe.serialization.json.*;
    import flash.net.*;
    import flash.system.*;
    import flash.external.*;

    public class JSQueue extends Sprite {

        public const VERSION:String;

        private var defaultEndpoint:String;
        private var model:Model;
        private var hostname:String;
        private var service:Service;
        private var uuid:String;
        private var controller:Controller;
        private var session:String;
        private var chatServers:Object;

        public function JSQueue(){
            var k:* = null;
            VERSION = String(20110906.29);
            super();
            trace("JSQueue!!");
            trace("flashvars");
            for (k in root.loaderInfo.parameters) {
                trace(((k + ": ") + root.loaderInfo.parameters[k]));
            };
            if (root.loaderInfo.parameters.hostname){
                hostname = root.loaderInfo.parameters.hostname;
            } else {
                hostname = "grooveshark.com";
            };
            if (root.loaderInfo.parameters.session){
                session = root.loaderInfo.parameters.session;
            } else {
                session = null;
            };
            if (root.loaderInfo.parameters.uuid){
                uuid = root.loaderInfo.parameters.uuid;
            } else {
                uuid = null;
            };
            if (root.loaderInfo.parameters.defaultEndpoint){
                defaultEndpoint = root.loaderInfo.parameters.defaultEndpoint;
            } else {
                defaultEndpoint = "more.php";
            };
            if (root.loaderInfo.parameters.chatServers){
                try {
                    chatServers = JSON.decode(root.loaderInfo.parameters.chatServers);
                } catch(e:Error) {
                    chatServers = [];
                };
            };
            if (!(chatServers is Array)){
                chatServers = [];
            };
            if (hostname.indexOf("staging") != -1){
                PlayableSong.useStagingScript = true;
            };
            var loader:* = new URLLoader();
            loader.addEventListener("complete", parseAllowedURLs);
            loader.addEventListener("ioError", loadFailed);
            try {
                loader.load(new URLRequest(((("http://" + hostname) + "/crossdomain.xml?") + VERSION)));
            } catch(e:Error) {
                trace("Failed to load allowed domains, not initializing.");
                reportBadHost();
            };
        }
        private function reportBadHost():void{
            if (ExternalInterface.available){
                try {
                    ExternalInterface.call((root.loaderInfo.parameters.serviceController + ".swfBadHost"));
                } catch(e:Error) {
                    trace(e);
                };
            };
        }
        private function loadFailed(_arg1:Event):void{
            trace("Failed to load allowed domains, not initializing.");
            reportBadHost();
        }
        private function initialize():void{
            Security.allowDomain("*");
            var _local1:Boolean = Boolean(int(root.loaderInfo.parameters.disableHTTPS));
            trace(("DISABLE HTTPS? " + _local1));
            service = new Service(hostname, defaultEndpoint, VERSION, session, uuid, !(_local1), String("theTicketsAreNowDiamonds"));
            service.fetchCountry();
            model = new Model(service);
            model.revision = VERSION;
            controller = new Controller(model, stage, root.loaderInfo.parameters.name, root.loaderInfo.parameters.playerController, root.loaderInfo.parameters.serviceController);
        }
        private function parseAllowedURLs(_arg1:Event):void{
            var node:* = null;
            var xml:* = null;
            var str:* = null;
            var event:* = _arg1;
            if (!ExternalInterface.available){
                trace("ExternalInterface not available, not initializing.");
                return;
            };
            var url:* = "";
            try {
                url = ExternalInterface.call("function() { return window.location.href;}");
            } catch(e:Error) {
                trace("Failed to grab window.location, not initializing.");
                reportBadHost();
                return;
            };
            var loader:* = (event.currentTarget as URLLoader);
            try {
                xml = new XML(loader.data);
            } catch(e:Error) {
                trace("Could not parse the XML file, not initializing.");
                reportBadHost();
                return;
            };
            var domainOk:* = false;
            for each (node in xml.descendants("allow-access-from")) {
                str = node.@domain;
                str = str.replace("*.", "");
                if (url.indexOf(str) != -1){
                    initialize();
                    return;
                };
            };
            trace("Domain not allowed, not initializing.");
            reportBadHost();
        }

    }
}//package 
﻿package {
    import mx.resources.*;

    public class en_US$logging_properties extends ResourceBundle {

        public function en_US$logging_properties(){
            super("en_US", "logging");
        }
        override protected function getContent():Object{
            var _local1:Object = {
                invalidTarget:"Invalid target specified.",
                charsInvalid:"Error for filter '{0}': The following characters are not valid: []~$^&/(){}<>+=_-`!@#%?,:;'\".",
                charPlacement:"Error for filter '{0}': '*' must be the right most character.",
                levelLimit:"Level must be less than LogEventLevel.ALL.",
                invalidChars:"Categories can not contain any of the following characters: []`~,!@#$%*^&()]{}+=|';?><./\".",
                invalidLen:"Categories must be at least one character in length."
            };
            return (_local1);
        }

    }
}//package 
﻿package {

    public class _CompiledResourceBundleInfo {

        public static function get compiledLocales():Array{
            return (["en_US"]);
        }
        public static function get compiledResourceBundleNames():Array{
            return (["collections", "core", "logging", "messaging", "rpc", "validators"]);
        }

    }
}//package 
﻿package com.grooveshark.jsQueue {

    public final class QueueChangeEvent {

        public static const QUEUE_RESET:String = "queueReset";
        public static const CONTENT_CHANGE:String = "contentChange";
        public static const PROPERTY_CHANGE:String = "propertyChange";

        public var details:Object;
        public var fullQueue:Object = null;
        public var type:String;

        public function QueueChangeEvent(_arg1:String, _arg2:Object=null){
            this.type = _arg1;
            this.details = ((_arg2) ? _arg2 : {});
        }
    }
}//package com.grooveshark.jsQueue 
﻿package com.grooveshark.jsQueue.commands {
    import flash.events.*;
    import com.grooveshark.jsQueue.*;
    import flash.utils.*;
    import com.grooveshark.framework.*;

    public final class RestoreQueue extends EventDispatcher implements ICommand {

        public var error:Object;
        private var storedQueue:Object;
        private var model:Model;
        private var service:Service;

        public function RestoreQueue(_arg1:Service, _arg2:Model, _arg3:Object){
            this.service = _arg1;
            this.model = _arg2;
            this.storedQueue = _arg3;
        }
        private function onSongCreateComplete(_arg1:Event):void{
            var newQueue:* = null;
            var event:* = _arg1;
            trace("[RestoreQueue] song creation complete");
            try {
                newQueue = QueueJS.createFromStoredQueue(storedQueue, model.songCache, service);
            } catch(e:Error) {
                trace("[RestoreQueue] queue creation failed");
                this.error = {
                    type:"queueRestorationFailed",
                    details:{reason:"Queue creation failed."}
                };
                dispatchEvent(new Event("failed"));
                return;
            };
            model.previousQueue = newQueue;
            dispatchEvent(new Event("complete"));
        }
        private function onSongCreateFailed(_arg1:Event):void{
            trace("[RestoreQueue] song creation failed");
            this.error = {
                type:"queueRestorationFailed",
                details:{reason:"Song creation failed."}
            };
            dispatchEvent(new Event("failed"));
        }
        public function execute():void{
            var _local2:Object;
            var _local3:int;
            var _local4:CreateSongsFromIDs;
            var _local5:Timer;
            var _local1:Array = [];
            for each (_local2 in storedQueue.songs) {
                _local3 = int(_local2.songID);
                if (_local3){
                    _local1.push(_local3);
                };
            };
            if (_local1.length){
                _local4 = new CreateSongsFromIDs(service, model.songCache, _local1);
                _local4.addEventListener(Event.COMPLETE, onSongCreateComplete);
                _local4.addEventListener("failed", onSongCreateFailed);
                _local4.execute();
            } else {
                _local5 = new Timer(100, 1);
                _local5.addEventListener(TimerEvent.TIMER_COMPLETE, onSongCreateComplete);
                _local5.start();
            };
        }

    }
}//package com.grooveshark.jsQueue.commands 
﻿package com.grooveshark.jsQueue.commands {
    import com.grooveshark.jsQueue.*;
    import com.grooveshark.framework.playback.*;
    import com.grooveshark.framework.*;
    import com.grooveshark.jsonrpc.*;
    import com.grooveshark.framework.playback.commands.*;

    public class JSVerifyAutoplay extends VerifyAutoplay {

        public function JSVerifyAutoplay(_arg1:IDualService, _arg2:Queue, _arg3:Boolean=true, _arg4:Object=null){
            super(_arg1, _arg2, _arg3, _arg4);
        }
        override protected function makeSongFromRaw(_arg1:Object):BaseSong{
            var _local3:Array;
            var _local2:BaseSong = (queue as QueueJS).gs_queue::songCache[int(_arg1.SongID)];
            if (!_local2){
                _local2 = new BaseSong();
                _local2.songID = _arg1.SongID;
                _local2.songName = _arg1.SongName;
                _local2.artistID = _arg1.ArtistID;
                _local2.artistName = _arg1.ArtistName;
                _local2.albumID = _arg1.AlbumID;
                _local2.albumName = _arg1.AlbumName;
                _local2.estimateDuration = (int(_arg1.EstimateDuration) * 1000);
                _local2.flags = int(_arg1.Flags);
                if (_arg1.CoverArtUrl){
                    _local3 = String(_arg1.CoverArtUrl).split("/");
                    if (_local3.length){
                        _local2.artFilename = String(_local3[(_local3.length - 1)]).substring(1);
                    };
                };
                (queue as QueueJS).gs_queue::songCache[_local2.songID] = _local2;
            } else {
                if (_arg1.CoverArtUrl){
                    _local3 = String(_arg1.CoverArtUrl).split("/");
                    if (_local3.length){
                        _local2.artFilename = String(_local3[(_local3.length - 1)]).substring(1);
                    };
                };
            };
            return (_local2);
        }

    }
}//package com.grooveshark.jsQueue.commands 
﻿package com.grooveshark.jsQueue.commands {
    import flash.events.*;
    import flash.utils.*;
    import com.grooveshark.framework.*;
    import com.grooveshark.jsonrpc.*;
    import mx.collections.*;
    import com.grooveshark.utils.*;

    public final class CreateSongsFromIDs extends EventDispatcher implements ICommand {

        public var songIDs:Array;
        private var songCache:Dictionary;
        public var results:Array;
        private var service:IDualService;

        public function CreateSongsFromIDs(_arg1:IDualService, _arg2:Dictionary, _arg3:Array){
            this.service = _arg1;
            this.songCache = _arg2;
            this.songIDs = _arg3;
        }
        private function serviceSuccess(_arg1:Object, _arg2:Object=null):void{
            var _local4:Array;
            var _local5:Object;
            var _local6:int;
            var _local7:BaseSong;
            var _local3:Array = ((_arg1 as JSONResult).result as Array);
            if (((_local3) && (_local3.length))){
                _local4 = [];
                for each (_local5 in _local3) {
                    _local7 = songCache[int(_local5.songID)];
                    if (!_local7){
                        _local7 = new BaseSong();
                        _local7.songID = int(_local5.SongID);
                        _local7.songName = String(_local5.Name);
                        _local7.artistID = int(_local5.ArtistID);
                        _local7.artistName = String(_local5.ArtistName);
                        _local7.albumID = int(_local5.AlbumID);
                        _local7.albumName = String(_local5.AlbumName);
                        _local7.flags = int(_local5.Flags);
                        if (_local5.CoverArtFilename){
                            _local7.artFilename = String(_local5.CoverArtFilename);
                        };
                        if (int(_local5.EstimateDuration)){
                            _local7.estimateDuration = (int(_local5.EstimateDuration) * 1000);
                        };
                        songCache[_local7.songID] = _local7;
                    };
                };
                this.results = [];
                for each (_local6 in this.songIDs) {
                    _local7 = songCache[_local6];
                    if (_local7){
                        results.push(_local7);
                    };
                };
                this.dispatchEvent(new Event(Event.COMPLETE));
            } else {
                onFail("No songs returned");
            };
        }
        private function serviceFault(_arg1:Object, _arg2:Object=null):void{
            onFail((_arg1 as JSONFault).message);
        }
        public function execute():void{
            if (songIDs.length){
                service.send(false, "getQueueSongListFromSongIDs", {songIDs:songIDs}, new ItemResponder(serviceSuccess, serviceFault));
            } else {
                onFail("No songIDs provided.");
            };
        }
        private function onFail(_arg1:String):void{
            Debug.getInstance().print((("[CreateSongsFromIDs] Failed: " + _arg1) + " Giving up."));
            dispatchEvent(new Event("failed"));
        }

    }
}//package com.grooveshark.jsQueue.commands 
﻿package com.grooveshark.jsQueue.commands {
    import flash.events.*;
    import com.grooveshark.jsQueue.*;
    import com.grooveshark.framework.playback.*;
    import com.grooveshark.framework.*;
    import com.grooveshark.jsonrpc.*;
    import com.grooveshark.framework.playback.commands.*;

    public class JSAddSongsToQueue extends AddSongsToQueue {

        public function JSAddSongsToQueue(_arg1:IDualService, _arg2:Queue, _arg3:Array, _arg4:int, _arg5:Boolean, _arg6:Boolean, _arg7:Object){
            super(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7);
        }
        private function onSongCreateComplete(_arg1:Event):void{
            var _local5:BaseSong;
            var _local6:int;
            var _local7:int;
            var _local2:int;
            var _local3:Array = [];
            var _local4:int;
            while (_local4 < queueSongs.length) {
                if (!queueSongs[_local4]){
                    _local5 = (queue as QueueJS).gs_queue::songCache[idsToFetch[_local2]];
                    if (_local5){
                        queueSongs[_local4] = new QueueSong(_local5, queue, service, context);
                    } else {
                        _local3.push(_local4);
                    };
                    _local2++;
                };
                _local4++;
            };
            if (_local3.length){
                _local6 = 0;
                while (_local6 < _local3.length) {
                    _local7 = (_local3[_local6] + _local6);
                    queueSongs.splice(_local7, 1);
                    _local6++;
                };
            };
            execute();
        }
        override protected function idToSong(_arg1:int):BaseSong{
            return ((queue as QueueJS).gs_queue::songCache[_arg1]);
        }
        override protected function fetchMissingIDs():void{
            var _local1:CreateSongsFromIDs = new CreateSongsFromIDs(service, (queue as QueueJS).gs_queue::songCache, idsToFetch);
            _local1.addEventListener(Event.COMPLETE, onSongCreateComplete, false, 0, true);
            _local1.addEventListener("failed", onSongCreateFailed, false, 0, true);
            _local1.execute();
        }
        private function onSongCreateFailed(_arg1:Event):void{
            queue.dispatchEvent(new QueueEvent(QueueEvent.ERROR_ADDING_SONGS, QueueEvent.FAILED_TO_CREATE_SONGS, true, {songs:this.items}));
            queue.gs_queue::pendingAdds--;
            dispatchEvent(new Event("failed"));
        }

    }
}//package com.grooveshark.jsQueue.commands 
﻿package com.grooveshark.jsQueue.commands {
    import com.grooveshark.jsQueue.*;
    import com.grooveshark.framework.playback.*;
    import com.grooveshark.framework.*;
    import com.grooveshark.jsonrpc.*;
    import com.grooveshark.framework.playback.commands.*;

    public class JSGetAutoplaySong extends GetAutoplaySong {

        public function JSGetAutoplaySong(_arg1:IDualService, _arg2:Queue){
            super(_arg1, _arg2);
        }
        override protected function makeSongFromRaw(_arg1:Object):BaseSong{
            var _local3:Array;
            var _local2:BaseSong = (queue as QueueJS).gs_queue::songCache[int(_arg1.SongID)];
            if (!_local2){
                _local2 = new BaseSong();
                _local2.songID = _arg1.SongID;
                _local2.songName = _arg1.SongName;
                _local2.artistID = _arg1.ArtistID;
                _local2.artistName = _arg1.ArtistName;
                _local2.albumID = _arg1.AlbumID;
                _local2.albumName = _arg1.AlbumName;
                _local2.estimateDuration = (int(_arg1.EstimateDuration) * 1000);
                _local2.flags = int(_arg1.Flags);
                if (_arg1.CoverArtUrl){
                    _local3 = String(_arg1.CoverArtUrl).split("/");
                    if (_local3.length){
                        _local2.artFilename = String(_local3[(_local3.length - 1)]).substring(1);
                    };
                };
                (queue as QueueJS).gs_queue::songCache[_local2.songID] = _local2;
            } else {
                if (_arg1.CoverArtUrl){
                    _local3 = String(_arg1.CoverArtUrl).split("/");
                    if (_local3.length){
                        _local2.artFilename = String(_local3[(_local3.length - 1)]).substring(1);
                    };
                };
            };
            return (_local2);
        }

    }
}//package com.grooveshark.jsQueue.commands 
﻿package com.grooveshark.jsQueue.commands {
    import com.grooveshark.jsQueue.*;
    import com.grooveshark.framework.playback.*;
    import com.grooveshark.framework.*;
    import com.grooveshark.jsonrpc.*;
    import com.grooveshark.framework.playback.commands.*;

    public class JSRefreshPendingAutoplaySong extends RefreshPendingAutoplaySong {

        public function JSRefreshPendingAutoplaySong(_arg1:IDualService, _arg2:Queue, _arg3:QueueSong, _arg4:Boolean=false){
            super(_arg1, _arg2, _arg3, _arg4);
        }
        override protected function makeSongFromRaw(_arg1:Object):BaseSong{
            var _local3:Array;
            var _local2:BaseSong = (queue as QueueJS).gs_queue::songCache[int(_arg1.SongID)];
            if (!_local2){
                _local2 = new BaseSong();
                _local2.songID = _arg1.SongID;
                _local2.songName = _arg1.SongName;
                _local2.artistID = _arg1.ArtistID;
                _local2.artistName = _arg1.ArtistName;
                _local2.albumID = _arg1.AlbumID;
                _local2.albumName = _arg1.AlbumName;
                _local2.estimateDuration = (int(_arg1.EstimateDuration) * 1000);
                _local2.flags = int(_arg1.Flags);
                if (_arg1.CoverArtUrl){
                    _local3 = String(_arg1.CoverArtUrl).split("/");
                    if (_local3.length){
                        _local2.artFilename = String(_local3[(_local3.length - 1)]).substring(1);
                    };
                };
                (queue as QueueJS).gs_queue::songCache[_local2.songID] = _local2;
            } else {
                if (_arg1.CoverArtUrl){
                    _local3 = String(_arg1.CoverArtUrl).split("/");
                    if (_local3.length){
                        _local2.artFilename = String(_local3[(_local3.length - 1)]).substring(1);
                    };
                };
            };
            return (_local2);
        }

    }
}//package com.grooveshark.jsQueue.commands 
﻿package com.grooveshark.jsQueue {
    import flash.events.*;
    import mx.rpc.*;
    import com.grooveshark.jsonrpc.events.*;
    import mx.events.*;
    import com.grooveshark.jsonrpc.*;
    import mx.collections.*;
    import flash.net.*;
    import com.adobe.crypto.*;

    public final class Service extends EventDispatcher implements IDualService {

        protected var currentToken:String;
        private var _299803597hostname:String;
        private var secretKey:String;
        protected var lastRandomizer:String;
        protected var _uuid:String;
        private var _1363930334allowHTTPS:Boolean = true;
        private var expired:Boolean = false;
        protected var newTokenPending:Boolean;
        private var _958078572defaultScript:String;
        protected var service:JSONService;
        protected var lso:SharedObject;
        protected var _privacy:uint;
        protected var _country:Object;
        protected var _session:String;
        protected var tokenExpires:Number = 0;
        protected var pendingCalls:Array;

        public function Service(_arg1:String, _arg2:String, _arg3:String, _arg4:String="", _arg5:String="", _arg6:Boolean=true, _arg7:String=""){
            var hostname:* = _arg1;
            var defaultScript:* = _arg2;
            var revision:* = _arg3;
            var session:String = _arg4;
            var uuid:String = _arg5;
            var allowHTTPS:Boolean = _arg6;
            var secretKey:String = _arg7;
            pendingCalls = [];
            super();
            this.service = new JSONService();
            this.service.addEventListener(HeaderEvent.HEADER, onHeader);
            this.service.addEventListener(ResultEvent.RESULT, onResult);
            this.service.addEventListener(FaultEvent.FAULT, onFault);
            this.addHeader("clientRevision", revision);
            this.addHeader("client", "jsqueue");
            this.addHeader("privacy", 0);
            this.hostname = hostname;
            this.defaultScript = defaultScript;
            this.session = session;
            this.uuid = uuid;
            this.allowHTTPS = allowHTTPS;
            this.secretKey = secretKey;
            try {
                lso = SharedObject.getLocal("gsGlobal", "/");
            } catch(e:Error) {
                trace("gsGlobal lso disabled or inaccessible");
                lso = null;
            };
        }
        public function fetchCountry():void{
            if (((((lso) && (lso.data))) && (lso.data.country))){
                this.country = lso.data.country;
            } else {
                this.send(false, "getCountry", null, new ItemResponder(countrySuccess, countryFault));
            };
        }
        public function get privacy():uint{
            return (_privacy);
        }
        private function onFault(_arg1:FaultEvent):void{
            dispatchEvent(_arg1.clone());
            if ((_arg1.fault.code & 0x0100)){
                invalidateToken();
            };
        }
        protected function countrySuccess(_arg1:Object, _arg2:Object=null):void{
            var jsonResult:* = _arg1;
            var token = _arg2;
            var result:* = (jsonResult as JSONResult).result;
            if (result){
                this.country = result;
                if (lso){
                    lso.data.country = result;
                    try {
                        lso.flush();
                    } catch(e:Error) {
                    };
                };
            } else {
                this.country = {
                    ID:223,
                    CC1:"0",
                    CC2:"0",
                    CC3:"0",
                    CC4:"2147483648"
                };
            };
        }
        public function addHeader(_arg1:String, _arg2:Object):void{
            trace(((("[Service] addHeader " + _arg1) + ":") + _arg2));
            service.addHeader(_arg1, _arg2);
            if (_arg1 == "session"){
                invalidateToken();
            };
        }
        public function get session():String{
            return (_session);
        }
        public function expire():void{
            this.expired = true;
        }
        protected function invalidateToken():void{
            currentToken = "";
            tokenExpires = 0;
        }
        private function set _314498168privacy(_arg1:uint):void{
            if (_arg1 !== _privacy){
                _privacy = _arg1;
                this.addHeader("privacy", _arg1);
            };
        }
        public function set privacy(_arg1:uint):void{
            var _local2:Object = this.privacy;
            if (_local2 !== _arg1){
                this._314498168privacy = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "privacy", _local2, _arg1));
            };
        }
        public function get allowHTTPS():Boolean{
            return (this._1363930334allowHTTPS);
        }
        private function set _1984987798session(_arg1:String):void{
            if (_arg1 !== _session){
                _session = _arg1;
                this.addHeader("session", _arg1);
            };
        }
        public function removeHeader(_arg1:String):void{
            service.removeHeader(_arg1);
        }
        public function get country():Object{
            return (_country);
        }
        public function get hostname():String{
            return (this._299803597hostname);
        }
        public function get uuid():String{
            return (_uuid);
        }
        public function getClient():String{
            return (this.service.headers.client);
        }
        public function set allowHTTPS(_arg1:Boolean):void{
            var _local2:Object = this._1363930334allowHTTPS;
            if (_local2 !== _arg1){
                this._1363930334allowHTTPS = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "allowHTTPS", _local2, _arg1));
            };
        }
        private function onHeader(_arg1:HeaderEvent):void{
            if (_arg1.header.expiredClient){
                this.expired = true;
            };
            dispatchEvent(_arg1.clone());
        }
        protected function countryFault(_arg1:Object, _arg2:Object=null):void{
            this.country = {
                ID:223,
                CC1:"0",
                CC2:"0",
                CC3:"0",
                CC4:"2147483648"
            };
        }
        private function set _957831062country(_arg1:Object):void{
            if (_arg1 !== _country){
                _country = _arg1;
                this.addHeader("country", _arg1);
            };
        }
        private function makeNewRandomizer():String{
            var _local1 = "";
            var _local2:int;
            while (_local2 < 6) {
                _local1 = (_local1 + Math.floor((Math.random() * 16)).toString(16));
                _local2++;
            };
            return (((_local1)!==lastRandomizer) ? _local1 : makeNewRandomizer());
        }
        public function set defaultScript(_arg1:String):void{
            var _local2:Object = this._958078572defaultScript;
            if (_local2 !== _arg1){
                this._958078572defaultScript = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "defaultScript", _local2, _arg1));
            };
        }
        public function set session(_arg1:String):void{
            var _local2:Object = this.session;
            if (_local2 !== _arg1){
                this._1984987798session = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "session", _local2, _arg1));
            };
        }
        public function send(_arg1:Boolean, _arg2:String, _arg3:Object=null, _arg4:IResponder=null, _arg5:String="", _arg6:Object=null, _arg7:String=""):void{
            var _local9:JSONFault;
            var _local10:String;
            var _local11:String;
            var _local12:String;
            var _local13:String;
            var _local14:String;
            if (this.expired){
                if (_arg4){
                    _local9 = new JSONFault(JSONFault.CLIENT_EXPIRED, "Client expired", "", _arg2);
                    _arg4.fault(_local9);
                };
                return;
            };
            var _local8:Date = new Date();
            if (((((((tokenExpires) && ((tokenExpires > _local8.getTime())))) || ((_arg2 == "initiateSession")))) || ((_arg2 == "getCommunicationToken")))){
                _local10 = ((((_arg1) && (allowHTTPS))) ? "https://" : "http://");
                _local11 = ((_arg5) ? _arg5 : defaultScript);
                _local12 = ((_arg7) ? _arg7 : secretKey);
                _local13 = (((_local10 + hostname) + "/") + _local11);
                if (_local13.indexOf("?") != -1){
                    _local13 = (_local13 + "&");
                } else {
                    _local13 = (_local13 + "?");
                };
                _local13 = (_local13 + _arg2);
                service.url = _local13;
                if (!_arg6){
                    _arg6 = {};
                };
                if (((((!((_arg2 == "initiateSession"))) && (!((_arg2 == "getCommunicationToken"))))) && (!(_arg6["token"])))){
                    lastRandomizer = makeNewRandomizer();
                    _local14 = SHA1.hash(((((((_arg2 + ":") + currentToken) + ":") + _local12) + ":") + lastRandomizer));
                    _local14 = (lastRandomizer + _local14);
                    _arg6["token"] = _local14;
                };
                if (!_arg6["client"]){
                    _arg6["client"] = "jsqueue";
                };
                service.send(_arg2, _arg3, _arg6, _arg4);
            } else {
                pendingCalls.push({
                    isSecure:_arg1,
                    methodName:_arg2,
                    params:_arg3,
                    responder:_arg4,
                    overrideScript:_arg5,
                    extraHeaders:_arg6
                });
                if (!newTokenPending){
                    fetchToken();
                };
            };
        }
        protected function fetchToken():void{
            if (!newTokenPending){
                newTokenPending = true;
                dispatchEvent(new ServiceEvent(ServiceEvent.TOKEN_NEEDED));
            };
        }
        private function set _3601339uuid(_arg1:String):void{
            if (_arg1 !== _uuid){
                _uuid = _arg1;
                this.addHeader("uuid", _arg1);
            };
        }
        private function onResult(_arg1:ResultEvent):void{
            dispatchEvent(_arg1.clone());
        }
        public function set country(_arg1:Object):void{
            var _local2:Object = this.country;
            if (_local2 !== _arg1){
                this._957831062country = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "country", _local2, _arg1));
            };
        }
        public function set hostname(_arg1:String):void{
            var _local2:Object = this._299803597hostname;
            if (_local2 !== _arg1){
                this._299803597hostname = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "hostname", _local2, _arg1));
            };
        }
        public function get defaultScript():String{
            return (this._958078572defaultScript);
        }
        public function resetToken(_arg1:String):void{
            var _local3:Object;
            var _local2:Date = new Date();
            tokenExpires = (_local2.getTime() + ((1000 * 60) * 25));
            currentToken = _arg1;
            newTokenPending = false;
            if (pendingCalls.length){
                while ((_local3 = pendingCalls.shift())) {
                    send(_local3.isSecure, _local3.methodName, _local3.params, _local3.responder, _local3.overrideScript, _local3.extraHeaders);
                };
            };
        }
        public function clearHeaders():void{
            service.clearHeaders();
        }
        public function set uuid(_arg1:String):void{
            var _local2:Object = this.uuid;
            if (_local2 !== _arg1){
                this._3601339uuid = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "uuid", _local2, _arg1));
            };
        }

    }
}//package com.grooveshark.jsQueue 
﻿package com.grooveshark.jsQueue {
    import mx.events.*;
    import com.grooveshark.framework.playback.*;
    import flash.utils.*;
    import com.grooveshark.framework.*;
    import com.grooveshark.jsonrpc.*;
    import com.grooveshark.jsQueue.commands.*;
    import com.grooveshark.framework.playback.commands.*;

    public final class QueueJS extends Queue {

        gs_queue var songCache:Dictionary;

        public function QueueJS(_arg1:IDualService, _arg2:Dictionary, _arg3:Boolean=true, _arg4:Boolean=false){
            super(_arg1, _arg3, _arg4);
            this.gs_queue::songCache = _arg2;
            this.gs_queue::chunkSize = 1000;
            this.gs_queue::maxChunks = 1;
        }
        public static function createFromStoredQueue(_arg1:Object, _arg2:Dictionary, _arg3:IDualService, _arg4:Boolean=false, _arg5:Boolean=false):QueueJS{
            var _local8:Object;
            var _local9:int;
            var _local10:Object;
            var _local11:BaseSong;
            var _local12:QueueSong;
            var _local13:Array;
            var _local6:QueueJS;
            var _local7:int;
            if (((_arg1) && ((_arg1.version == 1)))){
                _local6 = new QueueJS(_arg3, _arg2, _arg4, false);
                for each (_local8 in _arg1.songs) {
                    _local11 = _arg2[int(_local8.songID)];
                    if (_local11){
                        _local12 = new QueueSong(_local11, _local6, _arg3);
                        _local12.queueSongID = int(_local8.queueSongID);
                        _local12.gs_queue::_autoplayVote = int(_local8.autoplayVote);
                        _local12.sponsoredAutoplayID = int(_local8.sponsoredAutoplayID);
                        _local12.source = String(_local8.source);
                        if (_local8.context){
                            _local12.context = _local8.context;
                        };
                        _local6.gs_queue::source.push(_local12);
                        _local12.addEventListener(PlayableSongEvent.SONG_FLAGGED, _local6.onSongFlagged);
                        _local12.addEventListener(PlayableSongEvent.SONG_VOTE_FAILED, _local6.onSongVoteFailed);
                        _local12.addEventListener(PropertyChangeEvent.PROPERTY_CHANGE, _local6.dirtySong);
                        _local13 = _local6.gs_queue::queueSongLookupBySongID[_local12.song.songID];
                        if (_local13){
                            _local13.push(_local12);
                        } else {
                            _local6.gs_queue::queueSongLookupBySongID[_local12.song.songID] = [_local12];
                        };
                        _local6.gs_queue::queueSongLookupByQueueSongID[_local12.queueSongID] = _local12;
                        if (_local12.queueSongID > _local7){
                            _local7 = _local12.queueSongID;
                        };
                    };
                };
                for each (_local9 in _arg1.playedSongs) {
                    _local12 = _local6.gs_queue::queueSongLookupByQueueSongID[_local9];
                    if (_local12){
                        _local6.gs_queue::playedSongs.push(_local12);
                    };
                };
                for each (_local9 in _arg1.pendingSongs) {
                    _local12 = _local6.gs_queue::queueSongLookupByQueueSongID[_local9];
                    if (_local12){
                        _local6.gs_queue::pendingSongs.push(_local12);
                    };
                };
                _local6.queueID = String(_arg1.queueID);
                _local6.lastPlaylistID = int(_arg1.lastPlaylistID);
                _local6.autoAutoplayDisabled = Boolean(_arg1.autoAutoplayDisabled);
                _local6.shuffleEnabled = Boolean(_arg1.shuffleEnabled);
                _local6.repeatMode = int(_arg1.repeatMode);
                _local6.crossfadeEnabled = Boolean(_arg1.crossfadeEnabled);
                _local10 = _arg1.crossfadeAmount;
                if (_local10 != null){
                    _local6.crossfadeAmount = int(_local10);
                };
                _local6.crossfadeInOutEnabled = Boolean(_arg1.crossfadeInOutEnabled);
                if (_arg1.currentAutoplayTagID){
                    _local6.currentAutoplayTag = Tag.tagIDLookup[_arg1.currentAutoplayTagID];
                };
                _local12 = _local6.gs_queue::queueSongLookupByQueueSongID[int(_arg1.activeSong)];
                if (_local12){
                    _local6.gs_queue::_activeSong = _local12;
                } else {
                    if (_local6.length){
                        _local6.gs_queue::_activeSong = (_local6.getItemAt(0) as QueueSong);
                    };
                };
                for each (_local12 in _local6) {
                    _local12.gs_queue::recalcEligibleForAutoplayRemoval();
                };
                _local6.gs_queue::autoplayStatus = AutoplayStatus.createFromStoredParams(_local6, _arg1.autoplayStatus);
                if (_arg5){
                    _local6.setAutoplayEnabled(true, Boolean(_arg1.autoplayUserInitiated), false);
                } else {
                    _local6.gs_queue::_autoplayEnabled = Boolean(_arg1.autoplayEnabled);
                    _local6.gs_queue::autoplayUserInitiated = Boolean(_arg1.autoplayUserInitiated);
                };
            };
            _local6.gs_queue::songCount = (_local7 + 1);
            return (_local6);
        }

        override protected function generateGetAutoplaySong():void{
            var _local1:QueueCommand = new JSGetAutoplaySong(service, this);
            this.gs_queue::commandQueue.queueCommand(_local1);
        }
        override gs_queue function completeRemoveSongs(_arg1:Array):void{
            var _local2:QueueSong;
            super.gs_queue::completeRemoveSongs(_arg1);
            for each (_local2 in _arg1) {
                _local2.removeEventListener(PropertyChangeEvent.PROPERTY_CHANGE, dirtySong);
            };
        }
        public function createStoredQueue():Object{
            var _local2:QueueSong;
            var _local3:Object;
            var _local1:Object = {};
            _local1.version = 1;
            _local1.queueID = this.queueID;
            _local1.lastPlaylistID = this.lastPlaylistID;
            _local1.autoAutoplayDisabled = this.autoAutoplayDisabled;
            _local1.autoplayUserInitiated = this.gs_queue::autoplayUserInitiated;
            _local1.autoplayEnabled = this.autoplayEnabled;
            _local1.shuffleEnabled = this.shuffleEnabled;
            _local1.repeatMode = this.repeatMode;
            _local1.currentAutoplayTagID = ((this.currentAutoplayTag) ? this.currentAutoplayTag.tagID : 0);
            _local1.crossfadeEnabled = this.crossfadeEnabled;
            _local1.crossfadeAmount = this.crossfadeAmount;
            _local1.crossfadeInOutEnabled = this.crossfadeInOutEnabled;
            _local1.activeSong = ((this.activeSong) ? this.activeSong.queueSongID : 0);
            _local1.playedSongs = [];
            for each (_local2 in this.gs_queue::playedSongs) {
                if (_local2){
                    _local1.playedSongs.push(_local2.queueSongID);
                };
            };
            _local1.pendingSongs = [];
            for each (_local2 in this.gs_queue::pendingSongs) {
                if (_local2){
                    _local1.pendingSongs.push(_local2.queueSongID);
                };
            };
            _local1.songs = [];
            for each (_local2 in this) {
                if (_local2){
                    _local3 = {};
                    _local3.songID = _local2.song.songID;
                    _local3.queueSongID = _local2.queueSongID;
                    _local3.autoplayVote = _local2.gs_queue::_autoplayVote;
                    _local3.sponsoredAutoplayID = _local2.sponsoredAutoplayID;
                    _local3.source = _local2.source;
                    _local3.context = _local2.context;
                    _local1.songs.push(_local3);
                };
            };
            _local1.autoplayStatus = ((this.gs_queue::autoplayStatus) ? this.gs_queue::autoplayStatus.createStoredParams() : null);
            return (_local1);
        }
        override protected function generateAddSongsToQueue(_arg1:Array, _arg2:int, _arg3:Boolean, _arg4:Boolean, _arg5:Object):void{
            var _local6:QueueCommand = new JSAddSongsToQueue(service, this, _arg1, _arg2, _arg3, _arg4, _arg5);
            this.gs_queue::commandQueue.queueCommand(_local6);
        }
        private function dirtySong(_arg1:PropertyChangeEvent):void{
            var _local2:QueueSong = (_arg1.currentTarget as QueueSong);
            if (_local2){
                switch (_arg1.property){
                    case "queueSongID":
                    case "autoplayVote":
                    case "source":
                    case "sponsoredAutoplayID":
                    case "songID":
                    case "songName":
                    case "artistID":
                    case "artistName":
                    case "albumID":
                    case "albumName":
                    case "estimateDuration":
                        this.dispatchEvent(new SongEvent(SongEvent.SONG_DIRTY, _local2));
                        break;
                };
            };
        }
        override protected function generateVerifyAutoplay(_arg1:Boolean=true, _arg2:Object=null):void{
            var _local3:QueueCommand = new JSVerifyAutoplay(service, this, _arg1, _arg2);
            this.gs_queue::commandQueue.queueCommand(_local3);
        }
        override gs_queue function completeAddSongsAt(_arg1:Array, _arg2:int, _arg3:Boolean, _arg4:Boolean, _arg5:QueueSong=null):void{
            var _local6:QueueSong;
            super.gs_queue::completeAddSongsAt(_arg1, _arg2, _arg3, _arg4, _arg5);
            for each (_local6 in _arg1) {
                _local6.addEventListener(PropertyChangeEvent.PROPERTY_CHANGE, dirtySong);
            };
        }
        override protected function generateRefreshPendingAutoplaySong(_arg1:QueueSong, _arg2:Boolean=false):void{
            var _local3:QueueCommand = new JSRefreshPendingAutoplaySong(service, this, _arg1, _arg2);
            this.gs_queue::commandQueue.queueCommand(_local3);
        }
        override public function addItemsFromPlaylistAt(_arg1:BasePlaylist, _arg2:int=-1, _arg3:Boolean=false):void{
            throw (new Error("QueueJS does not support adding playlists, add as songs instead"));
        }

    }
}//package com.grooveshark.jsQueue 
﻿package com.grooveshark.jsQueue {
    import flash.events.*;

    public final class ServiceEvent extends Event {

        public static const INVALID_CLIENT:String = "invalidClient";
        public static const TOKEN_FAILURE:String = "tokenFailure";
        public static const TOKEN_NEEDED:String = "tokenNeeded";
        public static const SERVICE_ERROR:String = "serviceError";
        public static const MAINTENANCE_MODE:String = "maintenanceMode";

        public var detail:String;

        public function ServiceEvent(_arg1:String, _arg2:String="", _arg3:Boolean=false, _arg4:Boolean=false){
            super(_arg1, _arg3, _arg4);
            this.detail = _arg2;
        }
        override public function clone():Event{
            return (new ServiceEvent(this.type, this.detail, this.bubbles, this.cancelable));
        }

    }
}//package com.grooveshark.jsQueue 
﻿package com.grooveshark.jsQueue {
    import flash.events.*;
    import mx.rpc.*;
    import flash.display.*;
    import mx.events.*;
    import com.grooveshark.socket.*;
    import com.grooveshark.framework.playback.*;
    import flash.utils.*;
    import com.grooveshark.framework.*;
    import com.adobe.serialization.json.*;
    import mx.collections.*;
    import mx.rpc.http.*;
    import mx.validators.*;
    import flash.media.*;
    import flash.system.*;
    import com.adobe.crypto.*;
    import com.grooveshark.jsQueue.commands.*;
    import flash.external.*;

    public class Controller {

        public static const RAPLEAF_ACCT_ID:String = "44241";
        public static const RAPLEAF_PERSONLIZE_URL_VISIT:String = "http://personalize.rlcdn.com/v4/wv";
        public static const RAPLEAF_API_KEY:String = "b1d31b086b1d9469ee82de9c7fa2b778";
        public static const RAPLEAF_PERSONLIZE_URL_DIRECT:String = "https://personalize.rlcdn.com/v4/dr";

        private const SETUP:Class;
        private const PROXY_ALLOWED:Array;
        private const API:Class;

        private var needToken:Boolean;
        private var lastFMAudioScrobblerURL:String = "http://ws.audioscrobbler.com/2.0/";
        private var _model:Model;
        private var playStatusDirty:Boolean;
        private var serviceController:String;
        private var queueDirty:Array;
        private var playerReady:Boolean;
        private var culmulativeSeconds:Number = 0;
        private var propsDirty:Boolean;
        private var propertyChangeCallback:String;
        private var playbackStatusCallback:String;
        private var allowedHTTPMethods:Array;
        private var playerController:String;
        private var errorCallback:String;
        private var songsDirty:Array;
        private var _service:Service;
        private var queueChangeCallback:String;
        private var computeSpectrumCallback:String;
        private var ready:Boolean;
        private var useFFT:Boolean = false;
        private var thirdPartyLoader:HTTPService;
        private var songPropertyChangeCallback:String;
        private var playerCreated:Boolean;
        private var zoomChangeCallback:String;
        private var spectrum:ByteArray;
        private var lastWidth:int = 10;
        private var _activeSong:QueueSong;
        private var _chatClient:JSONChatClient;
        private var lastfmSecret:String = "f8ed9c4ea2f1b981e61e1d0df1a98406";
        private var serviceReady:Boolean;
        private var setupString:String;
        private var _currentQueue:Queue;
        private var stage:Stage;

        public function Controller(_arg1:Model, _arg2:Stage, _arg3:String, _arg4:String, _arg5:String){
            API = Controller_API;
            SETUP = Controller_SETUP;
            songsDirty = [];
            queueDirty = [];
            PROXY_ALLOWED = ["initiateSession", "getCommunicationToken", "userForgotPassword", "getUserByInviteID", "getGoogleAuthToken", "getGoogleContacts", "getDetailsForBroadcast", "broadcastSong", "getUserFacebookDataEx", "saveUserFacebookDataEx", "updateUserFacebookData", "getUserGoogleData", "getUserTwitterData", "authenticateUser", "authenticateFacebookUser", "authenticateGoogleUser", "authenticateTwitterUser", "authenticateLastfmUser", "reportUserChange", "changePassword", "resetPassword", "registerUser", "registerFacebookUser", "registerGoogleUser", "registerTwitterUser", "registerLastfmUser", "getLastfmService", "getThemeFromDFP", "getSubscriptionDetails", "userDisableAccount", "changeUserInfoEx", "isFirstVisit", "getClearvoiceMemberInfo", "saveClearvoiceMemberInfo", "addClearvoiceAnswers", "getUserIDByClearvoiceEmail", "saveUserAnswers", "finalizeUserSurvey", "getTunipopID", "getNotificationFromDFP", "getSubscriptionHistory"];
            allowedHTTPMethods = ["GET", "POST", "HEAD", "OPTIONS", "PUT", "TRACE", "DELETE"];
            spectrum = new ByteArray();
            super();
            this.model = _arg1;
            this.playerController = _arg4;
            this.serviceController = _arg5;
            this.stage = _arg2;
            this.thirdPartyLoader = new HTTPService();
            this.thirdPartyLoader.resultFormat = "text";
            if (!ExternalInterface.available){
                trace("ExternalInterface not available. Shouldn't have gotten this far.");
                return;
            };
            ExternalInterface.addCallback("getApplicationVersion", getApplicationVersion);
            ExternalInterface.addCallback("expireService", expireService);
            ExternalInterface.addCallback("getEverything", getEverything);
            ExternalInterface.addCallback("getVolume", getVolume);
            ExternalInterface.addCallback("setVolume", setVolume);
            ExternalInterface.addCallback("getIsMuted", getIsMuted);
            ExternalInterface.addCallback("setIsMuted", setIsMuted);
            ExternalInterface.addCallback("getCrossfadeAmount", getCrossfadeAmount);
            ExternalInterface.addCallback("setCrossfadeAmount", setCrossfadeAmount);
            ExternalInterface.addCallback("getCrossfadeEnabled", getCrossfadeEnabled);
            ExternalInterface.addCallback("setCrossfadeEnabled", setCrossfadeEnabled);
            ExternalInterface.addCallback("getPlayPauseFade", getPlayPauseFade);
            ExternalInterface.addCallback("setPlayPauseFade", setPlayPauseFade);
            ExternalInterface.addCallback("getPrefetchEnabled", getPrefetchEnabled);
            ExternalInterface.addCallback("setPrefetchEnabled", setPrefetchEnabled);
            ExternalInterface.addCallback("getLowerQuality", getLowerQuality);
            ExternalInterface.addCallback("setLowerQuality", setLowerQuality);
            ExternalInterface.addCallback("setPersistShuffle", setPersistShuffle);
            ExternalInterface.addCallback("setPropertyChangeCallback", setPropertyChangeCallback);
            ExternalInterface.addCallback("getSongDetails", getSongDetails);
            ExternalInterface.addCallback("setSongPropertyChangeCallback", setSongPropertyChangeCallback);
            ExternalInterface.addCallback("getCurrentQueue", getCurrentQueue);
            ExternalInterface.addCallback("getPreviousQueue", getPreviousQueue);
            ExternalInterface.addCallback("setQueueChangeCallback", setQueueChangeCallback);
            ExternalInterface.addCallback("getPlaybackStatus", getPlaybackStatus);
            ExternalInterface.addCallback("setPlaybackStatusCallback", setPlaybackStatusCallback);
            ExternalInterface.addCallback("setComputeSpectrumCallback", setComputeSpectrumCallback);
            ExternalInterface.addCallback("setErrorCallback", setErrorCallback);
            ExternalInterface.addCallback("addSongsToQueueAt", addSongsToQueueAt);
            ExternalInterface.addCallback("removeSongs", removeSongs);
            ExternalInterface.addCallback("moveSongsTo", moveSongsTo);
            ExternalInterface.addCallback("setActiveSong", setActiveSong);
            ExternalInterface.addCallback("clearQueue", clearQueue);
            ExternalInterface.addCallback("restoreQueue", restoreQueue);
            ExternalInterface.addCallback("getQueueIsRestorable", getQueueIsRestorable);
            ExternalInterface.addCallback("storeQueue", storeQueue);
            ExternalInterface.addCallback("setAutoplay", setAutoplay);
            ExternalInterface.addCallback("setShuffle", setShuffle);
            ExternalInterface.addCallback("getShuffle", getShuffle);
            ExternalInterface.addCallback("setRepeat", setRepeat);
            ExternalInterface.addCallback("playSong", playSong);
            ExternalInterface.addCallback("pauseSong", pauseSong);
            ExternalInterface.addCallback("resumeSong", resumeSong);
            ExternalInterface.addCallback("stopSong", stopSong);
            ExternalInterface.addCallback("nextSong", nextSong);
            ExternalInterface.addCallback("previousSong", previousSong);
            ExternalInterface.addCallback("seekTo", seekTo);
            ExternalInterface.addCallback("voteSong", voteSong);
            ExternalInterface.addCallback("flagSong", flagSong);
            ExternalInterface.addCallback("swfProxy", swfProxy);
            ExternalInterface.addCallback("setZoomChangeCallback", setZoomChangeCallback);
            ExternalInterface.addCallback("getCulmulativeListenTime", getCulmulativeListenTime);
            ExternalInterface.addCallback("setChatServers", setChatServers);
            ExternalInterface.addCallback("prefetchStreamKeys", prefetchStreamKeys);
            setupString = new this.SETUP();
            setupString = setupString.replace(/SWFNAME/g, _arg3);
            setupString = setupString.replace(/PLAYER_CONTROLLER/g, _arg4);
            setupString = setupString.replace(/SERVICE_CONTROLLER/g, _arg5);
            _arg2.addEventListener(Event.ENTER_FRAME, handleCallbacks);
        }
        private function getTunipopID(_arg1:Object, _arg2:Object, _arg3:String):void{
            var _local6:String;
            var _local7:AsyncToken;
            var _local4:String = ((((_arg1.parameters) && (_arg1.parameters.brand))) ? _arg1.parameters.brand : "");
            var _local5:String = ((((_arg1.parameters) && (_arg1.parameters.artist))) ? _arg1.parameters.artist : "");
            if (_local4){
                _local6 = ("&qufr=2&Brand=" + encodeURIComponent(_local4));
            } else {
                if (_local5){
                    _local6 = ("&qufr=3&Artist=" + encodeURIComponent(_local5));
                };
            };
            if (_local6){
                thirdPartyLoader.method = "GET";
                thirdPartyLoader.url = ("https://query.tunipop.net/MerchLocator/RequestMerch.php?qucx=mm&rtid=7300" + _local6);
                _local7 = thirdPartyLoader.send();
                _local7.addResponder(new ItemResponder(tunipopResult, tunipopFault, {
                    request:_arg1,
                    key:_arg3
                }));
            } else {
                reportRequestFailure({
                    code:0,
                    message:"Missing required parameter: brand or artist"
                }, _arg3);
            };
        }
        private function buildPlaybackStatus():Object{
            var _local1:Object;
            if (activeSong){
                _local1 = {
                    activeSong:buildSong(activeSong),
                    bytesLoaded:activeSong.bytesLoaded,
                    bytesTotal:activeSong.bytesTotal,
                    position:activeSong.position,
                    duration:activeSong.duration,
                    status:activeSong.playStatus,
                    currentStreamServer:activeSong.currentStreamServer
                };
            };
            if (((((_local1) && (_local1.activeSong))) && (currentQueue))){
                _local1.activeSong.index = currentQueue.getItemIndex(activeSong);
            };
            return (_local1);
        }
        private function parseGoogXML(_arg1:String):Array{
            var contact:* = null;
            var item:* = null;
            var isValid:* = false;
            var e:* = null;
            var vr:* = null;
            var rawXML:* = _arg1;
            var validator:* = new EmailValidator();
            var xml:* = new XML(rawXML);
            var gd:* = new Namespace("gd", "http://schemas.google.com/g/2005");
            var items:* = xml.channel.item;
            var contacts:* = [];
            for each (item in items) {
                contact = new Object();
                contact.title = String(XMLList(item).title.text());
                contact.address = String(XMLList(item).gd::email.(attribute("primary") == "true").@address);
                if (contact.address){
                    isValid = true;
                    e = EmailValidator.validateEmail(validator, contact.address, "");
                    if (e.length){
                        for each (vr in e) {
                            if (vr.isError){
                                isValid = false;
                                break;
                            };
                        };
                    };
                    if (isValid){
                        contacts.push(contact);
                    };
                };
            };
            return (contacts);
        }
        private function onQueuePropChange(_arg1:PropertyChangeEvent):void{
            var _local2:QueueChangeEvent;
            switch (_arg1.property){
                case "activeSong":
                    activeSong = (_arg1.newValue as QueueSong);
                case "queueID":
                case "nextSong":
                case "previousSong":
                case "autoplayEnabled":
                case "autoplayEnabled":
                case "shuffleEnabled":
                case "repeatMode":
                case "currentAutoplayTag":
                    _local2 = new QueueChangeEvent(QueueChangeEvent.PROPERTY_CHANGE, _arg1.property);
                    queueDirty.push(_local2);
                    break;
                case "crossfadeAmount":
                case "crossfadeEnabled":
                case "crossfadeInOutEnabled":
                    propsDirty = true;
                    break;
            };
        }
        public function removeSongs(_arg1:Array):void{
            var _local2:Array;
            var _local3:int;
            var _local4:QueueSong;
            if (model.currentQueue){
                _local2 = [];
                for each (_local3 in _arg1) {
                    _local4 = model.currentQueue.gs_queue::queueSongLookupByQueueSongID[_local3];
                    if (_local4){
                        _local2.push(_local4);
                    };
                };
                model.currentQueue.removeItems(_local2);
            };
        }
        public function getPlayPauseFade():Boolean{
            return (model.playPauseFadeEnabled);
        }
        private function onAutoplayVoteError(_arg1:QueueEvent):void{
            var _local2:Object = {
                type:_arg1.type,
                details:{}
            };
            _local2.details.song = buildSong((_arg1.extra.song as QueueSong));
            this.reportError(_local2);
        }
        public function getCrossfadeAmount():int{
            return (model.crossfadeAmount);
        }
        public function moveSongsTo(_arg1:Array, _arg2:int):void{
            var _local3:Array;
            var _local4:int;
            var _local5:QueueSong;
            if (model.currentQueue){
                _local3 = [];
                for each (_local4 in _arg1) {
                    _local5 = model.currentQueue.gs_queue::queueSongLookupByQueueSongID[_local4];
                    if (_local5){
                        _local3.push(_local5);
                    };
                };
                model.currentQueue.moveItemsTo(_local3, _arg2);
            };
        }
        public function getVolume():Number{
            return (model.volume);
        }
        public function setComputeSpectrumCallback(_arg1:String, _arg2:Boolean=false):void{
            if (_arg1){
                PlayableSong.checkPolicyFile = true;
                if (((activeSong) && (activeSong.currentStreamServer))){
                    Security.loadPolicyFile((activeSong.currentStreamServer + "/crossdomain.xml"));
                };
            } else {
                PlayableSong.checkPolicyFile = false;
            };
            this.computeSpectrumCallback = _arg1;
            this.useFFT = _arg2;
        }
        public function swfProxy(_arg1:Object, _arg2:Object, _arg3:String):void{
            var _local4:Object;
            var _local5:Function;
            if (!_arg1){
                reportRequestFailure({
                    code:0,
                    message:"Null request object"
                }, _arg3);
                return;
            };
            trace(((("swfProxy: " + _arg1.type) + ": ") + _arg1.method));
            switch (_arg1.type){
                case "normal":
                default:
                    this.synchronizeHeaders(_arg2);
                    _local4 = {client:"htmlshark"};
                    if (_arg2.clientRevision){
                        _local4.clientRevision = _arg2.clientRevision;
                    };
                    if (PROXY_ALLOWED.indexOf(_arg1.method) != -1){
                        switch (_arg1.method){
                            case "getStoredUsers":
                            case "deleteStoredUser":
                            case "loginStoredUser":
                            case "reportUserChange":
                            case "getThemeFromDFP":
                            case "getNotificationFromDFP":
                            case "isFirstVisit":
                            case "getTunipopID":
                                trace("LOCAL PROXY METHOD");
                                var _local6 = this;
                                _local6[_arg1.method](_arg1, _arg2, _arg3);
                                return;
                        };
                        model.service.send(_arg1.useHTTPS, _arg1.method, _arg1.parameters, new ItemResponder(swfSuccess, swfFault, {
                            request:_arg1,
                            key:_arg3
                        }), "", _local4, _arg1.overrideKey);
                    } else {
                        trace("PROXY DENIED");
                        reportRequestFailure({
                            message:"Not allowed through SWF",
                            code:0
                        }, _arg3);
                    };
                    break;
                case "lastfm":
                    this.handleLastfmRequest(_arg1, _arg3);
                    break;
                case "facebook":
                    this.handleFacebookRequest(_arg1, _arg3);
                    break;
                case "rapleaf":
                    _local5 = (this[("rapleaf_" + _arg1.method)] as Function);
                    if (_local5 !== null){
                        _local5(_arg1, _arg3);
                    } else {
                        reportRequestFailure({
                            message:"Invalid rapleaf method.",
                            code:0
                        }, _arg3);
                    };
            };
        }
        private function onQueueRestoreComplete(_arg1:Event):void{
            var event:* = _arg1;
            try {
                trace("calling queueIsRestorable");
                ExternalInterface.call((playerController + ".queueIsRestorable"));
            } catch(e:Error) {
                trace(e);
                return;
            };
        }
        private function synchronizeHeaders(_arg1:Object):void{
            if (((((_arg1.hasOwnProperty("session")) && (_arg1.session))) && (!((_arg1.session === model.service.session))))){
                model.service.session = _arg1.session;
            };
            if (((_arg1.hasOwnProperty("country")) && (_arg1.country))){
                model.service.country = _arg1.country;
            };
            if (((((_arg1.hasOwnProperty("uuid")) && (_arg1.uuid))) && (!((_arg1.uuid === model.service.uuid))))){
                model.service.uuid = _arg1.uuid;
            };
        }
        private function get currentQueue():Queue{
            return (_currentQueue);
        }
        private function onQueueRestoreFailed(_arg1:Event):void{
            trace("restore queue failed");
            var _local2:RestoreQueue = (_arg1.currentTarget as RestoreQueue);
            if (((_local2) && (_local2.error))){
                this.reportError(_local2.error);
            };
        }
        public function getPrefetchEnabled():Boolean{
            return (Queue.prefetchEnabled);
        }
        public function setVolume(_arg1:Number):void{
            if (((isNaN(_arg1)) || ((_arg1 < 0)))){
                _arg1 = 0;
            };
            if (_arg1 > 100){
                _arg1 = 100;
            };
            model.isMuted = false;
            model.volume = _arg1;
            SoundMixer.soundTransform = new SoundTransform((_arg1 / 100));
        }
        private function rapleafResult(_arg1:Object, _arg2:Object=null):void{
            reportRequestSuccess(_arg1.result, _arg2.key);
        }
        public function voteSong(_arg1:int, _arg2:int):void{
            var _local3:QueueSong;
            if (model.currentQueue){
                _local3 = model.currentQueue.gs_queue::queueSongLookupByQueueSongID[_arg1];
                if (_local3){
                    _local3.setAutoplayVote(_arg2);
                };
            };
        }
        public function restoreQueueFromLocal():void{
            var _local1:RestoreQueue;
            trace(("Checking for queue to restore: " + model.queueToRestore));
            if (model.queueToRestore){
                _local1 = new RestoreQueue(model.service, model, model.queueToRestore);
                _local1.addEventListener(Event.COMPLETE, onQueueRestoreComplete);
                _local1.addEventListener("failed", onQueueRestoreFailed);
                _local1.execute();
            };
        }
        private function onChatData(_arg1:JSONChatEvent):void{
            var event:* = _arg1;
            var crap:* = cleanObjectForEI(event.data);
            trace(JSON.encode(crap));
            try {
                ExternalInterface.call((serviceController + ".onChatData"), crap);
            } catch(e:Error) {
                trace(e);
            };
        }
        public function seekTo(_arg1:int):void{
            if (model.currentQueue){
                model.currentQueue.seekInCurrentSong(_arg1);
            };
        }
        public function restoreQueue():Boolean{
            if (((((!(model.currentQueue)) || ((model.currentQueue.length == 0)))) && (model.previousQueue))){
                model.currentQueue = model.previousQueue;
                if (model.currentQueue.autoplayEnabled){
                    model.currentQueue.setAutoplayEnabled(true, model.currentQueue.gs_queue::autoplayUserInitiated, false);
                };
                return (true);
            };
            return (false);
        }
        public function prefetchStreamKeys(_arg1:Array):void{
            Queue.cacheStreamKeys(_arg1, model.service);
        }
        private function cleanObjectForEI(_arg1:Object):Object{
            var _local3:String;
            if (((((((((!(_arg1)) || ((_arg1 is Number)))) || ((_arg1 is Boolean)))) || ((_arg1 is int)))) || ((_arg1 is uint)))){
                return (_arg1);
            };
            var _local2:Object = {};
            for (_local3 in _arg1) {
                if ((_arg1[_local3] is String)){
                    _local2[_local3] = cleanStringForEI((_arg1[_local3] as String));
                } else {
                    if ((_arg1[_local3] is Array)){
                        _local2[_local3] = cleanArrayForEI((_arg1[_local3] as Array));
                    } else {
                        if ((_arg1[_local3] is Object)){
                            _local2[_local3] = cleanObjectForEI(_arg1[_local3]);
                        } else {
                            _local2[_local3] = _arg1[_local3];
                        };
                    };
                };
            };
            return (_local2);
        }
        private function reportZoom():void{
            var dif:* = 0;
            if (((((ready) && (zoomChangeCallback))) && (!((lastWidth === stage.stageWidth))))){
                dif = (stage.stageWidth - 10);
                try {
                    ExternalInterface.call(zoomChangeCallback, dif);
                } catch(e:Error) {
                    trace(e);
                    return;
                };
                lastWidth = stage.stageWidth;
            };
        }
        private function swfSuccess(_arg1:Object, _arg2:Object=null):void{
            var _local4:Object;
            var _local5:String;
            var _local3:Object = _arg2.request;
            _local4 = _arg1.result;
            switch (_local3.method){
                case "getCommunicationToken":
                    _local5 = String(_local4);
                    model.service.resetToken(_local5);
                    break;
                case "getGoogleContacts":
                    if (int(_local4.result.statusCode) == 1){
                        _arg1.result.result.parsedResult = parseGoogXML((_local4.result.rawResponse as String));
                    };
                    break;
            };
            _arg1.rawResult = cleanStringForEI(_arg1.rawResult);
            reportRequestSuccess(_arg1, _arg2.key);
        }
        public function get model():Model{
            return (_model);
        }
        public function getIsMuted():Boolean{
            return (model.isMuted);
        }
        private function set currentQueue(_arg1:Queue):void{
            var _local2:QueueChangeEvent;
            if (_arg1 !== _currentQueue){
                if (_currentQueue){
                    _currentQueue.removeEventListener(PropertyChangeEvent.PROPERTY_CHANGE, onQueuePropChange);
                    _currentQueue.removeEventListener(CollectionEvent.COLLECTION_CHANGE, onQueueCollectionChange);
                    _currentQueue.removeEventListener(QueueEvent.AUTOPLAY_FAILED, onQueueAutoplayFailed);
                    _currentQueue.removeEventListener(QueueEvent.ERROR_ADDING_SONGS, onQueueAddError);
                    _currentQueue.removeEventListener(QueueEvent.PLAYBACK_ERROR, onQueuePlaybackError);
                    _currentQueue.removeEventListener(QueueEvent.AUTOPLAY_VOTE_ERROR, onAutoplayVoteError);
                    _currentQueue.removeEventListener(SongEvent.SONG_DIRTY, onSongDirty);
                };
                _currentQueue = _arg1;
                if (_currentQueue){
                    _currentQueue.addEventListener(PropertyChangeEvent.PROPERTY_CHANGE, onQueuePropChange, false, 0, true);
                    _currentQueue.addEventListener(CollectionEvent.COLLECTION_CHANGE, onQueueCollectionChange, false, 0, true);
                    _currentQueue.addEventListener(QueueEvent.AUTOPLAY_FAILED, onQueueAutoplayFailed, false, 0, true);
                    _currentQueue.addEventListener(QueueEvent.ERROR_ADDING_SONGS, onQueueAddError, false, 0, true);
                    _currentQueue.addEventListener(QueueEvent.PLAYBACK_ERROR, onQueuePlaybackError, false, 0, true);
                    _currentQueue.addEventListener(QueueEvent.AUTOPLAY_VOTE_ERROR, onAutoplayVoteError, false, 0, true);
                    _currentQueue.addEventListener(SongEvent.SONG_DIRTY, onSongDirty, false, 0, true);
                    activeSong = _currentQueue.activeSong;
                    _currentQueue.enableCrossfade(model.crossfadeEnabled, model.crossfadeAmount, model.playPauseFadeEnabled);
                    if (model.persistShuffle){
                        _currentQueue.shuffleEnabled = model.shuffleEnabled;
                    } else {
                        model.shuffleEnabled = _currentQueue.shuffleEnabled;
                    };
                } else {
                    activeSong = null;
                };
                _local2 = new QueueChangeEvent(QueueChangeEvent.QUEUE_RESET);
                queueDirty.push(_local2);
                propsDirty = true;
            };
        }
        public function setErrorCallback(_arg1:String):void{
            this.errorCallback = _arg1;
        }
        public function getLowerQuality():Boolean{
            return (PlayableSong.useMobile);
        }
        public function resumeSong():void{
            if (model.currentQueue){
                model.currentQueue.resume();
            };
        }
        public function getSongDetails(_arg1:String, _arg2:Array):Array{
            var _local5:int;
            var _local6:QueueSong;
            var _local3:Array = [];
            var _local4:Queue = ((((!(_arg1)) || ((model.currentQueue.queueID == _arg1)))) ? model.currentQueue : ((((model.previousQueue) && (model.previousQueue.queueID))) ? model.previousQueue : null));
            if (_local4){
                for each (_local5 in _arg2) {
                    _local6 = _local4.gs_queue::queueSongLookupByQueueSongID[_local5];
                    if (_local6){
                        _local3.push(buildSong(_local6));
                    };
                };
            };
            return (_local3);
        }
        public function rapleaf_direct(_arg1:Object, _arg2:String):void{
            var _local4:AsyncToken;
            var _local3:String = ((((_arg1.parameters) && (_arg1.parameters.email))) ? _arg1.parameters.email : "");
            if (_local3){
                _local3 = MD5.hash(_local3.toLowerCase().replace(/\s/g, ""));
                thirdPartyLoader.method = "GET";
                thirdPartyLoader.url = ((((RAPLEAF_PERSONLIZE_URL_DIRECT + "?api_key=") + RAPLEAF_API_KEY) + "&md5_email=") + _local3);
                _local4 = thirdPartyLoader.send();
                _local4.addResponder(new ItemResponder(rapleafResult, rapleafFault, {
                    request:_arg1,
                    key:_arg2
                }));
            } else {
                reportRequestFailure({message:"Missing required parameter: email"}, _arg2);
            };
        }
        private function reportPropertyChange():Boolean{
            if (((ready) && (propertyChangeCallback))){
                try {
                    ExternalInterface.call(propertyChangeCallback, buildProperties());
                } catch(e:Error) {
                    trace(e);
                };
                return (true);
            };
            return (false);
        }
        public function pauseSong():void{
            if (model.currentQueue){
                model.currentQueue.pause();
            };
        }
        private function get activeSong():QueueSong{
            return (_activeSong);
        }
        public function setActiveSong(_arg1:int):Boolean{
            var _local2:QueueSong;
            if (model.currentQueue){
                _local2 = model.currentQueue.gs_queue::queueSongLookupByQueueSongID[_arg1];
                if (_local2){
                    return (model.currentQueue.setActiveSong(_local2));
                };
            };
            return (false);
        }
        public function setShuffle(_arg1:Boolean):void{
            model.shuffleEnabled = _arg1;
            if (model.currentQueue){
                model.currentQueue.shuffleEnabled = _arg1;
            };
        }
        public function setLowerQuality(_arg1:Boolean):void{
            PlayableSong.useMobile = _arg1;
        }
        private function get chatClient():JSONChatClient{
            return (_chatClient);
        }
        private function isFirstVisit(_arg1:Object, _arg2:Object, _arg3:String):void{
            reportRequestSuccess(model.firstVisit, _arg3);
        }
        private function reportPlaybackStatus():Boolean{
            if (((ready) && (playbackStatusCallback))){
                try {
                    ExternalInterface.call(playbackStatusCallback, buildPlaybackStatus());
                } catch(e:Error) {
                    trace(e);
                };
                return (true);
            };
            return (false);
        }
        public function setPropertyChangeCallback(_arg1:String):Object{
            this.propertyChangeCallback = _arg1;
            return (buildProperties());
        }
        private function tunipopFault(_arg1:Object, _arg2:Object=null):void{
            reportRequestFailure({
                message:"HTTP_ERROR",
                details:_arg1,
                code:_arg1.statusCode
            }, _arg2.key);
        }
        private function reportRequestFailure(_arg1:Object, _arg2:String):void{
            var fault:* = _arg1;
            var key:* = _arg2;
            try {
                ExternalInterface.call((serviceController + ".swfFault"), fault, key);
            } catch(e:Error) {
                trace(e);
            };
        }
        private function buildProperties():Object{
            var _local1:Object = {
                volume:model.volume,
                isMuted:model.isMuted,
                crossfadeAmount:((model.currentQueue) ? model.currentQueue.crossfadeAmount : 0),
                crossfadeEnabled:((model.currentQueue) ? model.currentQueue.crossfadeEnabled : false),
                playPauseFade:((model.currentQueue) ? model.currentQueue.crossfadeInOutEnabled : false)
            };
            return (_local1);
        }
        private function onFacebookResult(_arg1:Object, _arg2:Object=null):void{
            reportRequestSuccess(_arg1, _arg2.key);
        }
        public function setChatServers(_arg1:Object):void{
            var _local3:String;
            var _local2:Array = [];
            for (_local3 in _arg1) {
                _local2.push({
                    host:_local3,
                    port:80,
                    weight:_arg1[_local3]
                });
            };
            model.chatClient.setServers(_local2);
        }
        private function buildEverything():Object{
            var _local1:Object = buildProperties();
            _local1.currentQueue = buildQueue(model.currentQueue);
            _local1.previousQueue = buildQueue(model.previousQueue);
            return (_local1);
        }
        public function set model(_arg1:Model):void{
            if (_arg1 !== _model){
                if (_model){
                    _model.removeEventListener(PropertyChangeEvent.PROPERTY_CHANGE, onModelChange);
                };
                _model = _arg1;
                if (_model){
                    _model.addEventListener(PropertyChangeEvent.PROPERTY_CHANGE, onModelChange);
                    service = _model.service;
                    currentQueue = _model.currentQueue;
                    chatClient = _model.chatClient;
                };
            };
        }
        private function onQueuePlaybackError(_arg1:QueueEvent):void{
            var _local2:Object = {
                type:_arg1.type,
                details:{}
            };
            _local2.details.reason = _arg1.detail;
            _local2.details.song = buildSong((_arg1.extra.song as QueueSong));
            _local2.details.errorDetail = "unknown";
            if (_arg1.extra.event){
                switch (_arg1.extra.event.code){
                    case PlayableSongEvent.FAILED_IO_ERROR:
                        _local2.details.errorDetail = "serverIOError";
                        break;
                    case PlayableSongEvent.FAILED_STREAMKEY_LIMIT:
                        _local2.details.errorDetail = "streamKeyRateLimit";
                        break;
                    case PlayableSongEvent.FAILED_TOO_MANY_STREAMKEY_FAILS:
                        _local2.details.errorDetail = "streamKeyMultipleFailures";
                        break;
                    case PlayableSongEvent.FAILED_STREAMKEY_OTHER:
                        _local2.details.errorDetail = "streamKeyFetchError";
                        break;
                    case PlayableSongEvent.FAILED_TOO_MANY_BAD_FRAMES:
                        _local2.details.errorDetail = "mp3Bad";
                        break;
                    case PlayableSongEvent.FAILED_UNKNOWN_SERVER_ERROR:
                        _local2.details.errorDetail = "serverUnknownError";
                        break;
                };
            };
            this.reportError(_local2);
        }
        private function reportQueueChange():Array{
            var events:* = null;
            var failed:* = false;
            var e:* = null;
            if (((ready) && (queueChangeCallback))){
                events = cleanQueueChangeEvents();
                failed = false;
                while (events.length) {
                    e = events.shift();
                    try {
                        ExternalInterface.call(queueChangeCallback, e);
                    } catch(e:Error) {
                        failed = true;
                        trace(e);
                    };
                };
            };
            return (((failed) ? [new QueueChangeEvent(QueueChangeEvent.QUEUE_RESET)] : []));
        }
        private function onFacebookFault(_arg1:Object, _arg2:Object=null):void{
            reportRequestFailure({
                message:"HTTP_ERROR",
                details:_arg1,
                code:_arg1.statusCode
            }, _arg2.key);
        }
        public function getApplicationVersion():String{
            return (model.revision);
        }
        private function fetchToken():void{
            try {
                ExternalInterface.call((serviceController + ".swfNeedsToken"));
            } catch(e:Error) {
                trace(e);
                return;
            };
            needToken = false;
        }
        private function cleanQueueChangeEvents():Array{
            var _local6:QueueChangeEvent;
            var _local7:String;
            var _local8:Object;
            var _local9:int;
            if (!model.currentQueue){
                return ([new QueueChangeEvent(QueueChangeEvent.QUEUE_RESET)]);
            };
            var _local1:Object = {};
            var _local2:Boolean;
            var _local3:Array = [];
            var _local4:Object = buildQueue(model.currentQueue);
            var _local5:Array = [];
            for each (_local6 in this.queueDirty) {
                switch (_local6.type){
                    case QueueChangeEvent.QUEUE_RESET:
                        _local6.details = _local4;
                        _local6.fullQueue = _local4;
                        return ([_local6]);
                    case QueueChangeEvent.CONTENT_CHANGE:
                        _local9 = 0;
                        while (_local9 < _local6.details.items.length) {
                            _local6.details.items[_local9] = buildSong(_local6.details.items[_local9]);
                            _local9++;
                        };
                        _local6.fullQueue = _local4;
                        _local3.push(_local6);
                        break;
                    case QueueChangeEvent.PROPERTY_CHANGE:
                        _local2 = true;
                        _local7 = (_local6.details as String);
                        _local8 = model.currentQueue[_local7];
                        if ((_local8 is QueueSong)){
                            _local8 = buildSong((_local8 as QueueSong));
                        } else {
                            if (_local7 == "currentAutoplayTag"){
                                _local7 = "currentAutoplayTagID";
                                _local8 = ((model.currentQueue.currentAutoplayTag) ? model.currentQueue.currentAutoplayTag.tagID : 0);
                            };
                        };
                        _local1[_local7] = _local8;
                        break;
                };
            };
            if (_local2){
                _local6 = new QueueChangeEvent(QueueChangeEvent.PROPERTY_CHANGE, _local1);
                _local6.fullQueue = _local4;
                _local5.push(_local6);
            };
            return (_local5.concat(_local3));
        }
        private function tunipopResult(_arg1:Object, _arg2:Object=null):void{
            var _local3:Array = _arg1.result.split("\n");
            if (_local3.length >= 4){
                reportRequestSuccess(_local3[3], _arg2.key);
            } else {
                if (_local3[0] == "301"){
                    reportRequestSuccess(0, _arg2.key);
                } else {
                    reportRequestFailure({
                        message:"tunipop error",
                        details:_arg1.result,
                        code:_local3[0]
                    }, _arg2.key);
                };
            };
        }
        private function rapleafFault(_arg1:Object, _arg2:Object=null):void{
            reportRequestFailure({
                message:"HTTP_ERROR",
                details:_arg1,
                code:_arg1.statusCode
            }, _arg2.key);
        }
        public function getQueueIsRestorable():Boolean{
            return (((((((!(model.currentQueue)) || ((model.currentQueue.length == 0)))) && (model.previousQueue))) && ((model.previousQueue.length > 0))));
        }
        public function setCrossfadeEnabled(_arg1:Boolean):void{
            model.crossfadeEnabled = _arg1;
            if (model.currentQueue){
                model.currentQueue.crossfadeEnabled = _arg1;
            };
            if (model.previousQueue){
                model.previousQueue.crossfadeEnabled = _arg1;
            };
        }
        private function set service(_arg1:Service):void{
            if (_arg1 !== _service){
                if (_service){
                    _service.removeEventListener(ServiceEvent.SERVICE_ERROR, onServiceError);
                    _service.removeEventListener(ServiceEvent.TOKEN_NEEDED, onServiceNeedsToken);
                    _service.removeEventListener(PropertyChangeEvent.PROPERTY_CHANGE, onServicePropChange);
                };
                _service = _arg1;
                if (_service){
                    _service.addEventListener(ServiceEvent.SERVICE_ERROR, onServiceError, false, 0, true);
                    _service.addEventListener(ServiceEvent.TOKEN_NEEDED, onServiceNeedsToken, false, 0, true);
                    _service.addEventListener(PropertyChangeEvent.PROPERTY_CHANGE, onServicePropChange, false, 0, true);
                };
            };
        }
        private function onServicePropChange(_arg1:PropertyChangeEvent):void{
            if (_arg1.property == "session"){
                model.chatClient.partChannels([_arg1.oldValue]);
                model.chatClient.joinChannels([_arg1.newValue]);
            };
        }
        private function onChatError(_arg1:JSONChatEvent):void{
            var event:* = _arg1;
            trace(JSON.encode(event));
            try {
                ExternalInterface.call((serviceController + ".onChatError"), cleanObjectForEI(event));
            } catch(e:Error) {
                trace(e);
            };
        }
        public function setCrossfadeAmount(_arg1:int):void{
            model.crossfadeAmount = _arg1;
            if (model.currentQueue){
                model.currentQueue.crossfadeAmount = _arg1;
            };
            if (model.previousQueue){
                model.previousQueue.crossfadeAmount = _arg1;
            };
        }
        public function getCrossfadeEnabled():Boolean{
            return (model.crossfadeEnabled);
        }
        private function set activeSong(_arg1:QueueSong):void{
            if (_arg1 !== _activeSong){
                if (_activeSong){
                    _activeSong.removeEventListener(PropertyChangeEvent.PROPERTY_CHANGE, onSongPropChange);
                    this.culmulativeSeconds = (this.culmulativeSeconds + _activeSong.secondsListened);
                };
                _activeSong = _arg1;
                if (_activeSong){
                    _activeSong.addEventListener(PropertyChangeEvent.PROPERTY_CHANGE, onSongPropChange, false, 0, true);
                };
                playStatusDirty = true;
            };
        }
        public function playSong(_arg1:int=0):void{
            var _local2:QueueSong;
            if (model.currentQueue){
                _local2 = null;
                if (_arg1){
                    _local2 = model.currentQueue.gs_queue::queueSongLookupByQueueSongID[_arg1];
                };
                model.currentQueue.playSong(_local2);
            };
        }
        private function onQueueAddError(_arg1:QueueEvent):void{
            var _local2:Object = {
                type:_arg1.type,
                details:_arg1.extra
            };
            _local2.details.reason = _arg1.detail;
            this.reportError(_local2);
        }
        private function reportError(_arg1:Object):void{
            var error:* = _arg1;
            if (((ready) && (errorCallback))){
                try {
                    ExternalInterface.call(errorCallback, error);
                } catch(e:Error) {
                    trace(e);
                };
            };
        }
        public function setPlayPauseFade(_arg1:Boolean):void{
            model.playPauseFadeEnabled = _arg1;
            if (model.currentQueue){
                model.currentQueue.crossfadeInOutEnabled = _arg1;
            };
            if (model.previousQueue){
                model.previousQueue.crossfadeInOutEnabled = _arg1;
            };
        }
        private function onQueueCollectionChange(_arg1:CollectionEvent):void{
            var _local2:QueueChangeEvent;
            var _local3:Object = {};
            switch (_arg1.kind){
                case CollectionEventKind.REFRESH:
                case CollectionEventKind.RESET:
                    _local2 = new QueueChangeEvent(QueueChangeEvent.QUEUE_RESET);
                    break;
                case CollectionEventKind.ADD:
                    _local3.index = _arg1.location;
                    _local3.items = _arg1.items;
                    _local3.kind = "add";
                    _local2 = new QueueChangeEvent(QueueChangeEvent.CONTENT_CHANGE, _local3);
                    break;
                case CollectionEventKind.REMOVE:
                    _local3.index = _arg1.location;
                    _local3.items = _arg1.items;
                    _local3.kind = "remove";
                    _local2 = new QueueChangeEvent(QueueChangeEvent.CONTENT_CHANGE, _local3);
                    break;
                case CollectionEventKind.MOVE:
                    _local3.index = _arg1.location;
                    _local3.oldIndex = _arg1.oldLocation;
                    _local3.items = _arg1.items;
                    _local3.kind = "move";
                    _local2 = new QueueChangeEvent(QueueChangeEvent.CONTENT_CHANGE, _local3);
                    break;
                case CollectionEventKind.REPLACE:
                    _local3.index = _arg1.location;
                    _local3.items = _arg1.items;
                    _local3.kind = "replace";
                    _local2 = new QueueChangeEvent(QueueChangeEvent.CONTENT_CHANGE, _local3);
                    break;
            };
            if (_local2){
                queueDirty.push(_local2);
            };
        }
        public function setPlaybackStatusCallback(_arg1:String):Object{
            this.playbackStatusCallback = _arg1;
            return (buildPlaybackStatus());
        }
        private function getNotificationFromDFP(_arg1:Object, _arg2:Object, _arg3:String):void{
            var _local4:String = ((((_arg1.parameters) && (_arg1.parameters.paramString))) ? _arg1.parameters.paramString : "");
            thirdPartyLoader.method = "GET";
            thirdPartyLoader.url = ("http://ad.doubleclick.net/pfadx/grooveshark.notif/" + _local4);
            var _local5:AsyncToken = thirdPartyLoader.send();
            _local5.addResponder(new ItemResponder(dfpResult, dfpFault, {
                request:_arg1,
                key:_arg3
            }));
        }
        private function toBejeebusString(_arg1:Object, _arg2:String=""):String{
            var _local4:String;
            var _local8:XML;
            var _local9:XMLList;
            var _local3 = (_arg2 + "[");
            var _local5:XML = describeType(_arg1);
            var _local6:String = _local5.@name;
            if (_local6.indexOf("::") != -1){
                _local6 = _local6.substring((_local6.indexOf("::") + 2));
            };
            _local3 = (_local3 + (_local6 + "]\n"));
            var _local7:XMLList = _local5.descendants("accessor");
            for each (_local8 in _local7) {
                _local4 = String(_arg1[_local8.@name]);
                _local3 = (_local3 + (((((((_arg2 + "    ") + _local8.@name) + ":") + _local8.@type) + "=") + _local4) + "\n"));
                if (_local4 == "[object Object]"){
                    _local3 = (_local3 + toStringExpanded(_arg1[_local8.@name], (_arg2 + "    ")));
                };
            };
            _local9 = _local5.descendants("variable");
            for each (_local8 in _local9) {
                _local4 = String(_arg1[_local8.@name]);
                _local3 = (_local3 + (((((((_arg2 + "    ") + _local8.@name) + ":") + _local8.@type) + "=") + _local4) + "\n"));
                if (_local4 == "[object Object]"){
                    _local3 = (_local3 + toStringExpanded(_arg1[_local8.@name], (_arg2 + "    ")));
                };
            };
            return (_local3);
        }
        public function setPersistShuffle(_arg1:Boolean):void{
            model.persistShuffle = _arg1;
        }
        private function buildQueue(_arg1:Queue):Object{
            var _local3:QueueSong;
            var _local4:Object;
            if (!_arg1){
                return (null);
            };
            var _local2:Array = [];
            for each (_local3 in _arg1) {
                _local2.push(buildSong(_local3));
            };
            _local4 = {
                songs:_local2,
                queueID:_arg1.queueID,
                activeSong:((_arg1.activeSong) ? buildSong(_arg1.activeSong) : null),
                previousSong:((_arg1.previousSong) ? buildSong(_arg1.previousSong) : null),
                nextSong:((_arg1.nextSong) ? buildSong(_arg1.nextSong) : null),
                autoplayEnabled:_arg1.autoplayEnabled,
                currentAutoplayTagID:((_arg1.currentAutoplayTag) ? _arg1.currentAutoplayTag.tagID : 0),
                shuffleEnabled:_arg1.shuffleEnabled,
                repeatMode:_arg1.repeatMode
            };
            if (_local4.activeSong){
                _local4.activeSong.index = _arg1.getItemIndex(_arg1.activeSong);
            };
            return (_local4);
        }
        private function cleanArrayForEI(_arg1:Array):Array{
            var _local2:Array = [];
            var _local3:int;
            while (_local3 < _arg1.length) {
                if ((_arg1[_local3] is String)){
                    _local2[_local3] = cleanStringForEI((_arg1[_local3] as String));
                } else {
                    if ((_arg1[_local3] is Array)){
                        _local2[_local3] = cleanArrayForEI((_arg1[_local3] as Array));
                    } else {
                        if ((_arg1[_local3] is Object)){
                            _local2[_local3] = cleanObjectForEI(_arg1[_local3]);
                        } else {
                            _local2[_local3] = _arg1[_local3];
                        };
                    };
                };
                _local3++;
            };
            return (_local2);
        }
        public function setPrefetchEnabled(_arg1:Boolean):void{
            Queue.prefetchEnabled = _arg1;
        }
        private function getThemeFromDFP(_arg1:Object, _arg2:Object, _arg3:String):void{
            var _local4:String = ((((_arg1.parameters) && (_arg1.parameters.paramString))) ? _arg1.parameters.paramString : "");
            thirdPartyLoader.method = "GET";
            thirdPartyLoader.url = ("http://ad.doubleclick.net/pfadx/grooveshark.wall/" + _local4);
            var _local5:AsyncToken = thirdPartyLoader.send();
            _local5.addResponder(new ItemResponder(dfpResult, dfpFault, {
                request:_arg1,
                key:_arg3
            }));
        }
        private function onQueueAutoplayFailed(_arg1:QueueEvent):void{
            var _local2:Object = {
                type:_arg1.type,
                details:{reason:_arg1.detail}
            };
            this.reportError(_local2);
        }
        private function cleanStringForEI(_arg1:String):String{
            return (_arg1.replace(/\\/g, "\\\\").replace(/\&/g, "&amp;"));
        }
        private function set chatClient(_arg1:JSONChatClient):void{
            if (_arg1 !== _chatClient){
                if (_chatClient){
                    _chatClient.removeEventListener(JSONChatEvent.DATA_RECEIVED, onChatData);
                    _chatClient.removeEventListener(JSONChatEvent.DATA_PARSE_ERROR, onChatError);
                    _chatClient.removeEventListener(JSONChatEvent.CONNECTION_ERROR, onChatError);
                    _chatClient.removeEventListener(JSONChatEvent.CONNECTION_DROP, onChatError);
                    _chatClient.removeEventListener(JSONChatEvent.CHANNEL_JOIN_ERROR, onChatError);
                    _chatClient.removeEventListener(JSONChatEvent.OTHER_IO_ERROR, onChatError);
                };
                _chatClient = _arg1;
                if (_chatClient){
                    _chatClient.addEventListener(JSONChatEvent.DATA_RECEIVED, onChatData, false, 0, true);
                    _chatClient.addEventListener(JSONChatEvent.DATA_PARSE_ERROR, onChatError, false, 0, true);
                    _chatClient.addEventListener(JSONChatEvent.CONNECTION_ERROR, onChatError, false, 0, true);
                    _chatClient.addEventListener(JSONChatEvent.CONNECTION_DROP, onChatError, false, 0, true);
                    _chatClient.addEventListener(JSONChatEvent.CHANNEL_JOIN_ERROR, onChatError, false, 0, true);
                    _chatClient.addEventListener(JSONChatEvent.OTHER_IO_ERROR, onChatError, false, 0, true);
                };
            };
        }
        public function expireService():void{
            model.service.expire();
        }
        private function toStringExpanded(_arg1:Object, _arg2:String=""):String{
            var _local4:String;
            var _local7:String;
            var _local3 = (_arg2 + "[");
            var _local5:XML = describeType(_arg1);
            var _local6:String = _local5.@name;
            if (_local6.indexOf("::") != -1){
                _local6 = _local6.substring((_local6.indexOf("::") + 2));
            };
            _local3 = (_local3 + (_local6 + "]\n"));
            for (_local7 in _arg1) {
                _local4 = String(_arg1[_local7]);
                _local3 = (_local3 + (((((_arg2 + "    ") + _local7) + ": ") + _local4) + "\n"));
                if (_local4 === "[object Object]"){
                    _local3 = (_local3 + this.toStringExpanded(_arg1[_local7], (_arg2 + "    ")));
                };
            };
            return (_local3);
        }
        public function stopSong():void{
            if (model.currentQueue){
                model.currentQueue.stop();
            };
        }
        private function dfpFault(_arg1:Object, _arg2:Object=null):void{
            reportRequestFailure({
                message:"HTTP_ERROR",
                details:_arg1,
                code:_arg1.statusCode
            }, _arg2.key);
        }
        public function getCurrentQueue():Object{
            return (buildQueue(model.currentQueue));
        }
        private function onSongDirty(_arg1:SongEvent):void{
            if (songsDirty.indexOf(_arg1.song) == -1){
                songsDirty.push(_arg1.song);
            };
        }
        public function setIsMuted(_arg1:Boolean):void{
            model.isMuted = _arg1;
            SoundMixer.soundTransform = new SoundTransform(((model.isMuted) ? 0 : (model.volume / 100)));
        }
        public function getCulmulativeListenTime():Object{
            return ({
                seconds:this.culmulativeSeconds,
                firstVisit:model.firstVisit
            });
        }
        private function handleFacebookRequest(_arg1:Object, _arg2:String):void{
            var _local3:String;
            var _local4:AsyncToken;
            _arg1.httpMethod = String(_arg1.httpMethod).toUpperCase();
            if (allowedHTTPMethods.indexOf(_arg1.httpMethod) == -1){
                _arg1.httpMethod = "POST";
            };
            thirdPartyLoader.method = _arg1.httpMethod;
            thirdPartyLoader.url = ("https://graph.facebook.com/" + _arg1.method);
            trace(((("FACEBOOK, method: " + thirdPartyLoader.method) + ", url: ") + thirdPartyLoader.url));
            for (_local3 in _arg1.parameters) {
                trace(((_local3 + ":") + _arg1.parameters[_local3]));
            };
            _local4 = thirdPartyLoader.send(_arg1.parameters);
            _local4.addResponder(new ItemResponder(onFacebookResult, onFacebookFault, {
                request:_arg1,
                key:_arg2
            }));
        }
        private function onSongPropChange(_arg1:PropertyChangeEvent):void{
            switch (_arg1.property){
                case "playStatus":
                    playStatusDirty = !(reportPlaybackStatus());
                    break;
                case "currentStreamServer":
                case "bytesLoaded":
                case "bytesTotal":
                case "position":
                case "duration":
                    playStatusDirty = true;
                    break;
            };
        }
        public function nextSong():void{
            if (model.currentQueue){
                model.currentQueue.playNextSong();
            };
        }
        public function getEverything():Object{
            return (buildEverything());
        }
        private function handleLastfmRequest(_arg1:Object, _arg2:String):void{
            var _local4:String;
            var _local5:String;
            var _local6:int;
            var _local7:AsyncToken;
            thirdPartyLoader.method = "POST";
            thirdPartyLoader.url = lastFMAudioScrobblerURL;
            var _local3:Array = [];
            for (_local4 in _arg1.parameters) {
                _local3.push(_local4);
            };
            _local3.sort();
            _local5 = "";
            _local6 = 0;
            while (_local6 < _local3.length) {
                if (((_local3[_local6]) && (_arg1.parameters.hasOwnProperty(_local3[_local6])))){
                    _local5 = (_local5 + (_local3[_local6] + _arg1.parameters[_local3[_local6]]));
                };
                _local6++;
            };
            trace(((((("LASTFM, method: " + thirdPartyLoader.method) + ", url: ") + thirdPartyLoader.url) + ", sig: ") + _local5));
            _local5 = (_local5 + lastfmSecret);
            _arg1.parameters["api_sig"] = MD5.hash(_local5);
            _arg1.parameters["format"] = "json";
            for (_local4 in _arg1.parameters) {
                trace(((_local4 + ":") + _arg1.parameters[_local4]));
            };
            _local7 = thirdPartyLoader.send(_arg1.parameters);
            _local7.addResponder(new ItemResponder(onLastfmResult, onLastfmFault, {
                request:_arg1,
                key:_arg2
            }));
        }
        public function getPreviousQueue():Object{
            return (buildQueue(model.previousQueue));
        }
        public function setRepeat(_arg1:int):void{
            if (model.currentQueue){
                model.currentQueue.repeatMode = _arg1;
            };
        }
        private function reportSongPropertyChange(_arg1:QueueSong):Boolean{
            var song:* = _arg1;
            if (((ready) && (songPropertyChangeCallback))){
                try {
                    ExternalInterface.call(songPropertyChangeCallback, buildSong(song));
                } catch(e:Error) {
                    trace(e);
                };
                return (true);
            };
            return (false);
        }
        private function reportUserChange(_arg1:Object, _arg2:Object, _arg3:String):void{
            if (!_arg1.parameters){
                reportRequestSuccess({result:false}, _arg3);
                return;
            };
            var _local4:int = int(_arg1.parameters.userID);
            if (!_local4){
                _local4 = -1;
            };
            var _local5:uint = uint(_arg1.parameters.privacy);
            var _local6:Number = Number(_arg1.parameters.userTrackingID);
            if (isNaN(_local6)){
                _local6 = 0;
            };
            model.service.privacy = _local5;
            Queue.userTrackingID = _local6;
            if (_local4){
                PlayableSong.userForReporting = {
                    userID:_local4,
                    username:_arg1.parameters.username,
                    picture:_arg1.parameters.picture
                };
            } else {
                PlayableSong.userForReporting = null;
            };
            model.chatClient.partChannels([("UserID" + model.currentUserID)]);
            if (_local4 > 0){
                model.chatClient.joinChannels([("UserID" + _local4)]);
            };
            model.currentUserID = _local4;
            reportRequestSuccess({result:true}, _arg3);
        }
        public function storeQueue(_arg1:Boolean=false):void{
            if (((model.currentQueue) && ((model.currentQueue.length > 1)))){
                trace(((("STORE QUEUE " + _arg1) + ", ") + model.currentQueue.length));
                model.lastQueue = model.currentQueue.createStoredQueue();
            };
        }
        public function previousSong(_arg1:Boolean=false):void{
            if (model.currentQueue){
                model.currentQueue.playPreviousSong(_arg1);
            };
        }
        private function get service():Service{
            return (_service);
        }
        private function reportComputeSpectrum():void{
            var arr:* = null;
            var i:* = 0;
            if (((((ready) && (computeSpectrumCallback))) && (!(SoundMixer.areSoundsInaccessible())))){
                try {
                    SoundMixer.computeSpectrum(spectrum, this.useFFT);
                } catch(e:Error) {
                    trace(e);
                    return;
                };
                arr = [];
                i = 0;
                while (i < 0x0200) {
                    arr.push(spectrum.readFloat());
                    i = (i + 1);
                };
                try {
                    ExternalInterface.call(computeSpectrumCallback, arr);
                } catch(e:Error) {
                    trace(e);
                };
            };
        }
        public function flagSong(_arg1:int, _arg2:int):void{
            var _local3:QueueSong;
            if (model.currentQueue){
                _local3 = model.currentQueue.gs_queue::queueSongLookupByQueueSongID[_arg1];
                if (_local3){
                    _local3.flag(_arg2);
                };
            };
        }
        private function buildSong(_arg1:QueueSong):Object{
            var _local2:Object = {
                parentQueueID:_arg1.parent.queueID,
                queueSongID:_arg1.queueSongID,
                autoplayVote:_arg1.rawAutoplayVote,
                source:_arg1.source,
                context:_arg1.context,
                sponsoredAutoplayID:_arg1.sponsoredAutoplayID,
                SongID:_arg1.song.songID,
                SongName:cleanStringForEI(_arg1.song.songName),
                ArtistID:_arg1.song.artistID,
                ArtistName:cleanStringForEI(_arg1.song.artistName),
                AlbumID:_arg1.song.albumID,
                AlbumName:cleanStringForEI(_arg1.song.albumName),
                CoverArtFilename:(((_arg1.song.artFilename.indexOf("default") == -1)) ? _arg1.song.artFilename : ""),
                EstimateDuration:_arg1.song.estimateDuration,
                Flags:_arg1.song.flags
            };
            return (_local2);
        }
        private function swfFault(_arg1:Object, _arg2:Object=null):void{
            _arg1.rawResult = cleanStringForEI(_arg1.rawResult);
            reportRequestFailure(_arg1, _arg2.key);
        }
        public function getShuffle():Boolean{
            return (model.shuffleEnabled);
        }
        public function setZoomChangeCallback(_arg1:String):int{
            this.zoomChangeCallback = _arg1;
            this.lastWidth = stage.stageWidth;
            return ((stage.stageWidth - 10));
        }
        public function addSongsToQueueAt(_arg1:Array, _arg2:int=-1, _arg3:Boolean=false, _arg4:Object=null, _arg5:Boolean=false):void{
            var _local7:Object;
            var _local8:int;
            var _local9:BaseSong;
            if (!model.currentQueue){
                model.currentQueue = new QueueJS(model.service, model.songCache);
            };
            if (((!(_arg1)) || (!(_arg1.length)))){
                trace("addSongsToQueueAt called with no songs!");
                return;
            };
            if (_arg4){
                _arg4 = cleanObjectForEI(_arg4);
            };
            var _local6:Array = [];
            for each (_local7 in _arg1) {
                if (_local7){
                    _local8 = int(_local7.SongID);
                    if (_local8){
                        _local6.push(_local8);
                        _local9 = model.songCache[_local8];
                        if (!_local9){
                            _local9 = new BaseSong();
                            _local9.songID = _local8;
                            _local9.songName = String(_local7.SongName);
                            _local9.artistID = int(_local7.ArtistID);
                            _local9.artistName = String(_local7.ArtistName);
                            _local9.albumID = int(_local7.AlbumID);
                            _local9.albumName = String(_local7.AlbumName);
                            _local9.flags = int(_local7.Flags);
                            if (_local7.CoverArtFilename){
                                _local9.artFilename = String(_local7.CoverArtFilename);
                            };
                            if (int(_local7.EstimateDuration)){
                                _local9.estimateDuration = (int(_local7.EstimateDuration) * 1000);
                            };
                            model.songCache[_local9.songID] = _local9;
                        };
                    };
                };
            };
            model.currentQueue.addItemsAt(_local6, _arg2, _arg3, _arg5, _arg4);
        }
        private function reportRequestSuccess(_arg1:Object, _arg2:String):void{
            var result:* = _arg1;
            var key:* = _arg2;
            try {
                ExternalInterface.call((serviceController + ".swfSuccess"), result, key);
            } catch(e:Error) {
                trace(e);
            };
        }
        public function setSongPropertyChangeCallback(_arg1:String):void{
            this.songPropertyChangeCallback = _arg1;
        }
        private function onServiceNeedsToken(_arg1:ServiceEvent):void{
            if (ready){
                fetchToken();
            } else {
                needToken = true;
            };
        }
        public function setQueueChangeCallback(_arg1:String):Object{
            this.queueChangeCallback = _arg1;
            return (buildQueue(model.currentQueue));
        }
        public function rapleaf_personalize(_arg1:Object, _arg2:String):void{
            var _local4:AsyncToken;
            var _local3:String = ((((_arg1.parameters) && (_arg1.parameters.redirectURL))) ? _arg1.parameters.redirectURL : "");
            if (_local3){
                thirdPartyLoader.method = "GET";
                thirdPartyLoader.url = ((((RAPLEAF_PERSONLIZE_URL_VISIT + "?acct=") + RAPLEAF_ACCT_ID) + "&url=") + _local3);
                _local4 = thirdPartyLoader.send();
                _local4.addResponder(new ItemResponder(rapleafResult, rapleafFault, {
                    request:_arg1,
                    key:_arg2
                }));
            } else {
                reportRequestFailure({message:"Missing required parameter: redirectURL"}, _arg2);
            };
        }
        private function attemptReady():void{
            var playerExists:* = null;
            var apiDef:* = null;
            var serviceExists:* = null;
            trace(((((("attemptReady, playerCreated: " + playerCreated) + ", playerReady: ") + playerReady) + ", serviceReady: ") + serviceReady));
            if (!playerCreated){
                try {
                    playerExists = ExternalInterface.call((playerController + ".playerExists"));
                } catch(e:Error) {
                    trace(e);
                    playerExists = false;
                };
                trace(("PLAYER EXIST ? " + playerExists));
                if (playerExists){
                    try {
                        playerCreated = true;
                        apiDef = new this.API();
                        ExternalInterface.call((((("function() { " + apiDef) + "\n") + setupString) + "}"));
                    } catch(e:Error) {
                        trace(e);
                        playerCreated = false;
                    };
                    trace(("PLAYER CREATED: " + playerCreated));
                };
            };
            if (((playerCreated) && (!(playerReady)))){
                try {
                    trace("CALLING PLAYER READY");
                    playerReady = ExternalInterface.call((playerController + ".playerReady"), buildEverything());
                } catch(e:Error) {
                    trace(e);
                    playerReady = false;
                };
                trace(("PLAYER READY: " + playerReady));
            };
            if (((playerReady) && (!(serviceReady)))){
                try {
                    serviceExists = ExternalInterface.call((serviceController + ".serviceExists"));
                } catch(e:Error) {
                    trace(e);
                    serviceExists = false;
                };
                trace(("SERVICE EXIST ? " + serviceExists));
                if (serviceExists){
                    try {
                        trace("CALLING SERVICE READY");
                        serviceReady = ExternalInterface.call((serviceController + ".swfReady"), "thingy");
                    } catch(e:Error) {
                        trace(e);
                        serviceReady = false;
                    };
                    trace(("SERVICE READY: " + serviceReady));
                };
            };
            if (((((playerCreated) && (playerReady))) && (serviceReady))){
                this.ready = true;
                if (needToken){
                    fetchToken();
                };
                this.restoreQueueFromLocal();
            };
        }
        private function onLastfmResult(_arg1:Object, _arg2:Object=null):void{
            reportRequestSuccess(_arg1, _arg2.key);
        }
        public function setAutoplay(_arg1:Boolean, _arg2:int=0, _arg3:Object=null):void{
            var _local4:Boolean;
            var _local5:Tag;
            if (model.currentQueue){
                if (_arg2){
                    if (_arg1){
                        _local4 = true;
                        _local5 = Tag.tagIDLookup[_arg2];
                        if (!_local5){
                            _local5 = new Tag(_arg2, "");
                        };
                        model.currentQueue.startTagAutoplay(_local5, true);
                    };
                } else {
                    model.currentQueue.stopTagAutoplay();
                };
                if (((!((_arg1 == model.currentQueue.autoplayEnabled))) && (!(_local4)))){
                    model.currentQueue.setAutoplayEnabled(_arg1, true, true, _arg3);
                };
            };
        }
        private function onLastfmFault(_arg1:Object, _arg2:Object=null):void{
            reportRequestFailure({
                message:"HTTP_ERROR",
                details:_arg1,
                code:_arg1.statusCode
            }, _arg2.key);
        }
        private function onServiceError(_arg1:ServiceEvent):void{
            var _local2:Object = {
                type:_arg1.type,
                details:_arg1.detail
            };
            this.reportError(_local2);
        }
        private function dfpResult(_arg1:Object, _arg2:Object=null):void{
            reportRequestSuccess(_arg1.result, _arg2.key);
        }
        public function clearQueue():void{
            model.previousQueue = model.currentQueue;
            model.currentQueue = new QueueJS(model.service, model.songCache);
            model.lastQueue = null;
        }
        private function onModelChange(_arg1:PropertyChangeEvent):void{
            switch (_arg1.property){
                case "service":
                    service = (_arg1.newValue as Service);
                    break;
                case "chatClient":
                    chatClient = (_arg1.newValue as JSONChatClient);
                    break;
                case "currentQueue":
                    currentQueue = (_arg1.newValue as Queue);
                    break;
                case "volume":
                case "isMuted":
                    propsDirty = true;
                    break;
            };
        }
        private function handleCallbacks(_arg1:Event):void{
            var _local3:QueueSong;
            var _local4:int;
            if (!ready){
                attemptReady();
                return;
            };
            if (this.propsDirty){
                this.propsDirty = !(reportPropertyChange());
            };
            if (this.queueDirty.length){
                this.queueDirty = reportQueueChange();
                if (this.ready){
                    this.storeQueue(true);
                };
            };
            if (this.playStatusDirty){
                this.playStatusDirty = !(reportPlaybackStatus());
            };
            var _local2:Array = songsDirty.concat();
            for each (_local3 in _local2) {
                if (reportSongPropertyChange(_local3)){
                    _local4 = songsDirty.indexOf(_local3);
                    songsDirty.splice(_local4, 1);
                };
            };
            reportComputeSpectrum();
            reportZoom();
        }
        public function getPlaybackStatus():Object{
            return (buildPlaybackStatus());
        }

    }
}//package com.grooveshark.jsQueue 
﻿package com.grooveshark.jsQueue {
    import mx.core.*;

    public class Controller_SETUP extends ByteArrayAsset {

    }
}//package com.grooveshark.jsQueue 
﻿package com.grooveshark.jsQueue {
    import mx.core.*;

    public class Controller_API extends ByteArrayAsset {

    }
}//package com.grooveshark.jsQueue 
﻿package com.grooveshark.jsQueue {
    import flash.events.*;
    import mx.events.*;
    import com.grooveshark.socket.*;
    import flash.utils.*;
    import flash.net.*;
    import mx.utils.*;

    public class Model extends EventDispatcher {

        private var flushLSOTimer:Timer;
        private var _260786213revision:String;
        private var _1799419675crossfadeEnabled:Boolean = false;
        private var _2129144446queueToRestore:Object;
        private var _2125426365chatClient:JSONChatClient;
        private var oldLSO:SharedObject;
        private var _662799197playPauseFadeEnabled:Boolean = false;
        private var _volume:Number = 100;
        private var _1995695873currentUserID:int = -1;
        private var _2065669729isMuted:Boolean = false;
        private var _279334822previousQueue:QueueJS;
        private var _334409581songCache:Dictionary;
        private var lso:SharedObject;
        private var _130732411persistShuffle:Boolean = false;
        private var _1984153269service:Service;
        private var _342671880shuffleEnabled:Boolean = false;
        private var _2112713164crossfadeAmount:int = 5000;
        private var _169428869firstVisit:Boolean = true;
        private var _1456008984currentQueue:QueueJS;

        public function Model(_arg1:Service){
            var service:* = _arg1;
            super();
            this.songCache = new Dictionary(true);
            this.service = service;
            this.currentQueue = new QueueJS(this.service, this.songCache);
            this.chatClient = new JSONChatClient(this.service.uuid);
            if (this.service.session){
                this.chatClient.joinChannels([this.service.session]);
            };
            try {
                oldLSO = SharedObject.getLocal("userAuth");
            } catch(e:Error) {
                oldLSO = null;
            };
            try {
                lso = SharedObject.getLocal("jsQueue", "/");
            } catch(e:Error) {
                lso = null;
            };
            if (lso){
                queueToRestore = ObjectUtil.copy(lso.data.lastQueue);
                if (!isNaN(lso.data.volume)){
                    _volume = lso.data.volume;
                };
                if (((!(isNaN(lso.data.hasVisited))) || (!((lso.size === 0))))){
                    firstVisit = false;
                };
                lso.data.hasVisited = 1;
            };
            if (oldLSO){
                if (!queueToRestore){
                    queueToRestore = ObjectUtil.copy(oldLSO.data.lastQueue);
                };
                if (((!(isNaN(oldLSO.data.hasVisited))) || (!((oldLSO.size === 0))))){
                    firstVisit = false;
                };
            };
            flushLSOTimer = new Timer(1000, 1);
            flushLSOTimer.addEventListener(TimerEvent.TIMER_COMPLETE, onFlushLSOTimer);
            resetLSOTimer();
        }
        public function get persistShuffle():Boolean{
            return (this._130732411persistShuffle);
        }
        public function set chatClient(_arg1:JSONChatClient):void{
            var _local2:Object = this._2125426365chatClient;
            if (_local2 !== _arg1){
                this._2125426365chatClient = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "chatClient", _local2, _arg1));
            };
        }
        public function get shuffleEnabled():Boolean{
            return (this._342671880shuffleEnabled);
        }
        public function set persistShuffle(_arg1:Boolean):void{
            var _local2:Object = this._130732411persistShuffle;
            if (_local2 !== _arg1){
                this._130732411persistShuffle = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "persistShuffle", _local2, _arg1));
            };
        }
        public function set queueToRestore(_arg1:Object):void{
            var _local2:Object = this._2129144446queueToRestore;
            if (_local2 !== _arg1){
                this._2129144446queueToRestore = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "queueToRestore", _local2, _arg1));
            };
        }
        public function set shuffleEnabled(_arg1:Boolean):void{
            var _local2:Object = this._342671880shuffleEnabled;
            if (_local2 !== _arg1){
                this._342671880shuffleEnabled = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "shuffleEnabled", _local2, _arg1));
            };
        }
        public function get volume():Number{
            return (_volume);
        }
        public function get lastQueue():Object{
            if (lso){
                return (lso.data.lastQueue);
            };
            return (null);
        }
        public function get playPauseFadeEnabled():Boolean{
            return (this._662799197playPauseFadeEnabled);
        }
        public function get chatClient():JSONChatClient{
            return (this._2125426365chatClient);
        }
        public function get currentQueue():QueueJS{
            return (this._1456008984currentQueue);
        }
        private function set _810883302volume(_arg1:Number):void{
            if (_arg1 !== _volume){
                _volume = _arg1;
                if (lso){
                    lso.data.volume = _arg1;
                    resetLSOTimer();
                };
            };
        }
        public function get queueToRestore():Object{
            return (this._2129144446queueToRestore);
        }
        public function set currentQueue(_arg1:QueueJS):void{
            var _local2:Object = this._1456008984currentQueue;
            if (_local2 !== _arg1){
                this._1456008984currentQueue = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "currentQueue", _local2, _arg1));
            };
        }
        public function set previousQueue(_arg1:QueueJS):void{
            var _local2:Object = this._279334822previousQueue;
            if (_local2 !== _arg1){
                this._279334822previousQueue = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "previousQueue", _local2, _arg1));
            };
        }
        public function get service():Service{
            return (this._1984153269service);
        }
        public function set revision(_arg1:String):void{
            var _local2:Object = this._260786213revision;
            if (_local2 !== _arg1){
                this._260786213revision = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "revision", _local2, _arg1));
            };
        }
        public function set lastQueue(_arg1:Object):void{
            var _local2:Object = this.lastQueue;
            if (_local2 !== _arg1){
                this._2000405531lastQueue = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "lastQueue", _local2, _arg1));
            };
        }
        public function set volume(_arg1:Number):void{
            var _local2:Object = this.volume;
            if (_local2 !== _arg1){
                this._810883302volume = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "volume", _local2, _arg1));
            };
        }
        public function set playPauseFadeEnabled(_arg1:Boolean):void{
            var _local2:Object = this._662799197playPauseFadeEnabled;
            if (_local2 !== _arg1){
                this._662799197playPauseFadeEnabled = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "playPauseFadeEnabled", _local2, _arg1));
            };
        }
        private function set _2000405531lastQueue(_arg1:Object):void{
            if (lso){
                lso.data.lastQueue = _arg1;
                resetLSOTimer();
            };
        }
        public function set isMuted(_arg1:Boolean):void{
            var _local2:Object = this._2065669729isMuted;
            if (_local2 !== _arg1){
                this._2065669729isMuted = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "isMuted", _local2, _arg1));
            };
        }
        public function set crossfadeEnabled(_arg1:Boolean):void{
            var _local2:Object = this._1799419675crossfadeEnabled;
            if (_local2 !== _arg1){
                this._1799419675crossfadeEnabled = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "crossfadeEnabled", _local2, _arg1));
            };
        }
        private function resetLSOTimer(_arg1:CollectionEvent=null):void{
            flushLSOTimer.reset();
            flushLSOTimer.start();
        }
        public function get crossfadeAmount():int{
            return (this._2112713164crossfadeAmount);
        }
        public function get revision():String{
            return (this._260786213revision);
        }
        public function set songCache(_arg1:Dictionary):void{
            var _local2:Object = this._334409581songCache;
            if (_local2 !== _arg1){
                this._334409581songCache = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "songCache", _local2, _arg1));
            };
        }
        public function get crossfadeEnabled():Boolean{
            return (this._1799419675crossfadeEnabled);
        }
        public function get isMuted():Boolean{
            return (this._2065669729isMuted);
        }
        private function onFlushLSOTimer(_arg1:TimerEvent):void{
            var event:* = _arg1;
            if (lso){
                try {
                    lso.flush();
                } catch(e:Error) {
                };
            };
        }
        public function set service(_arg1:Service):void{
            var _local2:Object = this._1984153269service;
            if (_local2 !== _arg1){
                this._1984153269service = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "service", _local2, _arg1));
            };
        }
        public function get songCache():Dictionary{
            return (this._334409581songCache);
        }
        public function set crossfadeAmount(_arg1:int):void{
            var _local2:Object = this._2112713164crossfadeAmount;
            if (_local2 !== _arg1){
                this._2112713164crossfadeAmount = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "crossfadeAmount", _local2, _arg1));
            };
        }
        public function set firstVisit(_arg1:Boolean):void{
            var _local2:Object = this._169428869firstVisit;
            if (_local2 !== _arg1){
                this._169428869firstVisit = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "firstVisit", _local2, _arg1));
            };
        }
        public function get firstVisit():Boolean{
            return (this._169428869firstVisit);
        }
        public function get previousQueue():QueueJS{
            return (this._279334822previousQueue);
        }
        public function set currentUserID(_arg1:int):void{
            var _local2:Object = this._1995695873currentUserID;
            if (_local2 !== _arg1){
                this._1995695873currentUserID = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "currentUserID", _local2, _arg1));
            };
        }
        public function get currentUserID():int{
            return (this._1995695873currentUserID);
        }

    }
}//package com.grooveshark.jsQueue 
﻿package com.grooveshark.jsQueue {
    import flash.events.*;
    import com.grooveshark.framework.playback.*;

    public final class SongEvent extends Event {

        public static const SONG_DIRTY:String = "songDirty";

        public var song:QueueSong;

        public function SongEvent(_arg1:String, _arg2:QueueSong, _arg3:Boolean=false, _arg4:Boolean=false){
            super(_arg1, _arg3, _arg4);
            this.song = _arg2;
        }
        override public function clone():Event{
            return (new SongEvent(this.type, this.song, this.bubbles, this.cancelable));
        }

    }
}//package com.grooveshark.jsQueue 
﻿package com.grooveshark.utils {

    public class StringUtils {

        public static function ucfirst(_arg1:String):String{
            return ((_arg1.substr(0, 1).toUpperCase() + _arg1.substr(1)));
        }
        public static function ucwords(_arg1:String):String{
            var _local2:Array = _arg1.split(" ");
            var _local3:int;
            while (_local3 < _local2.length) {
                _local2[_local3] = StringUtils.ucfirst(_local2[_local3]);
                _local3++;
            };
            return (_local2.join(" "));
        }
        public static function condenseTitle(_arg1:String):String{
            var _local2:RegExp = /[^A-Za-z0-9]+/g;
            var _local3:RegExp = /\sand\s|\sbut\s|\sor\s|\sthe\s/g;
            _arg1 = _arg1.toLowerCase();
            _arg1 = _arg1.replace(_local2, " ");
            _arg1 = ((" " + _arg1) + " ");
            _arg1 = _arg1.replace(_local3, " ");
            _arg1 = _arg1.replace(/\s/g, "");
            return (_arg1);
        }

    }
}//package com.grooveshark.utils 
﻿package com.grooveshark.utils {
    import flash.utils.*;
    import mx.utils.*;

    public class LiteURLUtils {

        public static var hostname:String = "grooveshark.com";

        public static function cleanNameForURL(_arg1:String, _arg2:Boolean=true):String{
            _arg1 = _arg1.replace(/&/g, " and ");
            _arg1 = _arg1.replace(/#/g, " number ");
            _arg1 = _arg1.replace(/[^\w]/g, "_");
            if (_arg2){
                _arg1 = StringUtils.ucwords(_arg1);
            };
            _arg1 = StringUtil.trim(_arg1).replace(/\s/g, "_");
            _arg1 = _arg1.replace(/__+/g, "_");
            _arg1 = escapeMultiByte(_arg1);
            _arg1 = _arg1.replace(/%5F/g, "+");
            return (_arg1);
        }
        public static function generateURL(_arg1:String, _arg2:int, _arg3:String, _arg4:String=null, _arg5:Boolean=false):String{
            var _local6:String;
            _arg1 = ((_arg1) ? _arg1 : "Unknown");
            _arg1 = cleanNameForURL(_arg1, !((_arg3 == "user")));
            _arg3 = _arg3.toLowerCase();
            if (_arg4){
                if (_arg3 == "song"){
                    _arg3 = "s";
                };
                if (_arg5){
                    _local6 = (((((((("http://" + hostname) + "/") + _arg3) + "/") + _arg1) + "/") + _arg4) + "?src=6");
                } else {
                    _local6 = (((((((("http://" + hostname) + "/#/") + _arg3) + "/") + _arg1) + "/") + _arg4) + "?src=6");
                };
            } else {
                if (_arg5){
                    _local6 = (((((((("http://" + hostname) + "/") + _arg3) + "/") + _arg1) + "/") + _arg2) + "?src=6");
                } else {
                    _local6 = (((((((("http://" + hostname) + "/#/") + _arg3) + "/") + _arg1) + "/") + _arg2) + "?src=6");
                };
            };
            return (_local6);
        }
        public static function generate404():String{
            return ((("http://" + hostname) + "/#/404?src=6"));
        }
        public static function extractURLFragment(_arg1:String):String{
            var _local2:String = URLUtil.getServerName(_arg1);
            var _local3:String = _arg1.substr((_arg1.indexOf(_local2) + _local2.length));
            while ((((_local3.indexOf("/") == 0)) || ((_local3.indexOf("#") == 0)))) {
                _local3 = _local3.substr(1);
            };
            return (_local3);
        }

    }
}//package com.grooveshark.utils 
﻿package com.grooveshark.utils {
    import flash.events.*;

    public class Debug extends EventDispatcher {

        private static var _instance:Debug;

        public function Debug(_arg1:SingletonEnforcer){
        }
        public static function getInstance():Debug{
            if (_instance == null){
                _instance = new Debug(new SingletonEnforcer());
            };
            return (_instance);
        }

        public function print(_arg1):void{
            var _local2:*;
            if ((_arg1 is Array)){
                for each (_local2 in _arg1) {
                    print(_local2);
                };
            } else {
                trace(_arg1);
            };
        }

    }
}//package com.grooveshark.utils 

class SingletonEnforcer {

    public function SingletonEnforcer(){
    }
}
﻿package com.grooveshark.socket {
    import flash.events.*;

    public final class JSONChatEvent extends Event {

        public static const CONNECTION_ERROR:String = "connectionError";
        public static const CHANNEL_JOIN_ERROR:String = "channelJoinError";
        public static const CONNECTION_DROP:String = "connectionDrop";
        public static const DATA_RECEIVED:String = "dataReceived";
        public static const OTHER_IO_ERROR:String = "otherIOError";
        public static const DATA_PARSE_ERROR:String = "dataParseError";

        public var data:Object;

        public function JSONChatEvent(_arg1:String, _arg2:Object=null, _arg3:Boolean=false, _arg4:Boolean=false){
            super(_arg1, _arg3, _arg4);
            this.data = _arg2;
        }
        override public function clone():Event{
            return (new JSONChatEvent(this.type, this.data, this.bubbles, this.cancelable));
        }

    }
}//package com.grooveshark.socket 
﻿package com.grooveshark.socket {
    import flash.events.*;
    import com.adobe.serialization.json.*;
    import flash.net.*;

    public class JSONChatClient extends EventDispatcher {

        private var pendingServer:Object;
        private var availableServers:Object;
        private var uuid:String;
        private var failedServers:Array;
        public var currentServer:Object;
        public var currentChannels:Array;
        private var socket:Socket;

        public function JSONChatClient(_arg1:String, _arg2:Array=null){
            currentChannels = [];
            super();
            this.availableServers = ((_arg2) ? _arg2 : []);
            this.failedServers = [];
            this.uuid = _arg1;
            this.socket = new Socket();
            this.socket.addEventListener(Event.CONNECT, onSocketConnect);
            this.socket.addEventListener(Event.CLOSE, onSocketClose);
            this.socket.addEventListener(IOErrorEvent.IO_ERROR, onSocketIOError);
            this.socket.addEventListener(SecurityErrorEvent.SECURITY_ERROR, onSocketSecurityError);
            this.socket.addEventListener(ProgressEvent.SOCKET_DATA, onSocketData);
        }
        private function failServer(_arg1:Object):void{
            var _local2:int = this.availableServers.indexOf(_arg1);
            if (_local2 != -1){
                this.availableServers.splice(_local2, 1);
            };
            _local2 = this.failedServers.indexOf(_arg1);
            if (_local2 != -1){
                this.failedServers.push(_arg1);
            };
        }
        private function onSocketIOError(_arg1:IOErrorEvent):void{
            this.dispatchEvent(new JSONChatEvent(JSONChatEvent.OTHER_IO_ERROR, {server:this.currentServer}));
        }
        public function setServers(_arg1:Array):void{
            var _local2:Object;
            trace(("CHAT: set servers " + _arg1));
            this.availableServers = _arg1;
            this.failedServers = [];
            if (((this.currentServer) || (this.pendingServer))){
                for each (_local2 in _arg1) {
                    if (((this.currentServer) && ((_local2.host == this.currentServer.host)))){
                        this.currentServer = _local2;
                    };
                    if (((this.pendingServer) && ((_local2.host == this.pendingServer.host)))){
                        this.pendingServer = _local2;
                    };
                };
            } else {
                this.reconnect();
            };
        }
        private function onSocketSecurityError(_arg1:SecurityErrorEvent):void{
            this.dispatchEvent(new JSONChatEvent(JSONChatEvent.CONNECTION_ERROR, {
                type:"securityError",
                server:this.pendingServer
            }));
            failServer(this.pendingServer);
            this.pendingServer = null;
            reconnect();
        }
        private function reconnect():void{
            if (this.socket.connected){
                this.socket.close();
            };
            if (this.availableServers.length){
                this.pendingServer = chooseServer();
                this.socket.connect(this.pendingServer.host, this.pendingServer.port);
                trace(("CHAT attempting to connect: " + this.pendingServer.host));
            } else {
                if (this.failedServers.length){
                    this.dispatchEvent(new JSONChatEvent(JSONChatEvent.CONNECTION_ERROR, {
                        type:"noServersAvailable",
                        previouslyFailed:this.failedServers
                    }));
                };
            };
        }
        private function onSocketConnect(_arg1:Event):void{
            this.currentServer = this.pendingServer;
            this.pendingServer = null;
            if (this.currentChannels.length){
                sendChannelRequest("sub", this.currentChannels);
            };
        }
        private function sendData(_arg1:Object):Boolean{
            var data:* = _arg1;
            if (!(data is String)){
                try {
                    data = JSON.encode(data);
                } catch(e:Error) {
                    trace("CHAT data to send is not string, but JSON encode failed");
                    return (false);
                };
            };
            if (data.charAt((data.length - 1)) !== "\n"){
                data = (data + "\n");
            };
            trace(("CHAT sending data: " + data));
            try {
                this.socket.writeUTFBytes(String(data));
                this.socket.flush();
            } catch(e:Error) {
                return (false);
            };
            return (true);
        }
        public function joinChannels(_arg1:Array):void{
            var _local3:String;
            var _local2:int;
            for each (_local3 in _arg1) {
                if (currentChannels.indexOf(_local3) == -1){
                    currentChannels.push(_local3);
                    _local2++;
                };
            };
            if (_local2){
                sendChannelRequest("sub", currentChannels);
            };
        }
        public function partChannels(_arg1:Array):void{
            var _local3:String;
            var _local4:int;
            var _local2:int;
            for each (_local3 in _arg1) {
                _local4 = currentChannels.indexOf(_local3);
                if (_local4 != -1){
                    currentChannels.splice(_local4, 1);
                    _local2++;
                };
            };
            if (_local2){
                sendChannelRequest("sub", currentChannels);
            };
        }
        private function sendChannelRequest(_arg1:String, _arg2:Array):void{
            var _local3:Object;
            if (this.socket.connected){
                _local3 = {
                    command:_arg1,
                    params:{
                        uid:this.uuid,
                        subs:_arg2
                    }
                };
                if (!this.sendData(_local3)){
                    this.dispatchEvent(new JSONChatEvent(JSONChatEvent.CHANNEL_JOIN_ERROR, {
                        server:this.currentServer,
                        channels:this.currentChannels
                    }));
                };
            } else {
                if (!this.pendingServer){
                    this.reconnect();
                };
            };
        }
        private function onSocketClose(_arg1:Event):void{
            this.dispatchEvent(new JSONChatEvent(JSONChatEvent.CONNECTION_DROP, {server:this.currentServer}));
            var _local2:Number = new Date().valueOf();
            if (((!(this.currentServer.lastConnectionDrop)) || (((_local2 - this.currentServer.lastConnectionDrop) > 60000)))){
                this.currentServer.lastConnectionDrop = _local2;
            } else {
                failServer(this.currentServer);
            };
            this.currentServer = null;
            reconnect();
        }
        private function chooseServer():Object{
            var _local4:Number;
            var _local1:Number = 0;
            var _local2:int;
            while (_local2 < this.availableServers.length) {
                _local1 = (_local1 + this.availableServers[_local2].weight);
                _local2++;
            };
            var _local3:int = Math.floor((Math.random() * _local1));
            _local1 = 0;
            _local2 = 0;
            while (_local2 < this.availableServers.length) {
                _local4 = _local1;
                _local1 = (_local1 + this.availableServers[_local2].weight);
                if ((((_local4 <= _local3)) && ((_local1 > _local3)))){
                    return (this.availableServers[_local2]);
                };
                _local2++;
            };
            return (this.availableServers[0]);
        }
        private function onSocketData(_arg1:ProgressEvent):void{
            var msg:* = null;
            var data:* = null;
            var event:* = _arg1;
            var dataStr:* = this.socket.readUTFBytes(this.socket.bytesAvailable);
            var msgs:* = dataStr.split("\n");
            for each (msg in msgs) {
                if (msg.length){
                    try {
                        data = JSON.decode(msg);
                    } catch(e:Error) {
                        this.dispatchEvent(new JSONChatEvent(JSONChatEvent.DATA_PARSE_ERROR, {
                            server:this.currentServer,
                            rawData:msg
                        }));
                        continue;
                    };
                    this.dispatchEvent(new JSONChatEvent(JSONChatEvent.DATA_RECEIVED, {
                        server:this.currentServer,
                        rawData:msg,
                        data:data
                    }));
                };
            };
        }

    }
}//package com.grooveshark.socket 
﻿package com.grooveshark.framework {
    import flash.events.*;
    import mx.events.*;
    import com.grooveshark.utils.*;

    public class BasePlaylist extends EventDispatcher {

        private var _980229514artFilename:String;
        private var _580007805playlistName:String = "";
        private var _2006098323playlistID:int = 0;
        private var _1899997672numSongs:int;
        private var _265713450username:String;
        private var _1724546052description:String = "";
        private var _836030938userID:int;

        public function get description():String{
            return (this._1724546052description);
        }
        public function getShareURL():String{
            return (LiteURLUtils.generateURL(playlistName, playlistID, "playlist", null, true));
        }
        public function get artFilename():String{
            return (this._980229514artFilename);
        }
        public function set userID(_arg1:int):void{
            var _local2:Object = this._836030938userID;
            if (_local2 !== _arg1){
                this._836030938userID = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "userID", _local2, _arg1));
            };
        }
        public function set artFilename(_arg1:String):void{
            var _local2:Object = this._980229514artFilename;
            if (_local2 !== _arg1){
                this._980229514artFilename = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "artFilename", _local2, _arg1));
            };
        }
        public function get username():String{
            return (this._265713450username);
        }
        public function set playlistID(_arg1:int):void{
            var _local2:Object = this._2006098323playlistID;
            if (_local2 !== _arg1){
                this._2006098323playlistID = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "playlistID", _local2, _arg1));
            };
        }
        public function get numSongs():int{
            return (this._1899997672numSongs);
        }
        override public function toString():String{
            return (((("[BasePlaylist] " + playlistID) + ":") + playlistName));
        }
        public function get userID():int{
            return (this._836030938userID);
        }
        public function get playlistID():int{
            return (this._2006098323playlistID);
        }
        public function set numSongs(_arg1:int):void{
            var _local2:Object = this._1899997672numSongs;
            if (_local2 !== _arg1){
                this._1899997672numSongs = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "numSongs", _local2, _arg1));
            };
        }
        public function set description(_arg1:String):void{
            var _local2:Object = this._1724546052description;
            if (_local2 !== _arg1){
                this._1724546052description = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "description", _local2, _arg1));
            };
        }
        public function getURL():String{
            return (LiteURLUtils.generateURL(playlistName, playlistID, "playlist"));
        }
        public function set playlistName(_arg1:String):void{
            var _local2:Object = this._580007805playlistName;
            if (_local2 !== _arg1){
                this._580007805playlistName = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "playlistName", _local2, _arg1));
            };
        }
        public function set username(_arg1:String):void{
            var _local2:Object = this._265713450username;
            if (_local2 !== _arg1){
                this._265713450username = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "username", _local2, _arg1));
            };
        }
        public function get playlistName():String{
            return (this._580007805playlistName);
        }

    }
}//package com.grooveshark.framework 
﻿package com.grooveshark.framework.playback.commands {
    import flash.events.*;
    import com.grooveshark.framework.playback.*;
    import com.grooveshark.framework.*;
    import com.grooveshark.jsonrpc.*;
    import mx.collections.*;
    import com.grooveshark.utils.*;

    public final class AddSongsFromPlaylist extends QueueCommand {

        private var index:int;
        private var playlist:BasePlaylist;
        private var playOnAdd:Boolean;

        public function AddSongsFromPlaylist(_arg1:IDualService, _arg2:Queue, _arg3:BasePlaylist, _arg4:int, _arg5:Boolean){
            super(_arg1, _arg2);
            this.playlist = _arg3;
            this.index = _arg4;
            this.playOnAdd = _arg5;
        }
        override public function execute():void{
            if (playlist){
                service.send(false, "playlistGetSongs", {playlistID:playlist.playlistID}, new ItemResponder(serviceSuccess, serviceFault));
            } else {
                Debug.getInstance().print("[AddSongsFromPlaylist] Failed: No playlist provided.");
                dispatchEvent(new Event("failed"));
            };
        }
        private function serviceSuccess(_arg1:Object, _arg2:Object=null):void{
            var _local5:Object;
            var _local6:BaseSong;
            var _local3:Array = ((_arg1 as JSONResult).result.Songs as Array);
            var _local4:Array = [];
            if (_local3){
                _local3.sortOn("Sort", Array.NUMERIC);
                for each (_local5 in _local3) {
                    _local6 = new BaseSong();
                    _local6.songID = int(_local5.SongID);
                    _local6.songName = String(_local5.Name);
                    _local6.artistID = int(_local5.ArtistID);
                    _local6.artistName = String(_local5.ArtistName);
                    _local6.albumID = int(_local5.AlbumID);
                    _local6.albumName = String(_local5.AlbumName);
                    if (_local5.CoverArtFilename){
                        _local6.artFilename = String(_local5.CoverArtFilename);
                    };
                    if (int(_local5.EstimateDuration)){
                        _local6.estimateDuration = (int(_local5.EstimateDuration) * 1000);
                    };
                    _local4.push(_local6);
                };
            };
            queue.addItemsAt(_local4, index, playOnAdd);
            queue.lastPlaylistID = playlist.playlistID;
            this.dispatchEvent(new Event(Event.COMPLETE));
        }
        private function serviceFault(_arg1:Object, _arg2:Object=null):void{
            queue.dispatchEvent(new QueueEvent(QueueEvent.ERROR_ADDING_SONGS, QueueEvent.FAILED_TO_CREATE_SONGS, true, {playlist:this.playlist}));
            dispatchEvent(new Event("failed"));
        }

    }
}//package com.grooveshark.framework.playback.commands 
﻿package com.grooveshark.framework.playback.commands {
    import flash.events.*;
    import com.grooveshark.framework.playback.*;
    import com.grooveshark.framework.*;
    import com.grooveshark.jsonrpc.*;
    import mx.collections.*;

    public final class PrefetchStreamKeys extends EventDispatcher implements ICommand {

        private var songIDs:Array;
        private var service:IDualService;
        public var results:Object;

        public function PrefetchStreamKeys(_arg1:IDualService, _arg2:Array){
            this.service = _arg1;
            this.songIDs = _arg2;
            this.results = {};
        }
        public function execute():void{
            service.send(false, "getStreamKeysFromSongIDs", {
                songIDs:songIDs,
                prefetch:false,
                country:service.country,
                mobile:PlayableSong.useMobile
            }, new ItemResponder(serviceSuccess, serviceFault));
        }
        private function serviceSuccess(_arg1:Object, _arg2:Object=null):void{
            var _local5:String;
            var _local6:String;
            var _local7:String;
            var _local8:int;
            var _local9:Number;
            var _local10:Object;
            var _local3:JSONResult = (_arg1 as JSONResult);
            var _local4:Number = (new Date().valueOf() + ((9 * 60) * 1000));
            if (((_local3) && (_local3.result))){
                for (_local5 in _local3.result) {
                    _local6 = (_local3.result[_local5].streamKey as String);
                    _local7 = (_local3.result[_local5].ip as String);
                    _local8 = int(_local3.result[_local5].streamServerID);
                    _local9 = Number(_local3.result[_local5].uSecs);
                    if (((((!((_local6 === "false"))) && (!((_local6 === "null"))))) && (_local8))){
                        _local10 = {
                            streamKey:_local6,
                            ip:_local7,
                            serverID:_local8,
                            uSecs:_local9,
                            expires:_local4
                        };
                        this.results[int(_local5)] = _local10;
                    };
                };
            };
            this.dispatchEvent(new Event(Event.COMPLETE));
        }
        private function serviceFault(_arg1:Object, _arg2:Object=null):void{
            dispatchEvent(new Event("failed"));
        }

    }
}//package com.grooveshark.framework.playback.commands 
﻿package com.grooveshark.framework.playback.commands {
    import flash.events.*;
    import com.grooveshark.framework.playback.*;
    import com.grooveshark.jsonrpc.*;
    import mx.collections.*;
    import com.grooveshark.utils.*;

    public class ReportCorrectDuration extends SongCommand {

        public function ReportCorrectDuration(_arg1:IDualService, _arg2:PlayableSong){
            super(_arg1, _arg2);
        }
        private function reexecute(_arg1:Event):void{
            execute();
        }
        private function onFail(_arg1:String, _arg2:Boolean=true):void{
            Debug.getInstance().print((("[ReportCorrectDuration] Failed: " + _arg1) + " Giving up."));
            dispatchEvent(new Event("failed"));
        }
        override public function execute():void{
            if (((((!(song)) || (!(song.lastStreamKey)))) || (!(song.duration)))){
                onFail("Either no song, or song is missing streamKey or duration is 0.", false);
                return;
            };
            var _local1:Object = {};
            _local1.streamKey = song.lastStreamKey;
            _local1.streamServerID = song.lastServerID;
            _local1.songID = song.song.songID;
            _local1.length = (song.duration / 1000);
            service.send(false, "updateStreamKeyLength", _local1, new ItemResponder(serviceSuccess, serviceFault));
        }
        private function serviceFault(_arg1:Object, _arg2:Object=null):void{
            onFail((_arg1 as JSONFault).message, !(((_arg1 as JSONFault).code == -256)));
        }
        private function serviceSuccess(_arg1:Object, _arg2:Object=null):void{
            dispatchEvent(new Event(Event.COMPLETE));
        }

    }
}//package com.grooveshark.framework.playback.commands 
﻿package com.grooveshark.framework.playback.commands {
    import flash.events.*;
    import com.grooveshark.framework.playback.*;
    import flash.utils.*;
    import com.grooveshark.framework.*;
    import com.grooveshark.jsonrpc.*;
    import mx.collections.*;
    import mx.utils.*;
    import com.grooveshark.utils.*;

    public class GetAutoplaySong extends QueueCommand {

        private var status:Object;
        private var attempts:int = 0;

        public function GetAutoplaySong(_arg1:IDualService, _arg2:Queue){
            super(_arg1, _arg2);
            if (!_arg2.gs_queue::autoplayStatus){
                _arg2.gs_queue::autoplayStatus = new AutoplayStatus(_arg2);
            };
            this.status = _arg2.gs_queue::autoplayStatus.statusForRPC;
        }
        override public function execute():void{
            if (((!(queue)) || (!(queue.queueID)))){
                onFail(QueueEvent.QUEUE_NOT_READY, false);
                return;
            };
            if (((((!(queue.autoplayEnabled)) || (queue.hasNextSong))) || (!((queue.gs_queue::pendingAdds == 0))))){
                onFail("songNotRequired", false);
                return;
            };
            if (status.seedArtists.length == 0){
                onFail(QueueEvent.NO_SEEDS, false);
                return;
            };
            if ((((queue.gs_queue::consecutiveFailedAutoplayRequests >= 3)) && (((getTimer() - queue.gs_queue::lastFailedAutoplayRequest) < 5000)))){
                onFail(QueueEvent.TOO_MANY_FAILURES, false);
                return;
            };
            var _local1:Object = ObjectUtil.copy(status);
            _local1.songQueueID = queue.queueID;
            _local1.country = service.country;
            if (queue.currentAutoplayTag){
                _local1.tagID = queue.currentAutoplayTag.tagID;
            };
            attempts++;
            service.send(false, "autoplayGetSong", _local1, new ItemResponder(serviceSuccess, serviceFault));
        }
        private function reexecute(_arg1:Event):void{
            execute();
        }
        private function onFail(_arg1:String, _arg2:Boolean=true):void{
            var _local3:int;
            var _local4:Timer;
            if (((_arg2) && ((attempts < 3)))){
                Debug.getInstance().print((("[GetAutoplaySong] Failed: " + _arg1) + " Will re-attempt."));
                _local3 = (100 + Math.floor((Math.random() * 400)));
                _local4 = new Timer(_local3, 1);
                _local4.addEventListener(TimerEvent.TIMER_COMPLETE, reexecute, false, 0, true);
                _local4.start();
            } else {
                Debug.getInstance().print((("[GetAutoplaySong] Failed: " + _arg1) + " Giving up."));
                switch (_arg1){
                    case "songNotRequired":
                        break;
                    case QueueEvent.TOO_MANY_FAILURES:
                        queue.dispatchEvent(new QueueEvent(QueueEvent.AUTOPLAY_FAILED, _arg1, true));
                        queue.setAutoplayEnabled(false, false);
                        break;
                    case "tokenFailure":
                    case "maintenanceMode":
                        queue.gs_queue::consecutiveFailedAutoplayRequests++;
                        queue.gs_queue::lastFailedAutoplayRequest = getTimer();
                        break;
                    default:
                        queue.gs_queue::consecutiveFailedAutoplayRequests++;
                        queue.gs_queue::lastFailedAutoplayRequest = getTimer();
                        queue.dispatchEvent(new QueueEvent(QueueEvent.AUTOPLAY_FAILED, _arg1, false));
                };
                dispatchEvent(new Event("failed"));
            };
        }
        protected function makeSongFromRaw(_arg1:Object):BaseSong{
            var _local3:Array;
            var _local2:BaseSong = new BaseSong();
            _local2.songID = _arg1.SongID;
            _local2.songName = _arg1.SongName;
            _local2.artistID = _arg1.ArtistID;
            _local2.artistName = _arg1.ArtistName;
            _local2.albumID = _arg1.AlbumID;
            _local2.albumName = _arg1.AlbumName;
            _local2.estimateDuration = (int(_arg1.EstimateDuration) * 1000);
            if (_arg1.CoverArtUrl){
                _local3 = String(_arg1.CoverArtUrl).split("/");
                if (_local3.length){
                    _local2.artFilename = String(_local3[(_local3.length - 1)]).substring(1);
                };
            };
            return (_local2);
        }
        private function serviceSuccess(_arg1:Object, _arg2:Object=null):void{
            queue.gs_queue::consecutiveFailedAutoplayRequests = 0;
            if (((!(queue.autoplayEnabled)) || (queue.hasNextSong))){
                onFail("songNotRequired", false);
                return;
            };
            var _local3:Object = (_arg1 as JSONResult).result;
            if (!_local3){
                onFail(QueueEvent.UNKNOWN_ERROR);
                return;
            };
            var _local4:BaseSong = makeSongFromRaw(_local3);
            var _local5:QueueSong = new QueueSong(_local4, queue, service, {
                type:"radio",
                data:{}
            });
            _local5.source = _local3.source;
            if (queue.currentAutoplayTag){
                _local5.context.data.tagID = queue.currentAutoplayTag.tagID;
            };
            _local5.sponsoredAutoplayID = int(_local3.SponsoredAutoplayID);
            var _local6:String = StringUtils.condenseTitle(_local5.song.songName);
            if (((((queue.gs_queue::autoplayStatus) && (!((queue.gs_queue::autoplayStatus.badTitles.indexOf(_local6) == -1))))) && ((attempts < 3)))){
                this.status.songIDsAlreadySeen.push(_local5.song.songID);
                onFail("Title Match");
                return;
            };
            var _local7:Boolean;
            if (((queue.activeSong) && ((queue.getItemIndex(queue.activeSong) == (queue.length - 1))))){
                switch (queue.activeSong.playStatus){
                    case PlayableSong.PLAY_STATUS_FAILED:
                    case PlayableSong.PLAY_STATUS_COMPLETED:
                        _local7 = true;
                        break;
                };
            } else {
                if (!queue.activeSong){
                    _local7 = true;
                };
            };
            queue.addItemsAt([_local5], -1, _local7);
            dispatchEvent(new Event(Event.COMPLETE));
        }
        private function serviceFault(_arg1:Object, _arg2:Object=null):void{
            var _local4:String;
            var _local3:JSONFault = (_arg1 as JSONFault);
            switch (_local3.code){
                case 0x0800:
                    _local4 = QueueEvent.NO_RECOMMENDATIONS;
                    queue.setAutoplayEnabled(false, false);
                    break;
                case 0x0200:
                    _local4 = QueueEvent.RATE_LIMIT_EXCEEDED;
                    queue.setAutoplayEnabled(false, false);
                    break;
                case -256:
                    _local4 = "tokenFailure";
                    queue.setAutoplayEnabled(false, false);
                    break;
                case 10:
                    _local4 = "maintenanceMode";
                    queue.setAutoplayEnabled(false, false);
                    break;
                default:
                    _local4 = QueueEvent.UNKNOWN_ERROR;
            };
            onFail(_local4, (_local4 == QueueEvent.UNKNOWN_ERROR));
        }

    }
}//package com.grooveshark.framework.playback.commands 
﻿package com.grooveshark.framework.playback.commands {
    import flash.events.*;
    import com.grooveshark.framework.playback.*;
    import com.grooveshark.framework.*;
    import com.grooveshark.jsonrpc.*;

    public class QueueCommand extends EventDispatcher implements ICommand {

        protected var queue:Queue;
        protected var service:IDualService;

        public function QueueCommand(_arg1:IDualService, _arg2:Queue){
            this.service = _arg1;
            this.queue = _arg2;
        }
        public function execute():void{
        }

    }
}//package com.grooveshark.framework.playback.commands 
﻿package com.grooveshark.framework.playback.commands {
    import flash.events.*;
    import com.grooveshark.framework.playback.*;
    import com.grooveshark.jsonrpc.*;
    import mx.collections.*;
    import com.grooveshark.utils.*;

    public class MarkSongOver30Seconds extends SongCommand {

        public function MarkSongOver30Seconds(_arg1:IDualService, _arg2:PlayableSong){
            super(_arg1, _arg2);
        }
        private function reexecute(_arg1:Event):void{
            execute();
        }
        private function onFail(_arg1:String, _arg2:Boolean=true):void{
            Debug.getInstance().print((("[MarkSongOver30Seconds] Failed: " + _arg1) + " Giving up."));
            dispatchEvent(new Event("failed"));
        }
        override public function execute():void{
            if (((!(song)) || (!(song.lastStreamKey)))){
                onFail("Either no song, or song is missing streamKey.", false);
                return;
            };
            var _local1:Object = {};
            _local1.streamKey = song.lastStreamKey;
            _local1.streamServerID = song.lastServerID;
            _local1.songID = song.song.songID;
            var _local2:Object = song;
            if (_local2.hasOwnProperty("queueSongID")){
                _local1.songQueueSongID = _local2.queueSongID;
            } else {
                _local1.songQueueSongID = 0;
            };
            if (((_local2.hasOwnProperty("parent")) && (_local2.parent.hasOwnProperty("queueID")))){
                _local1.songQueueID = _local2.parent.queueID;
            } else {
                _local1.songQueueID = 0;
            };
            service.send(false, "markStreamKeyOver30Seconds", _local1, new ItemResponder(serviceSuccess, serviceFault));
        }
        private function serviceFault(_arg1:Object, _arg2:Object=null):void{
            onFail((_arg1 as JSONFault).message, !(((_arg1 as JSONFault).code == -256)));
        }
        private function serviceSuccess(_arg1:Object, _arg2:Object=null):void{
            dispatchEvent(new Event(Event.COMPLETE));
        }

    }
}//package com.grooveshark.framework.playback.commands 
﻿package com.grooveshark.framework.playback.commands {
    import flash.events.*;
    import com.grooveshark.framework.playback.*;
    import com.grooveshark.framework.*;
    import com.grooveshark.jsonrpc.*;

    public class SongCommand extends EventDispatcher implements ICommand {

        protected var song:PlayableSong;
        protected var service:IDualService;

        public function SongCommand(_arg1:IDualService, _arg2:PlayableSong){
            this.service = _arg1;
            this.song = _arg2;
        }
        public function execute():void{
        }

    }
}//package com.grooveshark.framework.playback.commands 
﻿package com.grooveshark.framework.playback.commands {
    import flash.events.*;
    import com.grooveshark.framework.playback.*;
    import flash.utils.*;
    import com.grooveshark.framework.*;
    import com.grooveshark.jsonrpc.*;
    import mx.collections.*;

    public class AddSongsToQueue extends QueueCommand {

        protected var ignoreInitFail:Boolean = false;
        private var relativeSong:QueueSong = null;
        protected var items:Array;
        protected var index:int;
        protected var processTimer:Timer;
        protected var autoplayOnAdd:Boolean;
        protected var idsToFetch:Array;
        protected var queueSongs:Array;
        protected var playOnAdd:Boolean;
        protected var context:Object;

        public function AddSongsToQueue(_arg1:IDualService, _arg2:Queue, _arg3:Array, _arg4:int, _arg5:Boolean, _arg6:Boolean, _arg7:Object){
            idsToFetch = [];
            super(_arg1, _arg2);
            this.items = _arg3;
            this.index = _arg4;
            this.playOnAdd = _arg5;
            this.autoplayOnAdd = _arg6;
            this.context = _arg7;
            _arg2.gs_queue::pendingAdds++;
        }
        private function onSongCreateComplete(_arg1:Object, _arg2:Object=null):void{
            var _local5:Object;
            var _local6:int;
            var _local7:Array;
            var _local8:int;
            var _local9:BaseSong;
            var _local10:int;
            var _local11:int;
            var _local3:Array = ((_arg1 as JSONResult).result as Array);
            var _local4:Object = {};
            for each (_local5 in _local3) {
                _local9 = new BaseSong();
                _local9.songID = int(_local5.SongID);
                _local9.songName = String(_local5.Name);
                _local9.artistID = int(_local5.ArtistID);
                _local9.artistName = String(_local5.ArtistName);
                _local9.albumID = int(_local5.AlbumID);
                _local9.albumName = String(_local5.AlbumName);
                if (_local5.CoverArtFilename){
                    _local9.artFilename = String(_local5.CoverArtFilename);
                };
                if (int(_local5.EstimateDuration)){
                    _local9.estimateDuration = (int(_local5.EstimateDuration) * 1000);
                };
                _local4[_local9.songID] = _local9;
            };
            _local6 = 0;
            _local7 = [];
            _local8 = 0;
            while (_local8 < queueSongs.length) {
                if (!queueSongs[_local8]){
                    _local9 = _local4[idsToFetch[_local6]];
                    if (_local9){
                        queueSongs[_local8] = new QueueSong(_local9, queue, service, context);
                    } else {
                        _local7.push(_local8);
                    };
                    _local6++;
                };
                _local8++;
            };
            if (_local7.length){
                _local10 = 0;
                while (_local10 < _local7.length) {
                    _local11 = (_local7[_local10] + _local10);
                    queueSongs.splice(_local11, 1);
                    _local10++;
                };
            };
            execute();
        }
        private function onSongCreateFailed(_arg1:Object, _arg2:Object=null):void{
            queue.dispatchEvent(new QueueEvent(QueueEvent.ERROR_ADDING_SONGS, QueueEvent.FAILED_TO_CREATE_SONGS, true, {songs:this.items}));
            queue.gs_queue::pendingAdds--;
            dispatchEvent(new Event("failed"));
        }
        private function processSongs(_arg1:TimerEvent):void{
            trace(("[AddSongsToQueue] processSongs: songs left " + queueSongs.length));
            if (!queueSongs.length){
                processTimer.stop();
                processTimer.removeEventListener(TimerEvent.TIMER, processSongs);
                queue.gs_queue::pendingAdds--;
                this.dispatchEvent(new Event(Event.COMPLETE));
                return;
            };
            var _local2:Array = queueSongs.splice(0, queue.gs_queue::chunkSize);
            var _local3:Object = buildParams(_local2);
            service.send(false, "addSongsToQueue", _local3);
            if (relativeSong){
                index = Queue.gs_queue::INDEX_RELATIVE;
                playOnAdd = false;
                autoplayOnAdd = false;
            };
            trace(((("Sent " + _local2.length) + "items, queue chunk size is: ") + queue.gs_queue::chunkSize));
            queue.gs_queue::completeAddSongsAt(_local2, index, playOnAdd, autoplayOnAdd, relativeSong);
            relativeSong = (_local2[(_local2.length - 1)] as QueueSong);
        }
        private function buildParams(_arg1:Array):Object{
            var _local3:QueueSong;
            var _local4:Object;
            var _local5:Object;
            var _local2:Array = [];
            for each (_local3 in _arg1) {
                _local3.queueSongID = queue.gs_queue::songCount;
                queue.gs_queue::songCount++;
                _local5 = {};
                _local5.songID = _local3.song.songID;
                _local5.artistID = _local3.song.artistID;
                _local5.songQueueSongID = _local3.queueSongID;
                _local5.source = _local3.source;
                _local2.push(_local5);
            };
            _local4 = {};
            _local4.songIDsArtistIDs = _local2;
            _local4.songQueueID = queue.queueID;
            return (_local4);
        }
        protected function buildQueueSongsArray():void{
            var _local3:Object;
            var _local4:BaseSong;
            var _local5:int;
            var _local6:int;
            queueSongs = new Array(items.length);
            var _local1:Array = [];
            var _local2:int;
            while (_local2 < items.length) {
                _local3 = items[_local2];
                if ((_local3 is QueueSong)){
                    if ((_local3 as QueueSong).queueSongID != 0){
                        queueSongs[_local2] = new QueueSong(_local3.song, queue, service, context);
                    } else {
                        queueSongs[_local2] = _local3;
                    };
                } else {
                    if ((_local3 is BaseSong)){
                        queueSongs[_local2] = new QueueSong((_local3 as BaseSong), queue, service, context);
                    } else {
                        if (int(_local3)){
                            _local4 = idToSong(int(_local3));
                            if (_local4){
                                queueSongs[_local2] = new QueueSong(_local4, queue, service, context);
                            } else {
                                idsToFetch.push(int(_local3));
                            };
                        } else {
                            _local1.push(_local2);
                        };
                    };
                };
                _local2++;
            };
            if (_local1.length){
                _local5 = 0;
                while (_local5 < _local1.length) {
                    _local6 = (_local1[_local5] + _local5);
                    queueSongs.splice(_local6, 1);
                    _local5++;
                };
            };
            if (idsToFetch.length){
                fetchMissingIDs();
            } else {
                execute();
            };
        }
        private function reexecute(_arg1:Event):void{
            execute();
        }
        protected function idToSong(_arg1:int):BaseSong{
            return (null);
        }
        private function onInitQueueFail(_arg1:Event):void{
            ignoreInitFail = true;
            execute();
        }
        protected function fetchMissingIDs():void{
            service.send(false, "getQueueSongListFromSongIDs", {songIDs:idsToFetch}, new ItemResponder(onSongCreateComplete, onSongCreateFailed));
        }
        override public function execute():void{
            var _local1:InitiateQueue;
            if (((!(items)) || (!(items.length)))){
                trace("tried to add empty array to queue");
                dispatchEvent(new Event("failed"));
                return;
            };
            if (((!(queue.queueID)) && (!(ignoreInitFail)))){
                _local1 = new InitiateQueue(service, queue);
                _local1.addEventListener(Event.COMPLETE, reexecute, false, 0, true);
                _local1.addEventListener("failed", onInitQueueFail, false, 0, true);
                _local1.execute();
                return;
            };
            if (!queueSongs){
                buildQueueSongsArray();
                return;
            };
            if (!queueSongs.length){
                trace("tried to add empty array to queue");
                dispatchEvent(new Event("failed"));
                return;
            };
            trace((("[AddSongsToQueue] execute: " + queueSongs.length) + " songs total"));
            processTimer = new Timer(50);
            processTimer.addEventListener(TimerEvent.TIMER, processSongs);
            processTimer.start();
        }

    }
}//package com.grooveshark.framework.playback.commands 
﻿package com.grooveshark.framework.playback.commands {
    import flash.events.*;
    import com.grooveshark.framework.playback.*;
    import flash.utils.*;
    import com.grooveshark.framework.*;
    import com.grooveshark.jsonrpc.*;
    import mx.collections.*;
    import mx.utils.*;
    import com.grooveshark.utils.*;

    public class VerifyAutoplay extends QueueCommand {

        private var userInitiated:Boolean;
        private var attempts:int = 0;
        private var playOnSuccess:Boolean = true;
        private var status:Object;

        public function VerifyAutoplay(_arg1:IDualService, _arg2:Queue, _arg3:Boolean=true, _arg4:Object=null){
            super(_arg1, _arg2);
            this.userInitiated = _arg2.gs_queue::autoplayUserInitiated;
            if (((!(_arg2.gs_queue::autoplayStatus)) || (_arg4))){
                _arg2.gs_queue::autoplayStatus = new AutoplayStatus(_arg2, _arg4);
            };
            this.status = _arg2.gs_queue::autoplayStatus.statusForRPC;
            this.playOnSuccess = _arg3;
        }
        private function reexecute(_arg1:Event):void{
            execute();
        }
        private function serviceFault(_arg1:Object, _arg2:Object=null):void{
            var _local4:String;
            var _local3:JSONFault = (_arg1 as JSONFault);
            switch (_local3.code){
                case 0x0800:
                    _local4 = QueueEvent.NO_RECOMMENDATIONS;
                    break;
                case 0x0200:
                    _local4 = QueueEvent.RATE_LIMIT_EXCEEDED;
                    break;
                case -256:
                    _local4 = "tokenFailure";
                    break;
                case 10:
                    _local4 = "maintenanceMode";
                    break;
                default:
                    _local4 = QueueEvent.UNKNOWN_ERROR;
            };
            onFail(_local4, (_local4 == QueueEvent.UNKNOWN_ERROR));
        }
        private function serviceSuccess(_arg1:Object, _arg2:Object=null):void{
            queue.gs_queue::consecutiveFailedAutoplayRequests = 0;
            var _local3:Object = (_arg1 as JSONResult).result;
            if (!_local3){
                onFail(QueueEvent.UNKNOWN_ERROR);
                return;
            };
            var _local4:BaseSong = makeSongFromRaw(_local3);
            var _local5:QueueSong = new QueueSong(_local4, queue, service, {
                type:"radio",
                data:{}
            });
            _local5.source = _local3.source;
            if (queue.currentAutoplayTag){
                _local5.context.data.tagID = queue.currentAutoplayTag.tagID;
            };
            _local5.sponsoredAutoplayID = int(_local3.SponsoredAutoplayID);
            var _local6:String = StringUtils.condenseTitle(_local5.song.songName);
            if (((((queue.gs_queue::autoplayStatus) && (!((queue.gs_queue::autoplayStatus.badTitles.indexOf(_local6) == -1))))) && ((attempts < 3)))){
                this.status.songIDsAlreadySeen.push(_local5.song.songID);
                onFail("Title Match");
                return;
            };
            var _local7:Boolean;
            if (this.playOnSuccess){
                if (queue.activeSong){
                    switch (queue.activeSong.playStatus){
                        case PlayableSong.PLAY_STATUS_NONE:
                        case PlayableSong.PLAY_STATUS_FAILED:
                        case PlayableSong.PLAY_STATUS_COMPLETED:
                            _local7 = true;
                            break;
                    };
                } else {
                    _local7 = true;
                };
            };
            if (!userInitiated){
                _local7 = false;
            };
            if (((((_local7) && (queue.activeSong))) && ((queue.activeSong.playStatus == PlayableSong.PLAY_STATUS_NONE)))){
                queue.addItemsAt([_local5], queue.length, false);
                queue.playSong(queue.activeSong);
            } else {
                queue.addItemsAt([_local5], -1, _local7);
            };
            dispatchEvent(new Event(Event.COMPLETE));
        }
        override public function execute():void{
            if (((!(queue)) || (!(queue.queueID)))){
                onFail(QueueEvent.QUEUE_NOT_READY, false);
                return;
            };
            if (status.seedArtists.length == 0){
                onFail(QueueEvent.NO_SEEDS, false);
                return;
            };
            if ((((queue.gs_queue::consecutiveFailedAutoplayRequests >= 3)) && (((getTimer() - queue.gs_queue::lastFailedAutoplayRequest) < 5000)))){
                onFail(QueueEvent.TOO_MANY_FAILURES, false);
                return;
            };
            var _local1:Object = ObjectUtil.copy(status);
            _local1.songQueueID = queue.queueID;
            _local1.country = service.country;
            if (queue.currentAutoplayTag){
                _local1.tagID = queue.currentAutoplayTag.tagID;
            };
            attempts++;
            service.send(false, "autoplayGetSong", _local1, new ItemResponder(serviceSuccess, serviceFault));
        }
        protected function makeSongFromRaw(_arg1:Object):BaseSong{
            var _local3:Array;
            var _local2:BaseSong = new BaseSong();
            _local2.songID = _arg1.SongID;
            _local2.songName = _arg1.SongName;
            _local2.artistID = _arg1.ArtistID;
            _local2.artistName = _arg1.ArtistName;
            _local2.albumID = _arg1.AlbumID;
            _local2.albumName = _arg1.AlbumName;
            _local2.estimateDuration = (int(_arg1.EstimateDuration) * 1000);
            if (_arg1.CoverArtUrl){
                _local3 = String(_arg1.CoverArtUrl).split("/");
                if (_local3.length){
                    _local2.artFilename = String(_local3[(_local3.length - 1)]).substring(1);
                };
            };
            return (_local2);
        }
        private function onFail(_arg1:String, _arg2:Boolean=true):void{
            var _local3:int;
            var _local4:Timer;
            if (((_arg2) && ((attempts < 3)))){
                Debug.getInstance().print((("[VerifyAutoplay] Failed: " + _arg1) + " Will re-attempt."));
                _local3 = (100 + Math.floor((Math.random() * 400)));
                _local4 = new Timer(_local3, 1);
                _local4.addEventListener(TimerEvent.TIMER_COMPLETE, reexecute, false, 0, true);
                _local4.start();
            } else {
                Debug.getInstance().print((("[VerifyAutoplay] Failed: " + _arg1) + " Giving up."));
                switch (_arg1){
                    case QueueEvent.TOO_MANY_FAILURES:
                        queue.dispatchEvent(new QueueEvent(QueueEvent.AUTOPLAY_FAILED, _arg1, true));
                        queue.setAutoplayEnabled(false, false);
                        break;
                    case "tokenFailure":
                    case "maintenanceMode":
                        queue.gs_queue::consecutiveFailedAutoplayRequests++;
                        queue.gs_queue::lastFailedAutoplayRequest = getTimer();
                        break;
                    default:
                        queue.gs_queue::consecutiveFailedAutoplayRequests++;
                        queue.gs_queue::lastFailedAutoplayRequest = getTimer();
                        queue.dispatchEvent(new QueueEvent(QueueEvent.AUTOPLAY_FAILED, _arg1, userInitiated));
                };
                queue.gs_queue::_autoplayEnabled = false;
                dispatchEvent(new Event("failed"));
            };
        }

    }
}//package com.grooveshark.framework.playback.commands 
﻿package com.grooveshark.framework.playback.commands {
    import flash.events.*;
    import com.grooveshark.framework.playback.*;
    import com.grooveshark.jsonrpc.*;
    import mx.collections.*;
    import com.grooveshark.utils.*;

    public class MarkSongPlayed extends SongCommand {

        public function MarkSongPlayed(_arg1:IDualService, _arg2:PlayableSong){
            super(_arg1, _arg2);
        }
        private function reexecute(_arg1:Event):void{
            execute();
        }
        private function onFail(_arg1:String, _arg2:Boolean=true):void{
            Debug.getInstance().print((("[MarkSongPlayed] Failed: " + _arg1) + " Giving up."));
            dispatchEvent(new Event("failed"));
        }
        override public function execute():void{
            if (((!(song)) || (!(song.lastStreamKey)))){
                onFail("Either no song, or song is missing streamKey.", false);
                return;
            };
            var _local1:Object = {};
            _local1.streamKey = song.lastStreamKey;
            _local1.streamServerID = song.lastServerID;
            _local1.songID = song.song.songID;
            var _local2:Object = song;
            if (_local2.hasOwnProperty("queueSongID")){
                _local1.songQueueSongID = _local2.queueSongID;
            } else {
                _local1.songQueueSongID = 0;
            };
            if (((_local2.hasOwnProperty("parent")) && (_local2.parent.hasOwnProperty("queueID")))){
                _local1.songQueueID = _local2.parent.queueID;
            } else {
                _local1.songQueueID = 0;
            };
            service.send(false, "markSongQueueSongPlayed", _local1, new ItemResponder(serviceSuccess, serviceFault));
        }
        private function serviceFault(_arg1:Object, _arg2:Object=null):void{
            onFail((_arg1 as JSONFault).message, !(((_arg1 as JSONFault).code == -256)));
        }
        private function serviceSuccess(_arg1:Object, _arg2:Object=null):void{
            dispatchEvent(new Event(Event.COMPLETE));
        }

    }
}//package com.grooveshark.framework.playback.commands 
﻿package com.grooveshark.framework.playback.commands {
    import flash.events.*;
    import com.grooveshark.framework.playback.*;
    import flash.utils.*;
    import com.grooveshark.jsonrpc.*;
    import mx.collections.*;
    import com.grooveshark.utils.*;

    public class InitiateQueue extends QueueCommand {

        private var attempts:int = 0;

        public function InitiateQueue(_arg1:IDualService, _arg2:Queue){
            super(_arg1, _arg2);
        }
        private function reexecute(_arg1:TimerEvent):void{
            execute();
        }
        override public function execute():void{
            var _local1:String;
            var _local2:String;
            if (Queue.userTrackingID > 0){
                _local1 = String(Queue.userTrackingID);
                _local1 = (_local1 + int((new Date().valueOf() / 1000)));
                _local2 = Math.floor((Math.random() * 500)).toString();
                while (_local2.length < 3) {
                    _local2 = ("0" + _local2);
                };
                _local1 = (_local1 + _local2);
                queue.queueID = _local1;
                dispatchEvent(new Event(Event.COMPLETE));
            } else {
                attempts++;
                service.send(false, "initiateQueue", null, new ItemResponder(serviceSuccess, serviceFault));
            };
        }
        private function serviceFault(_arg1:Object, _arg2:Object=null):void{
            onFail((_arg1 as JSONFault).message, !(((_arg1 as JSONFault).code == -256)));
        }
        private function serviceSuccess(_arg1:Object, _arg2:Object=null):void{
            var _local3:String = String((_arg1 as JSONResult).result);
            if (_local3){
                queue.queueID = _local3;
                dispatchEvent(new Event(Event.COMPLETE));
            } else {
                onFail("No id returned.");
            };
        }
        private function onFail(_arg1:String, _arg2:Boolean=true):void{
            var _local3:int;
            var _local4:Timer;
            if (((_arg2) && ((attempts < 0)))){
                Debug.getInstance().print((("[InitiateQueue] Failed: " + _arg1) + " Will re-attempt."));
                _local3 = (100 + Math.floor((Math.random() * 400)));
                _local4 = new Timer(_local3, 1);
                _local4.addEventListener(TimerEvent.TIMER_COMPLETE, reexecute, false, 0, true);
                _local4.start();
            } else {
                Debug.getInstance().print((("[InitiateQueue] Failed: " + _arg1) + " Giving up."));
                dispatchEvent(new Event("failed"));
            };
        }

    }
}//package com.grooveshark.framework.playback.commands 
﻿package com.grooveshark.framework.playback.commands {
    import flash.events.*;
    import com.grooveshark.framework.playback.*;
    import com.grooveshark.jsonrpc.*;
    import mx.collections.*;
    import com.grooveshark.utils.*;

    public class MarkSongDownloaded extends SongCommand {

        public function MarkSongDownloaded(_arg1:IDualService, _arg2:PlayableSong){
            super(_arg1, _arg2);
        }
        private function reexecute(_arg1:Event):void{
            execute();
        }
        private function onFail(_arg1:String, _arg2:Boolean=true):void{
            Debug.getInstance().print((("[MarkSongDownloaded] Failed: " + _arg1) + " Giving up."));
            dispatchEvent(new Event("failed"));
        }
        override public function execute():void{
            if (((!(song)) || (!(song.lastStreamKey)))){
                onFail("Either no song, or song is missing streamKey.", false);
                return;
            };
            var _local1:Object = {};
            _local1.streamKey = song.lastStreamKey;
            _local1.streamServerID = song.lastServerID;
            _local1.songID = song.song.songID;
            service.send(false, "markSongDownloadedEx", _local1, new ItemResponder(serviceSuccess, serviceFault));
        }
        private function serviceFault(_arg1:Object, _arg2:Object=null):void{
            onFail((_arg1 as JSONFault).message, !(((_arg1 as JSONFault).code == -256)));
        }
        private function serviceSuccess(_arg1:Object, _arg2:Object=null):void{
            dispatchEvent(new Event(Event.COMPLETE));
        }

    }
}//package com.grooveshark.framework.playback.commands 
﻿package com.grooveshark.framework.playback.commands {
    import flash.events.*;
    import com.grooveshark.framework.playback.*;
    import flash.utils.*;
    import com.grooveshark.jsonrpc.*;
    import mx.collections.*;
    import com.grooveshark.utils.*;

    public class FlagSong extends SongCommand {

        public var flagReason:int;
        private var attempts:int = 0;

        public function FlagSong(_arg1:IDualService, _arg2:PlayableSong){
            super(_arg1, _arg2);
        }
        private function reexecute(_arg1:Event):void{
            execute();
        }
        override public function execute():void{
            if (((!(song)) || (!(song.lastStreamKey)))){
                onFail("Either no song, or song is missing streamKey.", false);
                return;
            };
            var _local1:Object = {};
            _local1.streamKey = song.lastStreamKey;
            _local1.streamServerID = song.lastServerID;
            _local1.songID = song.song.songID;
            _local1.reason = flagReason;
            attempts++;
            service.send(false, "flagSong", _local1, new ItemResponder(serviceSuccess, serviceFault));
        }
        private function serviceFault(_arg1:Object, _arg2:Object=null):void{
            var _local3:int = (_arg1 as JSONFault).code;
            onFail((_arg1 as JSONFault).message, ((((!((_local3 == -256))) && (!((_local3 == 10))))) && (!((_local3 == 0x0400)))));
        }
        private function serviceSuccess(_arg1:Object, _arg2:Object=null):void{
            song.dispatchEvent(new PlayableSongEvent(PlayableSongEvent.SONG_FLAGGED, flagReason));
            dispatchEvent(new Event(Event.COMPLETE));
        }
        private function onFail(_arg1:String, _arg2:Boolean=true):void{
            var _local3:int;
            var _local4:Timer;
            if (((_arg2) && ((attempts < 3)))){
                Debug.getInstance().print((("[FlagSong] Failed: " + _arg1) + " Will re-attempt."));
                _local3 = (100 + Math.floor((Math.random() * 400)));
                _local4 = new Timer(_local3, 1);
                _local4.addEventListener(TimerEvent.TIMER_COMPLETE, reexecute, false, 0, true);
                _local4.start();
            } else {
                Debug.getInstance().print((("[FlagSong] Failed: " + _arg1) + " Giving up."));
                dispatchEvent(new Event("failed"));
            };
        }

    }
}//package com.grooveshark.framework.playback.commands 
﻿package com.grooveshark.framework.playback.commands {
    import flash.events.*;
    import com.grooveshark.framework.playback.*;
    import flash.utils.*;
    import com.grooveshark.jsonrpc.*;
    import mx.collections.*;
    import com.grooveshark.utils.*;

    public class VoteSongForAutoplay extends SongCommand {

        private var attempts:int = 0;
        private var vote:int;

        public function VoteSongForAutoplay(_arg1:IDualService, _arg2:QueueSong, _arg3:int){
            super(_arg1, _arg2);
            this.vote = _arg3;
        }
        private function reexecute(_arg1:Event):void{
            execute();
        }
        private function voteUp(_arg1:Object):void{
            attempts++;
            service.send(false, "autoplayVoteUp", _arg1, new ItemResponder(voteSuccess, serviceFault));
        }
        private function removeUpVote(_arg1:Object):void{
            attempts++;
            service.send(false, "autoplayRemoveVoteUp", _arg1, new ItemResponder(removeSuccess, serviceFault, _arg1));
        }
        private function voteDown(_arg1:Object):void{
            attempts++;
            service.send(false, "autoplayVoteDown", _arg1, new ItemResponder(voteSuccess, serviceFault));
        }
        private function serviceFault(_arg1:Object, _arg2:Object=null):void{
            onFail((_arg1 as JSONFault).message, !(((_arg1 as JSONFault).code == -256)));
        }
        private function removeDownVote(_arg1:Object):void{
            attempts++;
            service.send(false, "autoplayRemoveVoteDown", _arg1, new ItemResponder(removeSuccess, serviceFault, _arg1));
        }
        override public function execute():void{
            if (((!((song as QueueSong).parent)) || (!((song as QueueSong).parent.queueID)))){
                onFail("Queue not initialized.", false);
                return;
            };
            if (((!(song)) || (!((song as QueueSong).queueSongID)))){
                onFail("Either no song, or song is missing queueSongID.", false);
                return;
            };
            var _local1:Object = {};
            _local1.songQueueID = (song as QueueSong).parent.queueID;
            _local1.songQueueSongID = (song as QueueSong).queueSongID;
            if ((song as QueueSong).autoplayVote == QueueSong.AUTOPLAY_VOTE_UP){
                removeUpVote(_local1);
            } else {
                if ((song as QueueSong).autoplayVote == QueueSong.AUTOPLAY_VOTE_DOWN){
                    removeDownVote(_local1);
                } else {
                    if (vote == QueueSong.AUTOPLAY_VOTE_UP){
                        voteUp(_local1);
                    } else {
                        voteDown(_local1);
                    };
                };
            };
        }
        private function voteSuccess(_arg1:Object, _arg2:Object=null):void{
            (song as QueueSong).autoplayVote = vote;
            dispatchEvent(new Event(Event.COMPLETE));
        }
        private function onFail(_arg1:String, _arg2:Boolean=true):void{
            var _local3:int;
            var _local4:Timer;
            if (((_arg2) && ((attempts < 3)))){
                Debug.getInstance().print((("[VoteSongForAutoplay] Failed: " + _arg1) + " Will re-attempt."));
                _local3 = (100 + Math.floor((Math.random() * 400)));
                _local4 = new Timer(_local3, 1);
                _local4.addEventListener(TimerEvent.TIMER_COMPLETE, reexecute, false, 0, true);
                _local4.start();
            } else {
                Debug.getInstance().print((("[VoteSongForAutoplay] Failed: " + _arg1) + " Giving up."));
                song.dispatchEvent(new PlayableSongEvent(PlayableSongEvent.SONG_VOTE_FAILED));
                dispatchEvent(new Event("failed"));
            };
        }
        private function removeSuccess(_arg1:Object, _arg2:Object=null):void{
            (song as QueueSong).autoplayVote = 0;
            attempts = 0;
            if (vote == QueueSong.AUTOPLAY_VOTE_UP){
                voteUp(_arg2);
            } else {
                if (vote == QueueSong.AUTOPLAY_VOTE_DOWN){
                    voteDown(_arg2);
                } else {
                    dispatchEvent(new Event(Event.COMPLETE));
                };
            };
        }

    }
}//package com.grooveshark.framework.playback.commands 
﻿package com.grooveshark.framework.playback.commands {
    import flash.events.*;
    import com.grooveshark.framework.playback.*;
    import com.grooveshark.jsonrpc.*;

    public class RemoveSongsFromQueue extends QueueCommand {

        private var userRemoved:Boolean;
        private var params:Object;
        private var removeWithoutReport:Array;
        private var songs:Array;

        public function RemoveSongsFromQueue(_arg1:IDualService, _arg2:Queue, _arg3:Array, _arg4:Boolean){
            removeWithoutReport = [];
            super(_arg1, _arg2);
            this.songs = _arg3;
            this.userRemoved = _arg4;
        }
        override public function execute():void{
            if (!queue.queueID){
                queue.gs_queue::completeRemoveSongs(songs);
                dispatchEvent(new Event("failed"));
                return;
            };
            if (!params){
                buildParams();
            };
            if (!params.songQueueSongIDs.length){
                if (removeWithoutReport.length){
                    queue.gs_queue::completeRemoveSongs(removeWithoutReport);
                };
                dispatchEvent(new Event(Event.COMPLETE));
                return;
            };
            service.send(false, "removeSongsFromQueue", params);
            queue.gs_queue::completeRemoveSongs(songs);
            dispatchEvent(new Event(Event.COMPLETE));
        }
        private function buildParams():void{
            var _local2:QueueSong;
            var _local1:Array = [];
            for each (_local2 in songs) {
                if (_local2.queueSongID){
                    if (_local2.autoplayVote == QueueSong.AUTOPLAY_VOTE_DOWN){
                        removeWithoutReport.push(_local2);
                    } else {
                        _local1.push(_local2.queueSongID);
                    };
                };
            };
            params = {};
            params.songQueueSongIDs = _local1;
            params.songQueueID = queue.queueID;
            params.userRemoved = userRemoved;
        }

    }
}//package com.grooveshark.framework.playback.commands 
﻿package com.grooveshark.framework.playback.commands {
    import flash.events.*;
    import com.grooveshark.framework.playback.*;
    import com.grooveshark.jsonrpc.*;
    import mx.collections.*;
    import com.grooveshark.utils.*;

    public class MarkSongSkipped extends SongCommand {

        public function MarkSongSkipped(_arg1:IDualService, _arg2:QueueSong){
            super(_arg1, _arg2);
        }
        private function reexecute(_arg1:Event):void{
            execute();
        }
        private function onFail(_arg1:String, _arg2:Boolean=true):void{
            Debug.getInstance().print((("[MarkSongSkipped] Failed: " + _arg1) + " Giving up."));
            dispatchEvent(new Event("failed"));
        }
        override public function execute():void{
            if (((((!((song as QueueSong).parent)) || (!((song as QueueSong).parent.queueID)))) || (!((song as QueueSong).parent.autoplayEnabled)))){
                onFail("Queue not initialized, or autoplay is off.", false);
                return;
            };
            if (((!(song)) || (!((song as QueueSong).queueSongID)))){
                onFail("Either no song, or song is missing queueSongID.", false);
                return;
            };
            var _local1:Object = {};
            _local1.songQueueSongID = (song as QueueSong).queueSongID;
            _local1.songQueueID = (song as QueueSong).parent.queueID;
            service.send(false, "markSongSkipped", _local1, new ItemResponder(serviceSuccess, serviceFault));
        }
        private function serviceFault(_arg1:Object, _arg2:Object=null):void{
            onFail((_arg1 as JSONFault).message, !(((_arg1 as JSONFault).code == -256)));
        }
        private function serviceSuccess(_arg1:Object, _arg2:Object=null):void{
            dispatchEvent(new Event(Event.COMPLETE));
        }

    }
}//package com.grooveshark.framework.playback.commands 
﻿package com.grooveshark.framework.playback.commands {
    import flash.events.*;
    import com.grooveshark.framework.playback.*;
    import flash.utils.*;
    import com.grooveshark.framework.*;
    import com.grooveshark.jsonrpc.*;
    import mx.collections.*;
    import mx.utils.*;
    import com.grooveshark.utils.*;

    public class RefreshPendingAutoplaySong extends QueueCommand {

        private var attempts:int = 0;
        private var playOnAdd:Boolean;
        private var status:Object;
        private var song:QueueSong;

        public function RefreshPendingAutoplaySong(_arg1:IDualService, _arg2:Queue, _arg3:QueueSong, _arg4:Boolean=false){
            super(_arg1, _arg2);
            this.song = _arg3;
            this.playOnAdd = _arg4;
            if (!_arg2.gs_queue::autoplayStatus){
                _arg2.gs_queue::autoplayStatus = new AutoplayStatus(_arg2);
            };
            this.status = _arg2.gs_queue::autoplayStatus.statusForRPC;
        }
        private function reexecute(_arg1:Event):void{
            execute();
        }
        private function serviceFault(_arg1:Object, _arg2:Object=null):void{
            var _local4:String;
            var _local3:JSONFault = (_arg1 as JSONFault);
            switch (_local3.code){
                case 0x0800:
                    _local4 = QueueEvent.NO_RECOMMENDATIONS;
                    queue.setAutoplayEnabled(false, false);
                    break;
                case 0x0200:
                    _local4 = QueueEvent.RATE_LIMIT_EXCEEDED;
                    queue.setAutoplayEnabled(false, false);
                    break;
                case -256:
                    _local4 = "tokenFailure";
                    queue.setAutoplayEnabled(false, false);
                    break;
                case 10:
                    _local4 = "maintenanceMode";
                    queue.setAutoplayEnabled(false, false);
                    break;
                default:
                    _local4 = QueueEvent.UNKNOWN_ERROR;
            };
            onFail(_local4, (_local4 == QueueEvent.UNKNOWN_ERROR));
        }
        override public function execute():void{
            if (((!(queue)) || (!(queue.queueID)))){
                onFail(QueueEvent.QUEUE_NOT_READY, false);
                return;
            };
            if (((!(queue.autoplayEnabled)) || (!(song.eligibleForAutoplayRemoval)))){
                onFail("songNotRequired", false);
                return;
            };
            if (status.seedArtists.length == 0){
                onFail(QueueEvent.NO_SEEDS, false);
                return;
            };
            if ((((queue.gs_queue::consecutiveFailedAutoplayRequests >= 3)) && (((getTimer() - queue.gs_queue::lastFailedAutoplayRequest) < 5000)))){
                onFail(QueueEvent.TOO_MANY_FAILURES, false);
                return;
            };
            var _local1:Object = ObjectUtil.copy(status);
            _local1.songQueueID = queue.queueID;
            _local1.country = service.country;
            if (queue.currentAutoplayTag){
                _local1.tagID = queue.currentAutoplayTag.tagID;
            };
            attempts++;
            service.send(false, "autoplayGetSong", _local1, new ItemResponder(serviceSuccess, serviceFault));
        }
        protected function makeSongFromRaw(_arg1:Object):BaseSong{
            var _local3:Array;
            var _local2:BaseSong = new BaseSong();
            _local2.songID = _arg1.SongID;
            _local2.songName = _arg1.SongName;
            _local2.artistID = _arg1.ArtistID;
            _local2.artistName = _arg1.ArtistName;
            _local2.albumID = _arg1.AlbumID;
            _local2.albumName = _arg1.AlbumName;
            _local2.estimateDuration = (int(_arg1.EstimateDuration) * 1000);
            if (_arg1.CoverArtUrl){
                _local3 = String(_arg1.CoverArtUrl).split("/");
                if (_local3.length){
                    _local2.artFilename = String(_local3[(_local3.length - 1)]).substring(1);
                };
            };
            return (_local2);
        }
        private function serviceSuccess(_arg1:Object, _arg2:Object=null):void{
            queue.gs_queue::consecutiveFailedAutoplayRequests = 0;
            if (((!(song.eligibleForAutoplayRemoval)) || (!(queue.contains(song))))){
                onFail("songNotRequired", false);
                return;
            };
            var _local3:Object = (_arg1 as JSONResult).result;
            if (!_local3){
                onFail(QueueEvent.UNKNOWN_ERROR);
                return;
            };
            var _local4:BaseSong = makeSongFromRaw(_local3);
            var _local5:QueueSong = new QueueSong(_local4, queue, service, {
                type:"radio",
                data:{}
            });
            _local5.source = _local3.source;
            if (queue.currentAutoplayTag){
                _local5.context.data.tagID = queue.currentAutoplayTag.tagID;
            };
            _local5.sponsoredAutoplayID = int(_local3.SponsoredAutoplayID);
            var _local6:String = StringUtils.condenseTitle(_local5.song.songName);
            if (((((queue.gs_queue::autoplayStatus) && (!((queue.gs_queue::autoplayStatus.badTitles.indexOf(_local6) == -1))))) && ((attempts < 3)))){
                this.status.songIDsAlreadySeen.push(_local5.song.songID);
                onFail("Title Match");
                return;
            };
            queue.addItemsAt([_local5], -1, playOnAdd);
            queue.removeItems([song], false);
            dispatchEvent(new Event(Event.COMPLETE));
        }
        private function onFail(_arg1:String, _arg2:Boolean=true):void{
            var _local3:int;
            var _local4:Timer;
            if (((_arg2) && ((attempts < 3)))){
                Debug.getInstance().print((("[RefreshPendingAutoplaySong] Failed: " + _arg1) + " Will re-attempt."));
                _local3 = (100 + Math.floor((Math.random() * 400)));
                _local4 = new Timer(_local3, 1);
                _local4.addEventListener(TimerEvent.TIMER_COMPLETE, reexecute, false, 0, true);
                _local4.start();
            } else {
                switch (_arg1){
                    case "songNotRequired":
                        break;
                    case QueueEvent.TOO_MANY_FAILURES:
                        queue.dispatchEvent(new QueueEvent(QueueEvent.AUTOPLAY_FAILED, _arg1, true));
                        queue.setAutoplayEnabled(false, false);
                        break;
                    case "tokenFailure":
                    case "maintenanceMode":
                        queue.gs_queue::consecutiveFailedAutoplayRequests++;
                        queue.gs_queue::lastFailedAutoplayRequest = getTimer();
                        break;
                    default:
                        queue.gs_queue::consecutiveFailedAutoplayRequests++;
                        queue.gs_queue::lastFailedAutoplayRequest = getTimer();
                        queue.dispatchEvent(new QueueEvent(QueueEvent.AUTOPLAY_FAILED, _arg1, false));
                };
                Debug.getInstance().print((("[RefreshPendingAutoplaySong] Failed: " + _arg1) + " Giving up."));
                dispatchEvent(new Event("failed"));
            };
        }

    }
}//package com.grooveshark.framework.playback.commands 
﻿package com.grooveshark.framework.playback.commands {
    import flash.events.*;
    import com.grooveshark.framework.playback.*;
    import com.grooveshark.jsonrpc.*;

    public class TurnOffAutoplay extends QueueCommand {

        private var userInitiated:Boolean;

        public function TurnOffAutoplay(_arg1:IDualService, _arg2:Queue){
            super(_arg1, _arg2);
            this.userInitiated = _arg2.gs_queue::autoplayUserInitiated;
        }
        override public function execute():void{
            var _local2:QueueSong;
            queue.gs_queue::autoplayStatus = null;
            queue.currentAutoplayTag = null;
            if (userInitiated){
                queue.autoAutoplayDisabled = true;
            };
            var _local1:Array = [];
            for each (_local2 in queue) {
                if (_local2.eligibleForAutoplayRemoval){
                    _local1.push(_local2);
                };
            };
            if (_local1.length){
                queue.removeItems(_local1, false);
            };
            dispatchEvent(new Event(Event.COMPLETE));
        }

    }
}//package com.grooveshark.framework.playback.commands 
﻿package com.grooveshark.framework.playback.commands {
    import flash.events.*;
    import com.grooveshark.framework.playback.*;
    import com.grooveshark.jsonrpc.*;
    import mx.collections.*;
    import com.grooveshark.utils.*;

    public class MarkSongComplete extends SongCommand {

        public function MarkSongComplete(_arg1:IDualService, _arg2:PlayableSong){
            super(_arg1, _arg2);
        }
        private function reexecute(_arg1:Event):void{
            execute();
        }
        private function onFail(_arg1:String, _arg2:Boolean=true):void{
            Debug.getInstance().print((("[MarkSongComplete] Failed: " + _arg1) + " Giving up."));
            dispatchEvent(new Event("failed"));
        }
        override public function execute():void{
            if (((!(song)) || (!(song.lastStreamKey)))){
                onFail("Either no song, or song is missing streamKey.", false);
                return;
            };
            var _local1:Object = {};
            _local1.streamKey = song.lastStreamKey;
            _local1.streamServerID = song.lastServerID;
            _local1.songID = song.song.songID;
            _local1.song = {};
            _local1.song.songID = song.song.songID;
            _local1.song.songName = song.song.songName;
            _local1.song.artistID = song.song.artistID;
            _local1.song.artistName = song.song.artistName;
            _local1.song.albumID = song.song.albumID;
            _local1.song.albumName = song.song.albumName;
            _local1.song.token = ((song.song.hasOwnProperty("token")) ? song.song["token"] : "");
            _local1.song.artFilename = (((song.song.artFilename.indexOf("default") == -1)) ? song.song.artFilename : "");
            var _local2:Object = song;
            if (_local2.hasOwnProperty("context")){
                _local1.context = {
                    type:_local2.context.type,
                    data:_local2.context.data
                };
            };
            if (PlayableSong.userForReporting){
                _local1.user = PlayableSong.userForReporting;
            };
            service.send(false, "markSongComplete", _local1, new ItemResponder(serviceSuccess, serviceFault));
        }
        private function serviceFault(_arg1:Object, _arg2:Object=null):void{
            onFail((_arg1 as JSONFault).message, !(((_arg1 as JSONFault).code == -256)));
        }
        private function serviceSuccess(_arg1:Object, _arg2:Object=null):void{
            dispatchEvent(new Event(Event.COMPLETE));
        }

    }
}//package com.grooveshark.framework.playback.commands 
﻿package com.grooveshark.framework.playback.commands {
    import flash.events.*;
    import com.grooveshark.framework.playback.*;
    import flash.utils.*;
    import com.grooveshark.jsonrpc.*;
    import mx.collections.*;
    import com.grooveshark.utils.*;

    public class GetArtistsForTagAutoplay extends QueueCommand {

        private var userInitiated:Boolean;
        private var attempts:int = 0;
        private var tag:Tag;

        public function GetArtistsForTagAutoplay(_arg1:IDualService, _arg2:Queue, _arg3:Tag, _arg4:Boolean){
            super(_arg1, _arg2);
            this.tag = _arg3;
            this.userInitiated = _arg4;
        }
        private function reexecute(_arg1:TimerEvent):void{
            execute();
        }
        private function serviceFault(_arg1:Object, _arg2:Object=null):void{
            onFail((_arg1 as JSONFault).message, !(((_arg1 as JSONFault).code == -256)));
        }
        private function serviceSuccess(_arg1:Object, _arg2:Object=null):void{
            var _local4:Array;
            var _local5:Object;
            var _local6:int;
            var _local3:Array = ((_arg1 as JSONResult).result as Array);
            if (((_local3) && (_local3.length))){
                _local4 = [];
                for each (_local5 in _local3) {
                    _local6 = int(_local5.ArtistID);
                    if (_local6){
                        _local4.push(_local6);
                    };
                };
                if (!queue.gs_queue::autoplayStatus){
                    queue.gs_queue::autoplayStatus = new AutoplayStatus(queue);
                };
                queue.gs_queue::autoplayStatus.addTagArtistSeeds(_local4);
                queue.currentAutoplayTag = tag;
                if (queue.autoplayEnabled){
                    queue.resetPendingAutoplaySuggestion(true);
                } else {
                    queue.setAutoplayEnabled(true, userInitiated);
                };
                dispatchEvent(new Event(Event.COMPLETE));
            } else {
                onFail("No artists returned.");
            };
        }
        override public function execute():void{
            if (((!(tag)) || (!(tag.tagID)))){
                onFail("No tagID provided.", false);
                return;
            };
            attempts++;
            service.send(false, "getArtistsForTagRadio", {tagID:tag.tagID}, new ItemResponder(serviceSuccess, serviceFault));
        }
        private function onFail(_arg1:String, _arg2:Boolean=true):void{
            var _local3:int;
            var _local4:Timer;
            if (((_arg2) && ((attempts < 3)))){
                Debug.getInstance().print((("[GetArtistsForTagAutoplay] Failed: " + _arg1) + " Will re-attempt."));
                _local3 = (100 + Math.floor((Math.random() * 400)));
                _local4 = new Timer(_local3, 1);
                _local4.addEventListener(TimerEvent.TIMER_COMPLETE, reexecute, false, 0, true);
                _local4.start();
            } else {
                Debug.getInstance().print((("[GetArtistsForTagAutoplay] Failed: " + _arg1) + " Giving up."));
                dispatchEvent(new Event("failed"));
            };
        }

    }
}//package com.grooveshark.framework.playback.commands 
﻿package com.grooveshark.framework.playback {
    import flash.events.*;

    public final class PlayableSongEvent extends Event {

        public static const COMPLETE:String = "complete";
        public static const FAILED_TOO_MANY_STREAMKEY_FAILS:int = 3;
        public static const SONG_VOTE_FAILED:String = "songVoteFailed";
        public static const FAILED_MUST_PROVIDE_STREAMKEY:int = 11;
        public static const COMPLETE_SOUND_COMPLETE:int = 7;
        public static const FAILED_IO_ERROR:int = 1;
        public static const FAILED_TOO_MANY_BAD_FRAMES:int = 5;
        public static const PLAYBACK_BEGUN:String = "playbackBegun";
        public static const SONG_FLAGGED:String = "songFlagged";
        public static const FAILED_UNKNOWN_SERVER_ERROR:int = 6;
        public static const ERROR:String = "error";
        public static const FAILED_STREAMKEY_OTHER:int = 4;
        public static const SONG_VOTED:String = "songVoted";
        public static const FAILED_STREAMKEY_LIMIT:int = 2;
        public static const WARNING_FREQUENT_BUFFERING:int = 10;
        public static const COMPLETE_VBR_COMPLETE:int = 8;
        public static const COMPLETE_FORCE_FROWN_SKIP:int = 9;

        public static var lastError:Array;

        public var code:int;
        public var preErrorStatus:int;

        public function PlayableSongEvent(_arg1:String, _arg2:int=0, _arg3:int=-1, _arg4:Boolean=false, _arg5:Boolean=false){
            super(_arg1, _arg4, _arg5);
            this.code = _arg2;
            this.preErrorStatus = _arg3;
            if (_arg1 == ERROR){
                if (!lastError){
                    lastError = [];
                };
                lastError.push((((((("SongEvent { " + _arg1) + ": finalCode:") + String(_arg2)) + " resultCode:") + String(_arg3)) + " }"));
                if (lastError.length > 5){
                    lastError.shift();
                };
            };
        }
        override public function clone():Event{
            return (new PlayableSongEvent(this.type, this.code, this.preErrorStatus, this.bubbles, this.cancelable));
        }

    }
}//package com.grooveshark.framework.playback 
﻿package com.grooveshark.framework.playback {
    import flash.events.*;
    import mx.events.*;
    import flash.utils.*;
    import com.grooveshark.framework.*;
    import com.grooveshark.jsonrpc.*;
    import mx.collections.*;
    import com.grooveshark.framework.playback.commands.*;

    public class Queue extends ListCollectionView {

        public static const INDEX_LAST:int = -3;
        public static const INDEX_DEFAULT:int = -1;
        public static const REPEAT_NONE:int = 0;
        public static const REPEAT_ALL:int = 1;
        public static const INDEX_NEXT:int = -2;
        public static const REPEAT_ONE:int = 2;
        public static const CROSSFADE_STEPS:int = 6;
        gs_queue static const INDEX_RELATIVE:int = -4;

        private static var _staticBindingEventDispatcher:EventDispatcher = new EventDispatcher();
        private static var _1923488829userTrackingID:Number = 0;
        protected static var streamKeys:Object = {};
        private static var _200723786prefetchEnabled:Boolean = true;

        private var _1796994653lastPlaylistID:int;
        private var _1117335380previousSong:QueueSong;
        private var _37396582hasPreviousSong:Boolean = false;
        gs_queue var chunkSize:int = 100;
        gs_queue var source:Array;
        gs_queue var queueSongLookupBySongID:Object;
        gs_queue var pendingAdds:int = 0;
        gs_queue var maxChunks:int = 10;
        protected var _shuffleEnabled:Boolean = false;
        gs_queue var autoplayStatus:AutoplayStatus = null;
        protected var _crossfadeEnabled:Boolean = false;
        private var __activeSong:QueueSong;
        private var _repeatMode:int = 0;
        protected var __autoplayEnabled:Boolean = false;
        gs_queue var commandQueue:CommandQueue;
        gs_queue var queueSongLookupByQueueSongID:Object;
        private var _crossfadeSongStopTimer:Timer;
        private var _655172076queueID:String;
        protected var _currentAutoplayTag:Tag;
        gs_queue var pendingSongs:Array;
        protected var service:IDualService;
        gs_queue var lastFailedAutoplayRequest:int;
        private var crossfadeNewAmount:int;
        gs_queue var autoplayUserInitiated:Boolean = false;
        private var _3866466hasNextSong:Boolean = false;
        private var _crossfadeRunning:Boolean = false;
        protected var prefetchedSongs:Array;
        private var _1424376488nextSong:QueueSong;
        private var crossfadeAmountChanged:Boolean = false;
        gs_queue var playedSongs:Array;
        gs_queue var consecutiveFailedAutoplayRequests:int;
        private var _crossfadeSong:QueueSong;
        protected var _crossfadeInOutEnabled:Boolean = false;
        gs_queue var songCount:int = 1;
        private var _crossfadeAmount:int = 5000;

        public function Queue(_arg1:IDualService, _arg2:Boolean=false, _arg3:Boolean=true){
            var _local5:InitiateQueue;
            gs_queue::source = [];
            gs_queue::playedSongs = [];
            gs_queue::pendingSongs = [];
            prefetchedSongs = [];
            gs_queue::queueSongLookupBySongID = {};
            gs_queue::queueSongLookupByQueueSongID = {};
            gs_queue::commandQueue = new CommandQueue();
            super();
            this.service = _arg1;
            this.autoAutoplayDisabled = _arg2;
            if (_arg3){
                _local5 = new InitiateQueue(_arg1, this);
                this.gs_queue::commandQueue.queueCommand(_local5);
            };
            var _local4:Number = (this.crossfadeAmount as Number);
            this.crossfadeSongStopTimer = new Timer(((1 / CROSSFADE_STEPS) * 1000), ((CROSSFADE_STEPS * _local4) / 1000));
        }
        public static function set userTrackingID(_arg1:Number):void{
            var _local3:IEventDispatcher;
            var _local2:Object = Queue._1923488829userTrackingID;
            if (_local2 !== _arg1){
                Queue._1923488829userTrackingID = _arg1;
                _local3 = Queue.staticEventDispatcher;
                if (_local3 != null){
                    _local3.dispatchEvent(PropertyChangeEvent.createUpdateEvent(Queue, "userTrackingID", _local2, _arg1));
                };
            };
        }
        public static function get prefetchEnabled():Boolean{
            return (Queue._200723786prefetchEnabled);
        }
        private static function onPrefetchComplete(_arg1:Event):void{
            var _local2:String;
            var _local4:PrefetchStreamKeys;
            var _local3:Number = new Date().valueOf();
            for (_local2 in Queue.streamKeys) {
                if (Queue.streamKeys[_local2].expires <= _local3){
                    delete Queue.streamKeys[_local2];
                };
            };
            _local4 = (_arg1.currentTarget as PrefetchStreamKeys);
            if (((_local4) && (_local4.results))){
                for (_local2 in _local4.results) {
                    Queue.streamKeys[_local2] = _local4.results[_local2];
                };
            };
        }
        public static function get staticEventDispatcher():IEventDispatcher{
            return (_staticBindingEventDispatcher);
        }
        public static function set prefetchEnabled(_arg1:Boolean):void{
            var _local3:IEventDispatcher;
            var _local2:Object = Queue._200723786prefetchEnabled;
            if (_local2 !== _arg1){
                Queue._200723786prefetchEnabled = _arg1;
                _local3 = Queue.staticEventDispatcher;
                if (_local3 != null){
                    _local3.dispatchEvent(PropertyChangeEvent.createUpdateEvent(Queue, "prefetchEnabled", _local2, _arg1));
                };
            };
        }
        public static function cacheStreamKeys(_arg1:Array, _arg2:IDualService):void{
            var _local3:PrefetchStreamKeys = new PrefetchStreamKeys(_arg2, _arg1);
            _local3.addEventListener(Event.COMPLETE, onPrefetchComplete);
            _local3.execute();
        }
        public static function get userTrackingID():Number{
            return (Queue._1923488829userTrackingID);
        }

        protected function generateTurnOffAutoplay():void{
            var _local1:QueueCommand = new TurnOffAutoplay(service, this);
            this.gs_queue::commandQueue.queueCommand(_local1);
        }
        public function stop():void{
            if (gs_queue::_activeSong){
                gs_queue::_activeSong.stop();
            };
            if (((_crossfadeSong) && ((_crossfadeSong.playStatus === PlayableSong.PLAY_STATUS_PLAYING)))){
                crossfadeSongStop();
            };
        }
        private function set _1799419675crossfadeEnabled(_arg1:Boolean):void{
            var _local2:Boolean;
            if (_arg1 != _crossfadeEnabled){
                _local2 = _crossfadeEnabled;
                _crossfadeEnabled = _arg1;
                dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "crossfadeEnabled", _local2, _arg1));
            };
        }
        public function set currentIndex(_arg1:int):void{
            var _local2:Object = this.currentIndex;
            if (_local2 !== _arg1){
                this._1448410841currentIndex = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "currentIndex", _local2, _arg1));
            };
        }
        public function get shuffleEnabled():Boolean{
            return (_shuffleEnabled);
        }
        protected function get adjustedActiveSongIndex():int{
            var _local1:int;
            if (!gs_queue::_activeSong){
                return (-1);
            };
            if (_shuffleEnabled){
                _local1 = gs_queue::playedSongs.indexOf(gs_queue::_activeSong);
                return (((_local1)!=-1) ? _local1 : 0);
            };
            return (gs_queue::source.indexOf(gs_queue::_activeSong));
        }
        private function properlyOrderSongs(_arg1:Array):Array{
            var _local3:QueueSong;
            var _local2:Array = [];
            for each (_local3 in this) {
                if (_arg1.indexOf(_local3) != -1){
                    _local2.push(_local3);
                };
            };
            return (_local2);
        }
        gs_queue function completeAddSongsAt(_arg1:Array, _arg2:int, _arg3:Boolean, _arg4:Boolean, _arg5:QueueSong=null):void{
            var _local9:QueueSong;
            var _local10:String;
            var _local11:int;
            var _local12:int;
            var _local13:QueueSong;
            var _local14:Array;
            var _local15:PropertyChangeEvent;
            var _local16:int;
            var _local17:QueueSong;
            if (!_arg1.length){
                return;
            };
            var _local6:Boolean;
            if (((_shuffleEnabled) && ((this.length == 0)))){
                _local6 = true;
            };
            var _local7 = ((_arg1[0] as QueueSong).source == "user");
            if (_arg2 >= 0){
                _local10 = "index";
            } else {
                if (((((((_local7) && ((_arg2 == Queue.gs_queue::INDEX_RELATIVE)))) && (_arg5))) && (this.contains(_arg5)))){
                    _local10 = "relative";
                } else {
                    if (((((_local7) && (gs_queue::_activeSong))) && ((((_arg2 == Queue.INDEX_NEXT)) || ((((_arg2 == Queue.INDEX_DEFAULT)) && (_arg3))))))){
                        _local10 = "next";
                    } else {
                        _local10 = "last";
                    };
                };
            };
            switch (_local10){
                case "index":
                    _local11 = _arg2;
                    break;
                case "relative":
                    _local11 = (gs_queue::source.indexOf(_arg5) + 1);
                    break;
                case "next":
                    if ((((gs_queue::_activeSong.playStatus == PlayableSong.PLAY_STATUS_NONE)) && (!(gs_queue::_activeSong.lastStreamKey)))){
                        _local11 = gs_queue::source.indexOf(gs_queue::_activeSong);
                    } else {
                        _local11 = (gs_queue::source.indexOf(gs_queue::_activeSong) + 1);
                    };
                    break;
                case "last":
                default:
                    if (_local7){
                        _local11 = this.lengthAdjustedForAutoplay;
                    } else {
                        _local11 = this.length;
                    };
            };
            gs_queue::source = insertItemsAtIndex(gs_queue::source, _arg1, _local11);
            if (_shuffleEnabled){
                if (_local6){
                    setupShuffle(true);
                } else {
                    _local12 = -1;
                    if (_local10 == "relative"){
                        _local12 = gs_queue::playedSongs.indexOf(_arg5);
                    } else {
                        if (_local10 == "next"){
                            _local12 = adjustedActiveSongIndex;
                        };
                    };
                    if (_local12 == -1){
                        for each (_local13 in _arg1) {
                            gs_queue::pendingSongs.push(_local13);
                        };
                    } else {
                        gs_queue::playedSongs = insertItemsAtIndex(gs_queue::playedSongs, randomizeArray(_arg1), (_local12 + 1));
                    };
                };
            };
            var _local8:CollectionEvent = new CollectionEvent(CollectionEvent.COLLECTION_CHANGE);
            _local8.kind = CollectionEventKind.ADD;
            _local8.location = _local11;
            _local8.items = _arg1;
            this.dispatchEvent(_local8);
            for each (_local9 in _arg1) {
                _local9.addEventListener(PlayableSongEvent.SONG_FLAGGED, onSongFlagged);
                _local9.addEventListener(PlayableSongEvent.SONG_VOTE_FAILED, onSongVoteFailed);
                _local14 = gs_queue::queueSongLookupBySongID[_local9.song.songID];
                if (_local14){
                    _local14.push(_local9);
                } else {
                    gs_queue::queueSongLookupBySongID[_local9.song.songID] = [_local9];
                };
                gs_queue::queueSongLookupByQueueSongID[_local9.queueSongID] = _local9;
                _local15 = new PropertyChangeEvent(PropertyChangeEvent.PROPERTY_CHANGE);
                _local15.property = _local11;
                _local15.newValue = _local9;
                this.dispatchEvent(_local15);
                _local11++;
            };
            if (_arg3){
                if (((_shuffleEnabled) && ((_arg1.length > 1)))){
                    _local16 = Math.floor((Math.random() * _arg1.length));
                    this.playSong(_arg1[_local16], false, this.crossfadeEnabled);
                } else {
                    this.playSong(_arg1[0], false, this.crossfadeEnabled);
                };
            } else {
                if (!gs_queue::_activeSong){
                    gs_queue::_activeSong = _arg1[0];
                };
            };
            recalcHasNextPrev();
            if (gs_queue::autoplayStatus){
                gs_queue::autoplayStatus.songsAddedToQueue(_arg1);
            };
            if (((this.autoplayEnabled) && (((_arg1[0] as QueueSong).source == "user")))){
                _local17 = (gs_queue::source[(gs_queue::source.length - 1)] as QueueSong);
                if (((_local17) && (_local17.eligibleForAutoplayRemoval))){
                    generateRefreshPendingAutoplaySong(_local17);
                };
            } else {
                if (((!(autoAutoplayDisabled)) || (_arg4))){
                    setAutoplayEnabled(true, _arg4);
                };
            };
        }
        public function set queueID(_arg1:String):void{
            var _local2:Object = this._655172076queueID;
            if (_local2 !== _arg1){
                this._655172076queueID = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "queueID", _local2, _arg1));
            };
        }
        public function set shuffleEnabled(_arg1:Boolean):void{
            var _local2:Object = this.shuffleEnabled;
            if (_local2 !== _arg1){
                this._342671880shuffleEnabled = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "shuffleEnabled", _local2, _arg1));
            };
        }
        public function playPreviousSong(_arg1:Boolean=false):void{
            var _local2:int = (((this.crossfadeAmount < 5)) ? 5 : this.crossfadeAmount);
            if (((((!(_arg1)) && (gs_queue::_activeSong))) && ((gs_queue::_activeSong.position > _local2)))){
                playSong(gs_queue::_activeSong, true, false);
                return;
            };
            if (((crossfadeSongStopTimer) && (crossfadeSongStopTimer.running))){
                stopCrossfade();
                crossfadeSongStop();
                gs_queue::_activeSong.soundVolume = Number(1);
            };
            var _local3:QueueSong = determinePreviousSong();
            if (_local3){
                playSong(_local3, true);
            };
        }
        private function set _2043934011activeSong(_arg1:QueueSong):void{
        }
        public function playNextSong():void{
            var _local2:*;
            if (((this.gs_queue::_activeSong) && (this.autoplayEnabled))){
                switch (this.gs_queue::_activeSong.playStatus){
                    case PlayableSong.PLAY_STATUS_INITIALIZING:
                    case PlayableSong.PLAY_STATUS_LOADING:
                    case PlayableSong.PLAY_STATUS_BUFFERING:
                    case PlayableSong.PLAY_STATUS_PLAYING:
                        _local2 = new MarkSongSkipped(service, this.gs_queue::_activeSong);
                        this.gs_queue::commandQueue.queueCommand(_local2);
                };
            };
            var _local1:QueueSong = determineNextSong();
            if (((crossfadeSongStopTimer) && (crossfadeSongStopTimer.running))){
                stopCrossfade();
                crossfadeSongStop();
                gs_queue::_activeSong.soundVolume = Number(1);
            };
            if (_local1){
                playSong(_local1, true);
            } else {
                if (this.autoplayEnabled){
                    generateGetAutoplaySong();
                };
            };
        }
        gs_queue function get _autoplayEnabled():Boolean{
            return (__autoplayEnabled);
        }
        override public function contains(_arg1:Object):Boolean{
            return (!((gs_queue::source.indexOf(_arg1) == -1)));
        }
        protected function generateRemoveSongsFromQueue(_arg1:Array, _arg2:Boolean):void{
            var _local3:RemoveSongsFromQueue = new RemoveSongsFromQueue(service, this, _arg1, _arg2);
            this.gs_queue::commandQueue.queueCommand(_local3);
        }
        public function resume():void{
            if (gs_queue::_activeSong){
                gs_queue::_activeSong.resume();
            };
        }
        public function resetPendingAutoplaySuggestion(_arg1:Boolean=false):void{
            generateRefreshPendingAutoplaySong(QueueSong(gs_queue::source[(gs_queue::source.length - 1)]), _arg1);
        }
        public function seekInCurrentSong(_arg1:int):void{
            if (gs_queue::_activeSong){
                gs_queue::_activeSong.seekTo(_arg1);
            };
        }
        public function addItemsAt(_arg1:Array, _arg2:int=-1, _arg3:Boolean=false, _arg4:Boolean=false, _arg5:Object=null):void{
            var _local6:Array = _arg1.splice(0, (gs_queue::chunkSize * gs_queue::maxChunks));
            generateAddSongsToQueue(_local6, _arg2, _arg3, _arg4, _arg5);
            if (_arg1.length){
                this.dispatchEvent(new QueueEvent(QueueEvent.ERROR_ADDING_SONGS, QueueEvent.TOO_MANY_SONGS, false, {songs:_arg1}));
            };
        }
        public function get crossfadeAmount():int{
            return (_crossfadeAmount);
        }
        protected function get lengthAdjustedForAutoplay():int{
            var _local2:QueueSong;
            if (!gs_queue::_autoplayEnabled){
                return (this.length);
            };
            var _local1:int;
            for each (_local2 in this) {
                if (!_local2.eligibleForAutoplayRemoval){
                    _local1++;
                };
            };
            return (_local1);
        }
        private function checkForNeededAutoplay():void{
            if (!this.autoplayEnabled){
                return;
            };
            if (!this.hasNextSong){
                generateGetAutoplaySong();
            };
        }
        public function get activeSong():QueueSong{
            return (__activeSong);
        }
        protected function onSongFlagged(_arg1:PlayableSongEvent):void{
            var _local2:QueueSong = (_arg1.currentTarget as QueueSong);
            if (_local2){
                if ((((_arg1.code < 4)) && (this.contains(_local2)))){
                    this.removeItem(_local2);
                };
                dispatchEvent(new QueueEvent(QueueEvent.SONG_FLAGGED, "", true, {song:_local2}));
                if (this.gs_queue::autoplayStatus){
                    this.gs_queue::autoplayStatus.songFlagged(_local2);
                };
            };
        }
        protected function randomizeArray(_arg1:Array):Array{
            var _local4:int;
            var _local5:Object;
            var _local2:Array = _arg1.concat();
            var _local3:Array = [];
            while (_local2.length) {
                _local4 = Math.floor((Math.random() * _local2.length));
                _local5 = _local2.splice(_local4, 1)[0];
                _local3.push(_local5);
            };
            return (_local3);
        }
        protected function onSongComplete(_arg1:PlayableSongEvent):void{
            var _local2:QueueSong = (_arg1.currentTarget as QueueSong);
            if (this.repeatMode == Queue.REPEAT_ONE){
                playSong(_local2);
            } else {
                if (_local2 === _crossfadeSong){
                    this.removeEventListeners(this._crossfadeSong);
                    _crossfadeSong = null;
                } else {
                    if (this.hasNextSong){
                        if (((((this.crossfadeEnabled) && ((_arg1.code == PlayableSongEvent.COMPLETE_FORCE_FROWN_SKIP)))) && ((_local2.playStatus == PlayableSong.PLAY_STATUS_COMPLETED)))){
                            this.crossfadeSong = _local2;
                        };
                        playNextSong();
                    };
                };
            };
        }
        private function set _1448410841currentIndex(_arg1:int):void{
        }
        protected function set crossfadeSong(_arg1:QueueSong):void{
            var _local2:Object = this.crossfadeSong;
            if (_local2 !== _arg1){
                this._1342440975crossfadeSong = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "crossfadeSong", _local2, _arg1));
            };
        }
        public function set lastPlaylistID(_arg1:int):void{
            var _local2:Object = this._1796994653lastPlaylistID;
            if (_local2 !== _arg1){
                this._1796994653lastPlaylistID = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "lastPlaylistID", _local2, _arg1));
            };
        }
        public function moveItemsTo(_arg1:Array, _arg2:int):void{
            var _local4:QueueSong;
            var _local5:int;
            var _local6:Array;
            var _local7:CollectionEvent;
            _arg1 = properlyOrderSongs(_arg1);
            var _local3:int = _arg2;
            for each (_local4 in _arg1) {
                _local5 = gs_queue::source.indexOf(_local4);
                if (((!((_local5 == -1))) && (!((_local5 == _arg2))))){
                    _local6 = gs_queue::source.slice(0, _arg2).concat(_local4).concat(gs_queue::source.slice(_arg2));
                    if (_local5 < _arg2){
                        _local6.splice(_local6.indexOf(_local4), 1);
                    } else {
                        _local6.splice(_local6.lastIndexOf(_local4), 1);
                    };
                    gs_queue::source = _local6;
                    _local7 = new CollectionEvent(CollectionEvent.COLLECTION_CHANGE);
                    _local7.kind = CollectionEventKind.MOVE;
                    _local7.location = gs_queue::source.indexOf(_local4);
                    _local7.oldLocation = _local5;
                    this.dispatchEvent(_local7);
                };
            };
            recalcHasNextPrev();
        }
        public function setActiveSong(_arg1:QueueSong):Boolean{
            if (!this.contains(_arg1)){
                return (false);
            };
            this.stop();
            this.gs_queue::_activeSong = _arg1;
            return (true);
        }
        gs_queue function set _autoplayEnabled(_arg1:Boolean):void{
            var _local2:Object = this.gs_queue::_autoplayEnabled;
            if (_local2 !== _arg1){
                this.gs_queue::_491406817_autoplayEnabled = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "gs_queue::_autoplayEnabled", _local2, _arg1));
            };
        }
        public function set nextSong(_arg1:QueueSong):void{
            var _local2:Object = this._1424376488nextSong;
            if (_local2 !== _arg1){
                this._1424376488nextSong = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "nextSong", _local2, _arg1));
            };
        }
        override public function removeItemAt(_arg1:int):Object{
            return (null);
        }
        protected function recalcHasNextPrev():void{
            if (!this.length){
                this.hasNextSong = (this.hasPreviousSong = false);
                return;
            };
            var _local1:int = this.adjustedActiveSongIndex;
            this.hasPreviousSong = (((repeatMode == Queue.REPEAT_ALL)) || ((_local1 >= 1)));
            this.hasNextSong = (((repeatMode == Queue.REPEAT_ALL)) || (((!((_local1 == -1))) && ((_local1 < (this.length - 1))))));
            determinePreviousSong();
            determineNextSong();
            checkForNeededAutoplay();
        }
        protected function generateGetAutoplaySong():void{
            var _local1:GetAutoplaySong = new GetAutoplaySong(service, this);
            this.gs_queue::commandQueue.queueCommand(_local1);
        }
        public function startTagAutoplay(_arg1:Tag, _arg2:Boolean):void{
            stopTagAutoplay();
            var _local3:QueueCommand = new GetArtistsForTagAutoplay(service, this, _arg1, _arg2);
            this.gs_queue::commandQueue.queueCommand(_local3);
        }
        public function get autoplayEnabled():Boolean{
            return (__autoplayEnabled);
        }
        public function set previousSong(_arg1:QueueSong):void{
            var _local2:Object = this._1117335380previousSong;
            if (_local2 !== _arg1){
                this._1117335380previousSong = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "previousSong", _local2, _arg1));
            };
        }
        function determineNextSong():QueueSong{
            var _local3:Number;
            var _local4:int;
            var _local1:QueueSong;
            var _local2:int = this.adjustedActiveSongIndex;
            if (_local2 >= (this.length - 1)){
                if (this.repeatMode == Queue.REPEAT_ALL){
                    if (_shuffleEnabled){
                        _local1 = gs_queue::playedSongs[0];
                    } else {
                        _local1 = gs_queue::source[0];
                    };
                };
            } else {
                if (_shuffleEnabled){
                    if (_local2 < (gs_queue::playedSongs.length - 1)){
                        _local1 = gs_queue::playedSongs[(_local2 + 1)];
                    } else {
                        _local3 = Math.random();
                        _local4 = Math.floor((_local3 * gs_queue::pendingSongs.length));
                        _local1 = gs_queue::pendingSongs.splice(_local4, 1)[0];
                        gs_queue::playedSongs.push(_local1);
                    };
                } else {
                    _local1 = gs_queue::source[(_local2 + 1)];
                };
            };
            this.nextSong = _local1;
            return (_local1);
        }
        protected function get crossfadeRunning():Boolean{
            return (_crossfadeRunning);
        }
        public function set repeatMode(_arg1:int):void{
            var _local2:Object = this.repeatMode;
            if (_local2 !== _arg1){
                this._1159370206repeatMode = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "repeatMode", _local2, _arg1));
            };
        }
        public function get hasPreviousSong():Boolean{
            return (this._37396582hasPreviousSong);
        }
        public function set crossfadeAmount(_arg1:int):void{
            var _local2:Object = this.crossfadeAmount;
            if (_local2 !== _arg1){
                this._2112713164crossfadeAmount = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "crossfadeAmount", _local2, _arg1));
            };
        }
        protected function removeEventListeners(_arg1:QueueSong):void{
            _arg1.removeEventListener(PropertyChangeEvent.PROPERTY_CHANGE, onSongPropChange);
            _arg1.removeEventListener(PlayableSongEvent.COMPLETE, onSongComplete);
            _arg1.removeEventListener(PlayableSongEvent.ERROR, onSongError);
            _arg1.removeEventListener(PlayableSongEvent.PLAYBACK_BEGUN, onSongPlayback);
        }
        public function crossfadeSongVolume(_arg1:TimerEvent=null):void{
            var _local2:Number;
            var _local3:Number;
            if (_crossfadeSong){
                _local2 = (1 / ((CROSSFADE_STEPS * crossfadeAmount) / 1000));
                _crossfadeSong.soundVolume = (((_crossfadeSong.soundVolume >= _local2)) ? (_crossfadeSong.soundVolume - _local2) : 0);
            };
            if (gs_queue::_activeSong){
                _local3 = (1 / (((CROSSFADE_STEPS * crossfadeAmount) * 0.8) / 1000));
                gs_queue::_activeSong.soundVolume = (((gs_queue::_activeSong.soundVolume <= (1 - _local3))) ? (gs_queue::_activeSong.soundVolume + _local3) : 1);
            };
        }
        override public function addItem(_arg1:Object):void{
        }
        public function addItemsFromPlaylistAt(_arg1:BasePlaylist, _arg2:int=-1, _arg3:Boolean=false):void{
            var _local4:QueueCommand = new AddSongsFromPlaylist(service, this, _arg1, _arg2, _arg3);
            this.gs_queue::commandQueue.queueCommand(_local4);
        }
        public function set currentAutoplayTag(_arg1:Tag):void{
            var _local2:Object = this.currentAutoplayTag;
            if (_local2 !== _arg1){
                this._35740674currentAutoplayTag = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "currentAutoplayTag", _local2, _arg1));
            };
        }
        public function playSong(_arg1:Object=null, _arg2:Boolean=false, _arg3:Boolean=true):void{
            var _local7:int;
            var _local8:Array;
            var _local9:QueueSong;
            var _local10:int;
            var _local11:int;
            var _local12:int;
            var _local4:Boolean;
            var _local5:int = this.adjustedActiveSongIndex;
            var _local6:Boolean;
            if (_arg3){
                _local6 = this.crossfadeEnabled;
            };
            if ((_arg1 is QueueSong)){
                if (this.contains(_arg1)){
                    if (((((((_local6) && (this.gs_queue::_activeSong))) && (!((_arg1 === this.gs_queue::_activeSong))))) && ((this.gs_queue::_activeSong.playStatus === PlayableSong.PLAY_STATUS_PLAYING)))){
                        this.crossfadeSong = this.gs_queue::_activeSong;
                        _arg1.soundVolume = 0;
                    };
                    this.gs_queue::_activeSong = (_arg1 as QueueSong);
                    checkCacheAndPlaySong(this.activeSong);
                    _local4 = true;
                } else {
                    this.addItemsAt([(_arg1 as QueueSong).song], -1, true);
                };
            } else {
                if ((((_arg1 is BaseSong)) || (int(_arg1)))){
                    _local7 = (((_arg1 is BaseSong)) ? (_arg1 as BaseSong).songID : int(_arg1));
                    _local8 = this.gs_queue::queueSongLookupBySongID[_local7];
                    if (((_local8) && (_local8.length))){
                        _local9 = _local8[0];
                        if (this.contains(_local9)){
                            if (((((((_local6) && (this.gs_queue::_activeSong))) && (!((_local9 === this.gs_queue::_activeSong))))) && ((this.gs_queue::_activeSong.playStatus === PlayableSong.PLAY_STATUS_PLAYING)))){
                                this.crossfadeSong = this.gs_queue::_activeSong;
                                _local9.soundVolume = 0;
                            };
                            this.gs_queue::_activeSong = _local9;
                            checkCacheAndPlaySong(this.activeSong);
                            _local4 = true;
                        } else {
                            _local8.shift();
                            if (!_local8.length){
                                delete this.gs_queue::queueSongLookupBySongID[_local7];
                            };
                            this.addItemsAt([_local9.song], -1, true);
                        };
                    } else {
                        this.addItemsAt([_local7], -1, true);
                    };
                } else {
                    if (_arg1 == null){
                        if (this.gs_queue::_activeSong){
                            checkCacheAndPlaySong(this.activeSong);
                            _local4 = true;
                        } else {
                            if (this.length){
                                this.gs_queue::_activeSong = gs_queue::source[0];
                                checkCacheAndPlaySong(this.activeSong);
                                _local4 = true;
                            };
                        };
                    };
                };
            };
            if (_local4){
                if (_shuffleEnabled){
                    _local10 = gs_queue::playedSongs.indexOf(this.gs_queue::_activeSong);
                    _local11 = gs_queue::pendingSongs.indexOf(this.gs_queue::_activeSong);
                    _local12 = (_local5 + 1);
                    if (((!(_arg2)) && (!((_local10 == -1))))){
                        gs_queue::playedSongs.splice(_local10, 1);
                        if (_local10 < _local12){
                            _local12--;
                        };
                        gs_queue::playedSongs.splice(_local12, 0, this.gs_queue::_activeSong);
                    } else {
                        if (_local11 != -1){
                            gs_queue::pendingSongs.splice(_local11, 1);
                            gs_queue::playedSongs.splice(_local12, 0, this.gs_queue::_activeSong);
                        };
                    };
                };
            };
            recalcHasNextPrev();
        }
        public function enableCrossfade(_arg1:Boolean, _arg2:int=5000, _arg3:Boolean=false):void{
            if (_arg1 != crossfadeEnabled){
                crossfadeEnabled = _arg1;
            };
            if (_arg2 != crossfadeAmount){
                crossfadeAmount = _arg2;
            };
            if (_arg3 != crossfadeInOutEnabled){
                crossfadeInOutEnabled = _arg3;
            };
        }
        protected function onSongVoteFailed(_arg1:PlayableSongEvent):void{
            var _local2:QueueSong = (_arg1.currentTarget as QueueSong);
            if (_local2){
                dispatchEvent(new QueueEvent(QueueEvent.AUTOPLAY_VOTE_ERROR, "", true, {song:_local2}));
            };
        }
        private function set _35740674currentAutoplayTag(_arg1:Tag):void{
            _currentAutoplayTag = _arg1;
        }
        protected function set _1360958307crossfadeRunning(_arg1:Boolean):void{
            if (_arg1 != _crossfadeRunning){
                _crossfadeRunning = _arg1;
                if (((((!(_arg1)) && (crossfadeAmountChanged))) && ((crossfadeNewAmount > 0)))){
                    crossfadeAmount = crossfadeNewAmount;
                    crossfadeAmountChanged = false;
                    crossfadeNewAmount = 0;
                };
            };
        }
        protected function startCrossfade():void{
            if (((crossfadeEnabled) && (crossfadeSongStopTimer))){
                if (crossfadeSongStopTimer.running){
                    stopCrossfade();
                    crossfadeSongStop();
                };
                crossfadeSongStopTimer.reset();
                crossfadeSongStopTimer.start();
                crossfadeRunning = true;
            };
        }
        protected function generateAddSongsToQueue(_arg1:Array, _arg2:int, _arg3:Boolean, _arg4:Boolean, _arg5:Object):void{
            var _local6:AddSongsToQueue = new AddSongsToQueue(service, this, _arg1, _arg2, _arg3, _arg4, _arg5);
            this.gs_queue::commandQueue.queueCommand(_local6);
        }
        override public function removeAll():void{
        }
        public function set activeSong(_arg1:QueueSong):void{
            var _local2:Object = this.activeSong;
            if (_local2 !== _arg1){
                this._2043934011activeSong = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "activeSong", _local2, _arg1));
            };
        }
        public function get hasNextSong():Boolean{
            return (this._3866466hasNextSong);
        }
        public function crossfadeSongStop(_arg1:TimerEvent=null):void{
            if (_crossfadeSong){
                _crossfadeSong.stop();
                _crossfadeSong.soundVolume = Number(1);
                this.removeEventListeners(_crossfadeSong);
                _crossfadeSong = null;
                crossfadeRunning = false;
            };
            crossfadeRunning = false;
            if (((gs_queue::_activeSong) && ((gs_queue::_activeSong.playStatus === PlayableSong.PLAY_STATUS_PLAYING)))){
                gs_queue::_activeSong.soundVolume = 1;
            };
        }
        protected function set _1519093106crossfadeSongStopTimer(_arg1:Timer):void{
            if (_arg1 !== _crossfadeSongStopTimer){
                if (_crossfadeSongStopTimer){
                    _crossfadeSongStopTimer.removeEventListener(TimerEvent.TIMER, crossfadeSongVolume);
                    _crossfadeSongStopTimer.removeEventListener(TimerEvent.TIMER_COMPLETE, crossfadeSongStop);
                };
                _crossfadeSongStopTimer = _arg1;
                if (_crossfadeSongStopTimer){
                    _crossfadeSongStopTimer.addEventListener(TimerEvent.TIMER, crossfadeSongVolume);
                    _crossfadeSongStopTimer.addEventListener(TimerEvent.TIMER_COMPLETE, crossfadeSongStop);
                };
            };
        }
        protected function set _1342440975crossfadeSong(_arg1:QueueSong):void{
            if (_arg1 !== _crossfadeSong){
                if (_crossfadeSong){
                    crossfadeSongStop();
                };
                _crossfadeSong = _arg1;
            };
        }
        override public function toArray():Array{
            return (gs_queue::source.concat());
        }
        protected function get crossfadeSongStopTimer():Timer{
            return (_crossfadeSongStopTimer);
        }
        gs_queue function set _491406817_autoplayEnabled(_arg1:Boolean):void{
            var _local2:Boolean;
            if (_arg1 != __autoplayEnabled){
                _local2 = __autoplayEnabled;
                __autoplayEnabled = _arg1;
                dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "autoplayEnabled", _local2, _arg1));
            };
        }
        public function setAutoplayEnabled(_arg1:Boolean, _arg2:Boolean=false, _arg3:Boolean=true, _arg4:Object=null):void{
            var _local5:InitiateQueue;
            if (_arg1 != gs_queue::_autoplayEnabled){
                this.gs_queue::autoplayUserInitiated = _arg2;
                gs_queue::consecutiveFailedAutoplayRequests = 0;
                gs_queue::lastFailedAutoplayRequest = 0;
                if (_arg1){
                    this.repeatMode = Queue.REPEAT_NONE;
                    this.shuffleEnabled = false;
                    this.gs_queue::_autoplayEnabled = true;
                    if (!this.queueID){
                        _local5 = new InitiateQueue(service, this);
                        this.gs_queue::commandQueue.queueCommand(_local5);
                    };
                    generateVerifyAutoplay(_arg3, _arg4);
                } else {
                    this.gs_queue::_autoplayEnabled = false;
                    generateTurnOffAutoplay();
                };
            };
        }
        private function checkCacheAndPlaySong(_arg1:QueueSong):void{
            var _local2:Number = new Date().valueOf();
            var _local3:Object = Queue.streamKeys[_arg1.song.songID];
            if (_local3){
                delete Queue.streamKeys[_arg1.song.songID];
                if (_local3.expires > _local2){
                    _arg1.play(_local3.streamKey, _local3.ip, _local3.serverID, _local3.uSecs);
                    return;
                };
            };
            _arg1.play();
        }
        override public function setItemAt(_arg1:Object, _arg2:int):Object{
            return (null);
        }
        public function get lastPlaylistID():int{
            return (this._1796994653lastPlaylistID);
        }
        override public function getItemAt(_arg1:int, _arg2:int=0):Object{
            if ((((_arg1 < 0)) || ((_arg1 >= gs_queue::source.length)))){
                throw (new RangeError((("[Queue] Index " + _arg1) + " is out of bounds.")));
            };
            return (gs_queue::source[_arg1]);
        }
        public function get previousSong():QueueSong{
            return (this._1117335380previousSong);
        }
        function determinePreviousSong():QueueSong{
            var _local3:int;
            var _local1:QueueSong;
            var _local2:int = this.adjustedActiveSongIndex;
            if (_local2 <= 0){
                if (this.repeatMode == Queue.REPEAT_ALL){
                    if (_shuffleEnabled){
                        if (gs_queue::pendingSongs.length){
                            _local3 = Math.floor((Math.random() * (gs_queue::pendingSongs.length - 1)));
                            _local1 = gs_queue::pendingSongs.splice(_local3, 1)[0];
                            gs_queue::playedSongs.unshift(_local1);
                        } else {
                            _local1 = gs_queue::playedSongs[(gs_queue::playedSongs.length - 1)];
                        };
                    } else {
                        _local1 = gs_queue::source[(this.length - 1)];
                    };
                };
            } else {
                if (_shuffleEnabled){
                    _local1 = gs_queue::playedSongs[(_local2 - 1)];
                } else {
                    _local1 = gs_queue::source[(_local2 - 1)];
                };
            };
            this.previousSong = _local1;
            return (_local1);
        }
        private function set _806131506autoAutoplayDisabled(_arg1:Boolean):void{
        }
        private function set _342671880shuffleEnabled(_arg1:Boolean):void{
            if (_arg1 != _shuffleEnabled){
                _shuffleEnabled = _arg1;
                if (((this.length) || (!(_arg1)))){
                    setupShuffle(_arg1);
                } else {
                    setupShuffle(false);
                };
            };
        }
        protected function onSongPropChange(_arg1:PropertyChangeEvent):void{
            var _local3:QueueSong;
            var _local2:QueueSong = (_arg1.currentTarget as QueueSong);
            if ((((_arg1.property == "position")) && (!((_local2 === _crossfadeSong))))){
                if (((((((((((((Queue.prefetchEnabled) && ((PlayableSong.consecutiveFailedStreamKeys == 0)))) && (!((this.repeatMode == Queue.REPEAT_ONE))))) && (_local2.fileLoaded))) && (_local2.position))) && (_local2.duration))) && (((_local2.duration - _local2.position) < 20000)))){
                    _local3 = determineNextSong();
                    if (((_local3) && (!((_local3 === activeSong))))){
                        _local3.load();
                        prefetchedSongs.push(_local3);
                        if (((this.crossfadeEnabled) && (((_local2.duration - _local2.position) < this.crossfadeAmount)))){
                            if (_local3.playStatus != PlayableSong.PLAY_STATUS_PLAYING){
                                playNextSong();
                            };
                        };
                    };
                };
                if (((((((((_crossfadeSong) && ((((_crossfadeSong.playStatus === PlayableSong.PLAY_STATUS_PLAYING)) || (((gs_queue::_activeSong) && ((gs_queue::_activeSong.soundVolume < 1)))))))) && ((_local2 === gs_queue::_activeSong)))) && ((_local2.position > (this.crossfadeAmount + 1000))))) && (((_local2.duration - _local2.position) > this.crossfadeAmount)))){
                    crossfadeSongStop();
                    if (gs_queue::_activeSong){
                        gs_queue::_activeSong.soundVolume = Number(1);
                    };
                };
            };
        }
        public function removeItem(_arg1:Object, _arg2:Boolean=true):void{
            this.removeItems([_arg1], _arg2);
        }
        public function stopTagAutoplay():void{
            this.currentAutoplayTag = null;
            if (this.autoplayEnabled){
                this.gs_queue::autoplayStatus.addTagArtistSeeds([]);
            };
        }
        private function set _2112713164crossfadeAmount(_arg1:int):void{
            var _local2:Number;
            if (_arg1 != _crossfadeAmount){
                if (crossfadeRunning){
                    crossfadeAmountChanged = true;
                    crossfadeNewAmount = _arg1;
                } else {
                    _local2 = (_arg1 as Number);
                    this.crossfadeSongStopTimer = new Timer(((1 / CROSSFADE_STEPS) * 1000), ((CROSSFADE_STEPS * _local2) / 1000));
                    _crossfadeAmount = _arg1;
                };
            };
        }
        override public function addItemAt(_arg1:Object, _arg2:int):void{
        }
        private function setupShuffle(_arg1:Boolean):void{
            var _local2:QueueSong;
            var _local3:int;
            if (_arg1){
                gs_queue::playedSongs = [];
                gs_queue::pendingSongs = gs_queue::source.concat();
                _local2 = gs_queue::_activeSong;
                if (((((!(_local2)) || ((_local2.playStatus == PlayableSong.PLAY_STATUS_NONE)))) || ((_local2.playStatus == PlayableSong.PLAY_STATUS_COMPLETED)))){
                    _local3 = Math.floor((Math.random() * (gs_queue::pendingSongs.length - 1)));
                    _local2 = gs_queue::pendingSongs[_local3];
                };
                gs_queue::pendingSongs.splice(gs_queue::pendingSongs.indexOf(_local2), 1);
                gs_queue::playedSongs.unshift(_local2);
                gs_queue::_activeSong = _local2;
            } else {
                gs_queue::playedSongs = [];
                gs_queue::pendingSongs = [];
            };
            recalcHasNextPrev();
        }
        public function set hasNextSong(_arg1:Boolean):void{
            var _local2:Object = this._3866466hasNextSong;
            if (_local2 !== _arg1){
                this._3866466hasNextSong = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "hasNextSong", _local2, _arg1));
            };
        }
        private function set _1672751092crossfadeInOutEnabled(_arg1:Boolean):void{
            if (_arg1 != crossfadeInOutEnabled){
                _crossfadeInOutEnabled = _arg1;
                if (gs_queue::_activeSong){
                    gs_queue::_activeSong.setFadeOptions(_arg1);
                };
            };
        }
        protected function set crossfadeRunning(_arg1:Boolean):void{
            var _local2:Object = this.crossfadeRunning;
            if (_local2 !== _arg1){
                this._1360958307crossfadeRunning = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "crossfadeRunning", _local2, _arg1));
            };
        }
        override public function getItemIndex(_arg1:Object):int{
            return (gs_queue::source.indexOf(_arg1));
        }
        public function get nextSong():QueueSong{
            return (this._1424376488nextSong);
        }
        public function set autoplayEnabled(_arg1:Boolean):void{
            var _local2:Object = this.autoplayEnabled;
            if (_local2 !== _arg1){
                this._764699742autoplayEnabled = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "autoplayEnabled", _local2, _arg1));
            };
        }
        gs_queue function set _activeSong(_arg1:QueueSong):void{
            var _local2:Object = this.gs_queue::_activeSong;
            if (_local2 !== _arg1){
                this.gs_queue::_1162720550_activeSong = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "gs_queue::_activeSong", _local2, _arg1));
            };
        }
        gs_queue function set _1162720550_activeSong(_arg1:QueueSong):void{
            var _local2:QueueSong;
            var _local3:QueueSong;
            if (_arg1 != __activeSong){
                _local2 = __activeSong;
                if (((__activeSong) && (!((__activeSong === crossfadeSong))))){
                    __activeSong.stop();
                    this.removeEventListeners(__activeSong);
                };
                __activeSong = _arg1;
                if (__activeSong){
                    __activeSong.setFadeOptions(this.crossfadeInOutEnabled);
                    __activeSong.addEventListener(PropertyChangeEvent.PROPERTY_CHANGE, onSongPropChange, false, 0, true);
                    __activeSong.addEventListener(PlayableSongEvent.COMPLETE, onSongComplete, false, 0, true);
                    __activeSong.addEventListener(PlayableSongEvent.ERROR, onSongError, false, 0, true);
                    __activeSong.addEventListener(PlayableSongEvent.PLAYBACK_BEGUN, onSongPlayback, false, 0, true);
                } else {
                    if (((((this._crossfadeSong) && ((this._crossfadeSong.playStatus == PlayableSong.PLAY_STATUS_PLAYING)))) && (!(this.crossfadeSongStopTimer.running)))){
                        startCrossfade();
                    };
                };
                while (prefetchedSongs.length) {
                    _local3 = prefetchedSongs.shift();
                    if (((!((_local3 === __activeSong))) && (!((_local3 === crossfadeSong))))){
                        _local3.stop();
                    };
                };
                recalcHasNextPrev();
                dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "activeSong", _local2, _arg1));
            };
        }
        protected function generateVerifyAutoplay(_arg1:Boolean=true, _arg2:Object=null):void{
            var _local3:QueueCommand = new VerifyAutoplay(service, this, _arg1, _arg2);
            this.gs_queue::commandQueue.queueCommand(_local3);
        }
        private function set _764699742autoplayEnabled(_arg1:Boolean):void{
        }
        public function set hasPreviousSong(_arg1:Boolean):void{
            var _local2:Object = this._37396582hasPreviousSong;
            if (_local2 !== _arg1){
                this._37396582hasPreviousSong = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "hasPreviousSong", _local2, _arg1));
            };
        }
        protected function onSongError(_arg1:PlayableSongEvent):void{
            var _local2:String;
            var _local3:Boolean;
            switch (_arg1.code){
                case PlayableSongEvent.FAILED_IO_ERROR:
                case PlayableSongEvent.FAILED_TOO_MANY_BAD_FRAMES:
                case PlayableSongEvent.FAILED_STREAMKEY_OTHER:
                case PlayableSongEvent.FAILED_UNKNOWN_SERVER_ERROR:
                    switch (_arg1.preErrorStatus){
                        case PlayableSong.PLAY_STATUS_INITIALIZING:
                        case PlayableSong.PLAY_STATUS_LOADING:
                        case PlayableSong.PLAY_STATUS_BUFFERING:
                        case PlayableSong.PLAY_STATUS_PLAYING:
                            _local3 = true;
                            break;
                    };
                    if (((this.hasNextSong) && (_local3))){
                        _local2 = QueueEvent.UNKNOWN_HAS_NEXT;
                    } else {
                        _local2 = QueueEvent.UNKNOWN_STOPPING;
                    };
                    break;
                case PlayableSongEvent.FAILED_STREAMKEY_LIMIT:
                    _local2 = QueueEvent.RATE_LIMIT_EXCEEDED;
                    break;
                case PlayableSongEvent.FAILED_TOO_MANY_STREAMKEY_FAILS:
                    _local2 = QueueEvent.TOO_MANY_FAILURES;
                    break;
                case PlayableSongEvent.WARNING_FREQUENT_BUFFERING:
                    break;
            };
            if (_local2){
                dispatchEvent(new QueueEvent(QueueEvent.PLAYBACK_ERROR, _local2, true, {
                    song:_arg1.currentTarget,
                    event:_arg1
                }));
            };
            if (((_local3) && (this.hasNextSong))){
                playNextSong();
            };
        }
        public function get autoAutoplayDisabled():Boolean{
            return (true);
        }
        protected function generateRefreshPendingAutoplaySong(_arg1:QueueSong, _arg2:Boolean=false):void{
            var _local3:QueueCommand = new RefreshPendingAutoplaySong(service, this, _arg1, _arg2);
            this.gs_queue::commandQueue.queueCommand(_local3);
        }
        public function get currentIndex():int{
            if (!gs_queue::_activeSong){
                return (-1);
            };
            return (gs_queue::source.indexOf(gs_queue::_activeSong));
        }
        protected function stopCrossfade():void{
            _crossfadeSongStopTimer.stop();
            crossfadeRunning = false;
        }
        public function get repeatMode():int{
            return (_repeatMode);
        }
        protected function insertItemsAtIndex(_arg1:Array, _arg2:Array, _arg3:int):Array{
            var _local4:Array = [];
            if (_arg3 == 0){
                _local4 = _arg2.concat(_arg1);
            } else {
                if (_arg3 == _arg1.length){
                    _local4 = _arg1.concat(_arg2);
                } else {
                    _local4 = _arg1.slice(0, _arg3).concat(_arg2).concat(_arg1.slice(_arg3));
                };
            };
            return (_local4);
        }
        gs_queue function get _activeSong():QueueSong{
            return (__activeSong);
        }
        public function get crossfadeEnabled():Boolean{
            return (_crossfadeEnabled);
        }
        override public function get length():int{
            return (gs_queue::source.length);
        }
        protected function onSongPlayback(_arg1:PlayableSongEvent):void{
            if (((this._crossfadeSong) || (((this.gs_queue::_activeSong) && ((this.gs_queue::_activeSong.soundVolume < 1)))))){
                startCrossfade();
            };
        }
        gs_queue function completeRemoveSongs(_arg1:Array):void{
            var _local2:Number;
            var _local5:QueueSong;
            var _local6:int;
            var _local8:int;
            var _local9:Array;
            var _local10:CollectionEvent;
            var _local11:PropertyChangeEvent;
            var _local12:Boolean;
            var _local13:int;
            var _local3:Boolean;
            var _local4:int = _arg1.length;
            var _local7:int;
            while (_local7 < _local4) {
                _local5 = (_arg1[_local7] as QueueSong);
                if (!_local5){
                    break;
                };
                _local6 = gs_queue::source.indexOf(_local5);
                if (_local6 != -1){
                    gs_queue::source.splice(_local6, 1);
                };
                _local8 = gs_queue::playedSongs.indexOf(_local5);
                if (_local8 != -1){
                    gs_queue::playedSongs.splice(_local8, 1);
                } else {
                    _local8 = gs_queue::pendingSongs.indexOf(_local5);
                    if (_local8 != -1){
                        gs_queue::pendingSongs.splice(_local8, 1);
                    };
                };
                if (_local5 === gs_queue::_activeSong){
                    _local2 = Number(_local6);
                    switch (_local5.playStatus){
                        case PlayableSong.PLAY_STATUS_INITIALIZING:
                        case PlayableSong.PLAY_STATUS_LOADING:
                        case PlayableSong.PLAY_STATUS_PLAYING:
                        case PlayableSong.PLAY_STATUS_PAUSED:
                        case PlayableSong.PLAY_STATUS_BUFFERING:
                            _local3 = true;
                            break;
                    };
                };
                this.removeEventListeners(_local5);
                _local9 = gs_queue::queueSongLookupBySongID[_local5.song.songID];
                if (_local9){
                    _local8 = _local9.indexOf(_local5);
                    if (_local8 != -1){
                        _local9.splice(_local8, 1);
                    };
                    if (!_local9.length){
                        delete gs_queue::queueSongLookupBySongID[_local5.song.songID];
                    };
                };
                delete gs_queue::queueSongLookupByQueueSongID[_local5.queueSongID];
                _local7++;
            };
            if ((((_arg1.length == 1)) && (this.length))){
                _local10 = new CollectionEvent(CollectionEvent.COLLECTION_CHANGE);
                _local10.kind = CollectionEventKind.REMOVE;
                _local10.location = _local6;
                _local10.items = [_local5];
                dispatchEvent(_local10);
                _local11 = new PropertyChangeEvent(PropertyChangeEvent.PROPERTY_CHANGE);
                _local11.property = _local6;
                _local11.oldValue = _local5;
                dispatchEvent(_local11);
            } else {
                _local10 = new CollectionEvent(CollectionEvent.COLLECTION_CHANGE);
                _local10.kind = CollectionEventKind.RESET;
                dispatchEvent(_local10);
            };
            if (((this.length) && (!((_local2.toString() == "NaN"))))){
                _local12 = false;
                if (((this.crossfadeEnabled) && ((this.gs_queue::_activeSong.playStatus === PlayableSong.PLAY_STATUS_PLAYING)))){
                    this.crossfadeSong = this.gs_queue::_activeSong;
                };
                if (_shuffleEnabled){
                    if (_local2 < gs_queue::playedSongs.length){
                        gs_queue::_activeSong = gs_queue::playedSongs[_local2];
                    } else {
                        if (gs_queue::pendingSongs.length){
                            _local13 = Math.floor((Math.random() * (gs_queue::pendingSongs.length - 1)));
                            gs_queue::_activeSong = gs_queue::pendingSongs.splice(_local13, 1)[0];
                            gs_queue::playedSongs.push(gs_queue::_activeSong);
                        } else {
                            gs_queue::_activeSong = gs_queue::playedSongs[(gs_queue::playedSongs.length - 1)];
                            _local12 = true;
                        };
                    };
                } else {
                    if (_local2 < this.length){
                        gs_queue::_activeSong = gs_queue::source[_local2];
                    } else {
                        gs_queue::_activeSong = gs_queue::source[(this.length - 1)];
                        _local12 = true;
                    };
                };
                if (((_local3) && (((!(_local12)) || ((((gs_queue::_activeSong.playStatus == PlayableSong.PLAY_STATUS_NONE)) && (!(gs_queue::_activeSong.lastStreamKey)))))))){
                    this.playSong(gs_queue::_activeSong);
                };
            };
            if (!this.length){
                gs_queue::_activeSong = null;
            };
            recalcHasNextPrev();
            if (gs_queue::autoplayStatus){
                gs_queue::autoplayStatus.songsRemovedFromQueue(_arg1);
            };
        }
        private function set _1159370206repeatMode(_arg1:int):void{
            if (_arg1 != _repeatMode){
                _repeatMode = _arg1;
                recalcHasNextPrev();
            };
        }
        public function get queueID():String{
            return (this._655172076queueID);
        }
        public function set crossfadeInOutEnabled(_arg1:Boolean):void{
            var _local2:Object = this.crossfadeInOutEnabled;
            if (_local2 !== _arg1){
                this._1672751092crossfadeInOutEnabled = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "crossfadeInOutEnabled", _local2, _arg1));
            };
        }
        public function removeItems(_arg1:Array, _arg2:Boolean=true):void{
            var _local3:Array;
            while (_arg1.length > 0) {
                _local3 = _arg1.splice(0, 100);
                generateRemoveSongsFromQueue(_local3, _arg2);
            };
        }
        protected function set crossfadeSongStopTimer(_arg1:Timer):void{
            var _local2:Object = this.crossfadeSongStopTimer;
            if (_local2 !== _arg1){
                this._1519093106crossfadeSongStopTimer = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "crossfadeSongStopTimer", _local2, _arg1));
            };
        }
        public function pause():void{
            if (((_crossfadeSong) && ((_crossfadeSong.playStatus === PlayableSong.PLAY_STATUS_PLAYING)))){
                if ((_crossfadeSong.duration - _crossfadeSong.position) < this.crossfadeAmount){
                    _crossfadeSong.soundVolume = 0;
                } else {
                    crossfadeSongStop();
                };
            };
            if (gs_queue::_activeSong){
                gs_queue::_activeSong.pause();
                gs_queue::_activeSong.soundVolume = Number(1);
            };
        }
        public function set crossfadeEnabled(_arg1:Boolean):void{
            var _local2:Object = this.crossfadeEnabled;
            if (_local2 !== _arg1){
                this._1799419675crossfadeEnabled = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "crossfadeEnabled", _local2, _arg1));
            };
        }
        protected function get crossfadeSong():QueueSong{
            return (_crossfadeSong);
        }
        public function get crossfadeInOutEnabled():Boolean{
            return (_crossfadeInOutEnabled);
        }
        public function get currentAutoplayTag():Tag{
            return (_currentAutoplayTag);
        }
        public function set autoAutoplayDisabled(_arg1:Boolean):void{
            var _local2:Object = this.autoAutoplayDisabled;
            if (_local2 !== _arg1){
                this._806131506autoAutoplayDisabled = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "autoAutoplayDisabled", _local2, _arg1));
            };
        }

    }
}//package com.grooveshark.framework.playback 
﻿package com.grooveshark.framework.playback {
    import com.grooveshark.utils.*;

    public final class AutoplayStatus {

        public static var numPlayedSongs:int = 50;
        public static var minDuration:Number = 60;
        public static var weightModifierRange:Array = [-9, 9];
        public static var minSeeds:int = 10;
        public static var numPlayedArtists:int = 5;
        public static var maxDuration:Number = 1500;
        public static var numBadTitles:int = 25;
        public static var seedWeightRange:Array = [70, 100];
        public static var secondarySeedWeightMultiplier:Number = 0.9;

        var frowns:Array;
        var taggedArtistIDs:Array;
        var _minDuration:Number;
        var flaggedSongIDs:Array;
        var _minSeeds:int;
        var userSeeds:Array;
        var _maxDuration:Number;
        var _numPlayedArtists:int;
        var _weightModifierRange:Array;
        var smiles:Array;
        public var parent:Queue;
        var _numPlayedSongs:int;
        var _seedWeightRange:Array;
        var _numBadTitles:int;
        var _secondarySeedWeightMultiplier:Number;

        public function AutoplayStatus(_arg1:Queue, _arg2:Object=null):void{
            var _local3:QueueSong;
            var _local4:Object;
            userSeeds = [];
            smiles = [];
            frowns = [];
            taggedArtistIDs = [];
            flaggedSongIDs = [];
            super();
            this.parent = _arg1;
            if (!_arg2){
                _arg2 = {};
            };
            _minSeeds = AutoplayStatus.minSeeds;
            _numPlayedArtists = AutoplayStatus.numPlayedArtists;
            _numPlayedSongs = AutoplayStatus.numPlayedSongs;
            _numBadTitles = AutoplayStatus.numBadTitles;
            if (_arg2.hasOwnProperty("secondaryArtistWeightModifier")){
                _secondarySeedWeightMultiplier = _arg2.secondaryArtistWeightModifier;
            } else {
                _secondarySeedWeightMultiplier = AutoplayStatus.secondarySeedWeightMultiplier;
            };
            if (_arg2.hasOwnProperty("seedArtistWeightRange")){
                _seedWeightRange = _arg2.seedArtistWeightRange;
            } else {
                _seedWeightRange = AutoplayStatus.seedWeightRange;
            };
            if (_arg2.hasOwnProperty("weightModifierRange")){
                _weightModifierRange = _arg2.weightModifierRange;
            } else {
                _weightModifierRange = AutoplayStatus.weightModifierRange;
            };
            _minDuration = AutoplayStatus.minDuration;
            _maxDuration = AutoplayStatus.maxDuration;
            for each (_local3 in _arg1) {
                if (_local3.source == "user"){
                    userSeeds.push(_local3);
                };
                if (_local3.gs_queue::_autoplayVote == QueueSong.AUTOPLAY_VOTE_UP){
                    smiles.push(_local3);
                } else {
                    if (_local3.gs_queue::_autoplayVote == QueueSong.AUTOPLAY_VOTE_DOWN){
                        frowns.push(_local3);
                    };
                };
            };
            if (((_arg2.hasOwnProperty("seeds")) && ((_arg2.seeds is Array)))){
                for each (_local4 in (_arg2.seeds as Array)) {
                    trace(("seed: " + _local4));
                    if (((_local4.hasOwnProperty("artistID")) && (int(_local4.artistID)))){
                        userSeeds.push(int(_local4.artistID));
                    } else {
                        if (((_local4.hasOwnProperty("ArtistID")) && (int(_local4.ArtistID)))){
                            userSeeds.push(int(_local4.ArtistID));
                        } else {
                            if (int(_local4)){
                                userSeeds.push(int(_local4));
                            };
                        };
                    };
                };
            };
            if (((_arg2.hasOwnProperty("frowns")) && ((_arg2.frowns is Array)))){
                for each (_local4 in (_arg2.frowns as Array)) {
                    if (((_local4.hasOwnProperty("artistID")) && (int(_local4.artistID)))){
                        frowns.push(int(_local4.artistID));
                    } else {
                        if (((_local4.hasOwnProperty("ArtistID")) && (int(_local4.ArtistID)))){
                            frowns.push(int(_local4.ArtistID));
                        } else {
                            if (int(_local4)){
                                frowns.push(int(_local4));
                            };
                        };
                    };
                };
            };
        }
        public static function paramsToStringArray():Array{
            var _local1:Array = [];
            _local1.push(("minSeeds: " + minSeeds));
            _local1.push(("numPlayedArtists: " + numPlayedArtists));
            _local1.push(("numPlayedSongs: " + numPlayedSongs));
            _local1.push(("numBadTitles: " + numBadTitles));
            _local1.push(("secondarySeedWeightMultiplier: " + secondarySeedWeightMultiplier));
            _local1.push(("seedWeightRange: " + seedWeightRange));
            _local1.push(("weightModifierRange: " + weightModifierRange));
            _local1.push(("minDuration: " + minDuration));
            _local1.push(("maxDuration: " + maxDuration));
            return (_local1);
        }
        public static function createFromStoredParams(_arg1:Queue, _arg2:Object):AutoplayStatus{
            var _local4:Object;
            var _local5:QueueSong;
            var _local3:AutoplayStatus = new AutoplayStatus(_arg1);
            if (_arg2){
                if ((((_arg2.version == 1)) || ((_arg2.version == 2)))){
                    _local3._minSeeds = _arg2.minSeeds;
                    _local3._numPlayedArtists = _arg2.numPlayedArtists;
                    _local3._numPlayedSongs = _arg2.numPlayedSongs;
                    _local3._numBadTitles = _arg2.numBadTitles;
                    _local3._secondarySeedWeightMultiplier = _arg2.secondarySeedWeightMultiplier;
                    _local3._seedWeightRange = _arg2.seedWeightRange;
                    _local3._weightModifierRange = _arg2.weightModifierRange;
                    _local3._minDuration = _arg2.minDuration;
                    _local3._maxDuration = _arg2.maxDuration;
                    if (((_arg2.hasOwnProperty("flaggedSongIDs")) && ((_arg2.flaggedSongIDs is Array)))){
                        _local3.flaggedSongIDs = _arg2.flaggedSongIDs;
                    };
                    if (_arg2.version == 1){
                        for each (_local4 in _arg2.seeds) {
                            if (((_local4.hasOwnProperty("queueSongID")) && (int(_local4.queueSongID)))){
                                _local5 = _arg1.gs_queue::queueSongLookupByQueueSongID[int(_local4.queueSongID)];
                                if (_local5){
                                    if (_local5.source == "user"){
                                        if (_local3.userSeeds.indexOf(_local5) == -1){
                                            _local3.userSeeds.push(_local5);
                                        };
                                    };
                                    if (_local5.gs_queue::_autoplayVote == QueueSong.AUTOPLAY_VOTE_UP){
                                        if (_local3.smiles.indexOf(_local5) == -1){
                                            _local3.smiles.push(_local5);
                                        };
                                    };
                                };
                            } else {
                                if (((_local4.hasOwnProperty("artistID")) && (int(_local4.artistID)))){
                                    _local3.taggedArtistIDs.push(int(_local4.artistID));
                                };
                            };
                        };
                        for each (_local4 in _arg2.frowns) {
                            if (((_local4.hasOwnProperty("artistID")) && (int(_local4.artistID)))){
                                _local3.frowns.push(int(_local4.artistID));
                            };
                        };
                    } else {
                        if (_arg2.version == 2){
                            for each (_local4 in _arg2.userSeeds) {
                                if (((_local4.hasOwnProperty("queueSongID")) && (int(_local4.queueSongID)))){
                                    _local5 = _arg1.gs_queue::queueSongLookupByQueueSongID[int(_local4.queueSongID)];
                                    if (((((_local5) && ((_local5.source == "user")))) && ((_local3.userSeeds.indexOf(_local5) == -1)))){
                                        _local3.userSeeds.push(_local5);
                                    };
                                } else {
                                    if (((_local4.hasOwnProperty("artistID")) && (int(_local4.artistID)))){
                                        _local3.userSeeds.push(int(_local4.artistID));
                                    };
                                };
                            };
                            for each (_local4 in _arg2.smiles) {
                                if (((_local4.hasOwnProperty("queueSongID")) && (int(_local4.queueSongID)))){
                                    _local5 = _arg1.gs_queue::queueSongLookupByQueueSongID[int(_local4.queueSongID)];
                                    if (((((_local5) && ((_local5.gs_queue::_autoplayVote == QueueSong.AUTOPLAY_VOTE_UP)))) && ((_local3.smiles.indexOf(_local5) == -1)))){
                                        _local3.smiles.push(_local5);
                                    };
                                };
                            };
                            for each (_local4 in _arg2.frowns) {
                                if (((_local4.hasOwnProperty("artistID")) && (int(_local4.artistID)))){
                                    _local3.frowns.push(int(_local4.artistID));
                                };
                            };
                            for each (_local4 in _arg2.taggedArtistIDs) {
                                if (((_local4.hasOwnProperty("artistID")) && (int(_local4.artistID)))){
                                    _local3.taggedArtistIDs.push(int(_local4.artistID));
                                };
                            };
                        };
                    };
                };
            };
            return (_local3);
        }

        public function songFlagged(_arg1:QueueSong):void{
            var _local2:int = _arg1.song.songID;
            var _local3:int = flaggedSongIDs.indexOf(_local2);
            if (_local3 == -1){
                flaggedSongIDs.push(_local2);
            };
        }
        public function get badTitles():Array{
            var _local3:QueueSong;
            var _local4:String;
            var _local1:Array = [];
            var _local2:int = (parent.length - 1);
            while (_local2 >= 0) {
                if (_local1.length < AutoplayStatus.numBadTitles){
                    _local3 = (parent.getItemAt(_local2) as QueueSong);
                    _local4 = StringUtils.condenseTitle(_local3.song.songName);
                    if (_local4){
                        _local1.push(_local4);
                    };
                } else {
                    break;
                };
                _local2--;
            };
            return (_local1);
        }
        public function songsAddedToQueue(_arg1:Array):void{
            var _local2:QueueSong;
            for each (_local2 in _arg1) {
                if (_local2.source == "user"){
                    userSeeds.push(_local2);
                };
            };
        }
        public function addTagArtistSeeds(_arg1:Array):void{
            taggedArtistIDs = _arg1;
            _seedWeightRange = [110, 130];
            _secondarySeedWeightMultiplier = 0.75;
            _numPlayedArtists = 15;
        }
        public function createStoredParams():Object{
            var _local2:Object;
            var _local3:QueueSong;
            var _local4:int;
            var _local1:Object = {};
            _local1.version = 2;
            _local1.minSeeds = this._minSeeds;
            _local1.numPlayedArtists = this._numPlayedArtists;
            _local1.numPlayedSongs = this._numPlayedSongs;
            _local1.numBadTitles = this._numBadTitles;
            _local1.secondarySeedWeightMultiplier = this._secondarySeedWeightMultiplier;
            _local1.seedWeightRange = this._seedWeightRange;
            _local1.weightModifierRange = this._weightModifierRange;
            _local1.minDuration = this._minDuration;
            _local1.maxDuration = this._maxDuration;
            _local1.userSeeds = [];
            _local1.smiles = [];
            _local1.frowns = [];
            _local1.taggedArtistIDs = [];
            _local1.flaggedSongIDs = [];
            for each (_local2 in userSeeds) {
                if ((_local2 is QueueSong)){
                    _local1.userSeeds.push({queueSongID:_local2.queueSongID});
                } else {
                    if (int(_local2)){
                        _local1.userSeeds.push({artistID:int(_local2)});
                    };
                };
            };
            for each (_local3 in smiles) {
                _local1.smiles.push({queueSongID:_local3.queueSongID});
            };
            for each (_local2 in frowns) {
                if ((_local2 is QueueSong)){
                    _local1.frowns.push({artistID:(_local2 as QueueSong).song.artistID});
                } else {
                    if (int(_local2)){
                        _local1.frowns.push({artistID:int(_local2)});
                    };
                };
            };
            for each (_local4 in taggedArtistIDs) {
                _local1.taggedArtistIDs.push({artistID:_local4});
            };
            return (_local1);
        }
        public function songsRemovedFromQueue(_arg1:Array):void{
            var _local2:QueueSong;
            var _local3:int;
            for each (_local2 in _arg1) {
                _local3 = userSeeds.indexOf(_local2);
                if (_local3 != -1){
                    userSeeds.splice(_local3, 1);
                };
                _local3 = smiles.indexOf(_local2);
                if (_local3 != -1){
                    smiles.splice(_local3, 1);
                };
            };
        }
        public function songVoted(_arg1:QueueSong):void{
            var _local2:int;
            switch (_arg1.gs_queue::_autoplayVote){
                case QueueSong.AUTOPLAY_VOTE_UP:
                    if (smiles.indexOf(_arg1) == -1){
                        smiles.push(_arg1);
                    };
                    break;
                case QueueSong.AUTOPLAY_VOTE_DOWN:
                    if (frowns.indexOf(_arg1) == -1){
                        frowns.push(_arg1);
                    };
                    break;
                case QueueSong.AUTOPLAY_VOTE_NONE:
                    _local2 = smiles.indexOf(_arg1);
                    if (_local2 != -1){
                        smiles.splice(_local2, 1);
                    };
                    _local2 = frowns.indexOf(_arg1);
                    if (_local2 != -1){
                        frowns.splice(_local2, 1);
                    };
                    break;
            };
        }
        public function get statusForRPC():Object{
            var _local3:Object;
            var _local4:Array;
            var _local5:QueueSong;
            var _local6:Array;
            var _local7:Array;
            var _local8:Array;
            var _local9:int;
            var _local11:int;
            var _local12:int;
            var _local13:Object;
            var _local14:QueueSong;
            var _local15:int;
            var _local1:Object = {};
            var _local2:Array = [];
            for each (_local3 in frowns) {
                if ((_local3 is QueueSong)){
                    _local2.push((_local3 as QueueSong).song.artistID);
                } else {
                    if (int(_local3)){
                        _local2.push(int(_local3));
                    };
                };
            };
            _local4 = userSeeds.concat();
            for each (_local5 in smiles) {
                if (_local4.indexOf(_local5) == -1){
                    _local4.push(_local5);
                };
            };
            _local4 = _local4.concat(taggedArtistIDs);
            _local6 = [];
            for each (_local3 in _local4) {
                if ((_local3 is QueueSong)){
                    _local12 = (_local3 as QueueSong).song.artistID;
                } else {
                    if (int(_local3) != 0){
                        _local12 = int(_local3);
                    };
                };
                _local11 = _local2.indexOf(_local12);
                if (_local11 == -1){
                    _local13 = {};
                    _local13.artistID = _local12;
                    _local13.type = "p";
                    _local6.push(_local13);
                } else {
                    _local2.splice(_local11, 1);
                };
            };
            _local7 = [];
            _local8 = [];
            _local9 = (parent.length - 1);
            while (_local9 >= 0) {
                _local14 = (parent.getItemAt(_local9) as QueueSong);
                _local15 = _local14.song.songID;
                _local12 = _local14.song.artistID;
                if ((((((((_local6.length < _minSeeds)) && (_local14.thirtySecReported))) && ((_local4.indexOf(_local14) == -1)))) && (!((_local14.source == "sponsored"))))){
                    _local11 = _local2.indexOf(_local12);
                    if (_local11 == -1){
                        _local13 = {};
                        _local13.artistID = _local12;
                        _local13.type = "s";
                        _local6.push(_local13);
                    } else {
                        _local2.splice(_local11, 1);
                    };
                };
                if ((((_local7.length < _numPlayedArtists)) && ((_local7.indexOf(_local12) == -1)))){
                    _local7.push(_local12);
                };
                if ((((_local8.length < _numPlayedSongs)) && ((_local8.indexOf(_local15) == -1)))){
                    _local8.push(_local15);
                };
                if ((((((_local6.length >= _minSeeds)) && ((_local7.length == _numPlayedArtists)))) && ((_local8.length == _numPlayedSongs)))){
                    break;
                };
                _local9--;
            };
            var _local10:Object = {};
            for each (_local13 in _local6) {
                if (!_local10[_local13.artistID]){
                    _local10[_local13.artistID] = _local13.type;
                };
            };
            _local1.seedArtists = _local10;
            _local1.frowns = _local2;
            _local1.recentArtists = _local7;
            _local1.songIDsAlreadySeen = _local8.concat(flaggedSongIDs);
            _local1.secondaryArtistWeightModifier = _secondarySeedWeightMultiplier;
            _local1.seedArtistWeightRange = _seedWeightRange;
            _local1.weightModifierRange = _weightModifierRange;
            _local1.minDuration = _minDuration;
            _local1.maxDuration = _maxDuration;
            return (_local1);
        }

    }
}//package com.grooveshark.framework.playback 
﻿package com.grooveshark.framework.playback {
    import flash.events.*;
    import flash.media.*;
    import flash.net.*;
    import flash.errors.*;

    public class GSSound9 extends EventDispatcher implements IGSSound {

        public static const DEFAULT_NETWORK_BUFFER:int = 3000;

        protected var sourceSound:Sound;
        private var _url:String;
        private var _volume:Number = 1;
        private var _outputSoundChannel:SoundChannel;
        protected var _isStopped:Boolean = true;
        protected var _isPaused:Boolean = false;
        protected var pausedPosition:Number = 0;

        public function GSSound9(_arg1:URLRequest, _arg2:Number=3000, _arg3:Boolean=true){
            _url = _arg1.url;
            sourceSound = new Sound();
            sourceSound.addEventListener(ProgressEvent.PROGRESS, onProgress);
            sourceSound.addEventListener(Event.COMPLETE, onDownloadComplete);
            sourceSound.addEventListener(IOErrorEvent.IO_ERROR, onIOError);
            sourceSound.load(_arg1, new SoundLoaderContext(_arg2, _arg3));
        }
        public function stop():void{
            _isPaused = false;
            _isStopped = true;
            if (outputSoundChannel){
                outputSoundChannel.stop();
            };
            if (((sourceSound) && ((sourceSound.bytesLoaded < sourceSound.bytesTotal)))){
                try {
                    sourceSound.close();
                } catch(error:IOError) {
                };
                sourceSound.removeEventListener(ProgressEvent.PROGRESS, onProgress);
                sourceSound.removeEventListener(Event.COMPLETE, onDownloadComplete);
                sourceSound.removeEventListener(IOErrorEvent.IO_ERROR, onIOError);
                sourceSound = null;
            };
        }
        public function set filters(_arg1:Array):void{
        }
        public function get duration():Number{
            if (sourceSound.bytesLoaded <= 0){
                return (0);
            };
            return ((sourceSound.length / (sourceSound.bytesLoaded / sourceSound.bytesTotal)));
        }
        protected function get outputSoundChannel():SoundChannel{
            return (_outputSoundChannel);
        }
        public function get isBuffering():Boolean{
            return (sourceSound.isBuffering);
        }
        public function get bytesTotal():int{
            return (sourceSound.bytesTotal);
        }
        public function get volume():Number{
            return (_volume);
        }
        public function get position():Number{
            return (((isPaused) ? pausedPosition : ((outputSoundChannel) ? outputSoundChannel.position : 0)));
        }
        protected function set outputSoundChannel(_arg1:SoundChannel):void{
            var _local2:SoundTransform;
            if (_arg1 !== _outputSoundChannel){
                if (_outputSoundChannel){
                    _outputSoundChannel.removeEventListener(Event.SOUND_COMPLETE, onSoundComplete);
                    _outputSoundChannel.stop();
                };
                _outputSoundChannel = _arg1;
                if (_outputSoundChannel){
                    _local2 = _outputSoundChannel.soundTransform;
                    _local2.volume = _volume;
                    _outputSoundChannel.soundTransform = _local2;
                    _outputSoundChannel.addEventListener(Event.SOUND_COMPLETE, onSoundComplete);
                };
            };
        }
        protected function onProgress(_arg1:Event):void{
            if (((sourceSound.url) && (!((sourceSound.url === _url))))){
                _url = sourceSound.url;
                dispatchEvent(new GSSoundEvent(GSSoundEvent.URL_CHANGED));
            };
        }
        public function get isStopped():Boolean{
            return (_isStopped);
        }
        protected function onSoundComplete(_arg1:Event):void{
            if (sourceSound.bytesLoaded >= sourceSound.bytesTotal){
                dispatchEvent(new GSSoundEvent(GSSoundEvent.PLAYBACK_COMPLETE));
            };
        }
        public function play():void{
            var _local1:Number;
            if (_isPaused){
                _local1 = pausedPosition;
            } else {
                if (_isStopped){
                    _local1 = 0;
                } else {
                    if (outputSoundChannel){
                        _local1 = outputSoundChannel.position;
                    } else {
                        _local1 = 0;
                    };
                };
            };
            _isPaused = false;
            _isStopped = false;
            outputSoundChannel = sourceSound.play(_local1);
        }
        public function set position(_arg1:Number):void{
            if (isPaused){
                pausedPosition = _arg1;
            } else {
                this.pause();
                pausedPosition = _arg1;
                this.play();
            };
        }
        public function set volume(_arg1:Number):void{
            var _local2:SoundTransform;
            if (isNaN(_arg1)){
                _arg1 = 0;
            };
            if (_arg1 < 0){
                _arg1 = 0;
            };
            if (_arg1 > 1){
                _arg1 = 1;
            };
            if (_arg1 !== _volume){
                _volume = _arg1;
                if (outputSoundChannel){
                    _local2 = outputSoundChannel.soundTransform;
                    _local2.volume = _arg1;
                    outputSoundChannel.soundTransform = _local2;
                };
            };
        }
        public function get bytesLoaded():uint{
            return (sourceSound.bytesLoaded);
        }
        protected function onIOError(_arg1:IOErrorEvent):void{
            this.stop();
            dispatchEvent(new GSSoundEvent(GSSoundEvent.IO_ERROR));
        }
        protected function onDownloadComplete(_arg1:Event):void{
            dispatchEvent(new GSSoundEvent(GSSoundEvent.DOWNLOAD_COMPLETE));
        }
        public function get isPaused():Boolean{
            return (_isPaused);
        }
        public function get filters():Array{
            return (null);
        }
        public function pause():void{
            _isPaused = true;
            if (outputSoundChannel){
                pausedPosition = outputSoundChannel.position;
                outputSoundChannel.stop();
            };
        }
        public function get url():String{
            return (_url);
        }

    }
}//package com.grooveshark.framework.playback 
﻿package com.grooveshark.framework.playback {
    import flash.events.*;

    public interface IGSSound extends IEventDispatcher {

        function get filters():Array;
        function get isStopped():Boolean;
        function get position():Number;
        function play():void;
        function get url():String;
        function get bytesLoaded():uint;
        function stop():void;
        function set position(_arg1:Number):void;
        function set volume(_arg1:Number):void;
        function set filters(_arg1:Array):void;
        function get isPaused():Boolean;
        function get bytesTotal():int;
        function get volume():Number;
        function get duration():Number;
        function pause():void;
        function get isBuffering():Boolean;

    }
}//package com.grooveshark.framework.playback 
﻿package com.grooveshark.framework.playback {
    import flash.events.*;

    public final class QueueEvent extends Event {

        public static const UNKNOWN_STOPPING:String = "unknownStopping";
        public static const PLAYBACK_ERROR:String = "playbackError";
        public static const FAILED_TO_CREATE_ARTIST_SONGS:String = "failedToCreateArtistSongs";
        public static const NO_SEEDS:String = "noSeeds";
        public static const UNKNOWN_HAS_NEXT:String = "unknownHasNext";
        public static const SONG_FLAGGED:String = "songFlagged";
        public static const UNKNOWN_ERROR:String = "unknownError";
        public static const FAILED_TO_CREATE_SONGS:String = "failedToCreateSongs";
        public static const AUTOPLAY_FAILED:String = "autoplayFailed";
        public static const QUEUE_NOT_READY:String = "queueNotReady";
        public static const FAILED_TO_CREATE_ALBUM_SONGS:String = "failedToCreateAlbumSongs";
        public static const AUTOPLAY_VOTE_ERROR:String = "autoplayVoteError";
        public static const TOO_MANY_SONGS:String = "tooManySongs";
        public static const RATE_LIMIT_EXCEEDED:String = "rateLimitExceeded";
        public static const ERROR_ADDING_SONGS:String = "errorAddingSongs";
        public static const NO_RECOMMENDATIONS:String = "noRecommendations";
        public static const TOO_MANY_FAILURES:String = "tooManyFailures";

        public var detail:String;
        public var notifyUser:Boolean;
        public var extra:Object;

        public function QueueEvent(_arg1:String, _arg2:String="", _arg3:Boolean=false, _arg4:Object=null, _arg5:Boolean=false, _arg6:Boolean=false){
            super(_arg1, _arg5, _arg6);
            this.detail = _arg2;
            this.notifyUser = _arg3;
            this.extra = _arg4;
        }
        override public function clone():Event{
            return (new QueueEvent(this.type, this.detail, this.notifyUser, this.extra, this.bubbles, this.cancelable));
        }

    }
}//package com.grooveshark.framework.playback 
﻿package com.grooveshark.framework.playback {

    public namespace gs_queue;
}//package com.grooveshark.framework.playback 
﻿package com.grooveshark.framework.playback {
    import flash.events.*;
    import mx.events.*;
    import flash.utils.*;
    import com.grooveshark.framework.*;
    import com.grooveshark.jsonrpc.*;
    import com.grooveshark.framework.playback.commands.*;

    public final class QueueSong extends PlayableSong {

        public static const AUTOPLAY_VOTE_NONE:int = 0;
        public static const AUTOPLAY_VOTE_UP:int = 1;
        public static const AUTOPLAY_VOTE_DOWN:int = -1;

        private var _902545055queueSongID:int = 0;
        gs_queue var _autoplayVote:int = 0;
        private var addedToRecent:Boolean = false;
        private var _sponsoredAutoplayID:uint;
        private var _951530927context:Object;
        private var _896505829source:String = "user";
        private var _1363713847eligibleForAutoplayRemoval:Boolean = false;
        private var _995424086parent:Queue;

        public function QueueSong(_arg1:BaseSong, _arg2:Queue, _arg3:IDualService, _arg4:Object=null){
            _951530927context = {
                type:"unknown",
                data:{}
            };
            super(_arg1, _arg3);
            this.addEventListener(PropertyChangeEvent.PROPERTY_CHANGE, onPropChange, false, 0, true);
            this.song.addEventListener(PropertyChangeEvent.PROPERTY_CHANGE, onSongPropChange, false, 0, true);
            this.parent = _arg2;
            this.parent.addEventListener(CollectionEvent.COLLECTION_CHANGE, onQueueCollectionChange, false, 0, true);
            if (_arg4){
                this.context = _arg4;
            };
            if (!this.context.type){
                this.context.type = "unknown";
            };
            if (!this.context.data){
                this.context.data = {};
            };
            if (!this.context.data.client){
                this.context.data.client = _arg3.getClient();
            };
            if (this.context.type == "userRadio"){
                this.source = "userRadio";
            };
            gs_queue::recalcEligibleForAutoplayRemoval();
        }
        private function onQueueCollectionChange(_arg1:CollectionEvent):void{
            gs_queue::recalcEligibleForAutoplayRemoval();
        }
        public function set queueSongID(_arg1:int):void{
            var _local2:Object = this._902545055queueSongID;
            if (_local2 !== _arg1){
                this._902545055queueSongID = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "queueSongID", _local2, _arg1));
            };
        }
        public function set sponsoredAutoplayID(_arg1:uint):void{
            var _local2:Object = this.sponsoredAutoplayID;
            if (_local2 !== _arg1){
                this._1875337257sponsoredAutoplayID = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "sponsoredAutoplayID", _local2, _arg1));
            };
        }
        public function get eligibleForAutoplayRemoval():Boolean{
            return (this._1363713847eligibleForAutoplayRemoval);
        }
        public function set eligibleForAutoplayRemoval(_arg1:Boolean):void{
            var _local2:Object = this._1363713847eligibleForAutoplayRemoval;
            if (_local2 !== _arg1){
                this._1363713847eligibleForAutoplayRemoval = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "eligibleForAutoplayRemoval", _local2, _arg1));
            };
        }
        public function set parent(_arg1:Queue):void{
            var _local2:Object = this._995424086parent;
            if (_local2 !== _arg1){
                this._995424086parent = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "parent", _local2, _arg1));
            };
        }
        public function get sponsoredAutoplayID():uint{
            return (_sponsoredAutoplayID);
        }
        private function onVoteDownTimer(_arg1:TimerEvent):void{
            if ((((((this.autoplayVote == QueueSong.AUTOPLAY_VOTE_DOWN)) && (this.parent))) && (this.parent.contains(this)))){
                this.parent.removeItem(this);
            };
        }
        public function get source():String{
            return (this._896505829source);
        }
        private function set _1640322797autoplayVote(_arg1:int):void{
            var _local2:Timer;
            if (_arg1 != gs_queue::_autoplayVote){
                gs_queue::_autoplayVote = _arg1;
                if (_arg1 == QueueSong.AUTOPLAY_VOTE_DOWN){
                    _local2 = new Timer(10000, 1);
                    _local2.addEventListener(TimerEvent.TIMER_COMPLETE, onVoteDownTimer, false, 0, true);
                    _local2.start();
                    switch (this.playStatus){
                        case PlayableSong.PLAY_STATUS_INITIALIZING:
                        case PlayableSong.PLAY_STATUS_LOADING:
                        case PlayableSong.PLAY_STATUS_PLAYING:
                        case PlayableSong.PLAY_STATUS_BUFFERING:
                            this.playStatus = PlayableSong.PLAY_STATUS_COMPLETED;
                            this.dispatchEvent(new PlayableSongEvent(PlayableSongEvent.COMPLETE, PlayableSongEvent.COMPLETE_FORCE_FROWN_SKIP));
                            break;
                    };
                };
                if (((parent) && (parent.gs_queue::autoplayStatus))){
                    parent.gs_queue::autoplayStatus.songVoted(this);
                };
            };
        }
        public function set context(_arg1:Object):void{
            var _local2:Object = this._951530927context;
            if (_local2 !== _arg1){
                this._951530927context = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "context", _local2, _arg1));
            };
        }
        gs_queue function recalcEligibleForAutoplayRemoval():void{
            var _local1:int;
            if (this.autoplayVote == QueueSong.AUTOPLAY_VOTE_DOWN){
                eligibleForAutoplayRemoval = true;
                return;
            };
            if (((((((!((this.source == "user"))) && (!(this.lastStreamKey)))) && ((this.autoplayVote == QueueSong.AUTOPLAY_VOTE_NONE)))) && (this.parent))){
                _local1 = this.parent.getItemIndex(this);
                this.eligibleForAutoplayRemoval = (_local1 == (parent.length - 1));
                return;
            };
            this.eligibleForAutoplayRemoval = false;
        }
        private function onSongPropChange(_arg1:PropertyChangeEvent):void{
            switch (_arg1.property){
                case "songName":
                    dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "title", _arg1.oldValue, _arg1.newValue));
                    break;
                case "artistName":
                    dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "artist", _arg1.oldValue, _arg1.newValue));
                    break;
                case "artURL":
                    dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "image", _arg1.oldValue, _arg1.newValue));
                    break;
            };
        }
        public function get queueSongID():int{
            return (this._902545055queueSongID);
        }
        public function set autoplayVote(_arg1:int):void{
            var _local2:Object = this.autoplayVote;
            if (_local2 !== _arg1){
                this._1640322797autoplayVote = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "autoplayVote", _local2, _arg1));
            };
        }
        public function get parent():Queue{
            return (this._995424086parent);
        }
        private function set _1875337257sponsoredAutoplayID(_arg1:uint):void{
            _sponsoredAutoplayID = _arg1;
        }
        public function setAutoplayVote(_arg1:int):void{
            var _local2:SongCommand = new VoteSongForAutoplay(service, this, _arg1);
            _local2.execute();
        }
        private function onPropChange(_arg1:PropertyChangeEvent):void{
            switch (_arg1.property){
                case "source":
                case "playStatus":
                case "autoplayVote":
                    gs_queue::recalcEligibleForAutoplayRemoval();
                    break;
            };
        }
        override public function play(_arg1:String="", _arg2:String="", _arg3:int=0, _arg4:Number=0):void{
            this.addedToRecent = false;
            if ((((((this.autoplayVote == QueueSong.AUTOPLAY_VOTE_DOWN)) && (parent))) && (parent.autoplayEnabled))){
                this.playStatus = PlayableSong.PLAY_STATUS_COMPLETED;
                this.dispatchEvent(new PlayableSongEvent(PlayableSongEvent.COMPLETE, PlayableSongEvent.COMPLETE_FORCE_FROWN_SKIP));
                return;
            };
            super.play(_arg1, _arg2, _arg3, _arg4);
        }
        public function get rawAutoplayVote():int{
            return (gs_queue::_autoplayVote);
        }
        public function get autoplayVote():int{
            return ((((((source == "user")) && ((gs_queue::_autoplayVote == AUTOPLAY_VOTE_NONE)))) ? AUTOPLAY_VOTE_UP : gs_queue::_autoplayVote));
        }
        public function set source(_arg1:String):void{
            var _local2:Object = this._896505829source;
            if (_local2 !== _arg1){
                this._896505829source = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "source", _local2, _arg1));
            };
        }
        public function get context():Object{
            return (this._951530927context);
        }

    }
}//package com.grooveshark.framework.playback 
﻿package com.grooveshark.framework.playback {
    import flash.events.*;
    import mx.events.*;

    public class Tag extends EventDispatcher {

        public static const TAG_STATIONS:Array = new Array(new Tag(13, "ALTERNATIVE"), new Tag(75, "AMBIENT"), new Tag(96, "BLUEGRASS"), new Tag(230, "BLUES"), new Tag(750, "CLASSICAL"), new Tag(3529, "CLASSIC_ROCK"), new Tag(80, "COUNTRY"), new Tag(67, "ELECTRONICA"), new Tag(191, "EXPERIMENTAL"), new Tag(122, "FOLK"), new Tag(29, "HIP_HOP"), new Tag(136, "INDIE"), new Tag(43, "JAZZ"), new Tag(528, "LATIN"), new Tag(17, "METAL"), new Tag(102, "OLDIES"), new Tag(56, "POP"), new Tag(111, "PUNK"), new Tag(3, "RAP"), new Tag(160, "REGGAE"), new Tag(4, "RNB"), new Tag(12, "ROCK"), new Tag(69, "TRANCE"));

        private static var _tagIDLookup:Object;

        private var _1549184699tagName:String;
        private var _110119477tagID:uint;

        public function Tag(_arg1:int, _arg2:String){
            tagID = _arg1;
            tagName = _arg2;
        }
        public static function buildLookup():Object{
            var _local2:Tag;
            var _local1:Object = {};
            for each (_local2 in Tag.TAG_STATIONS) {
                _local1[_local2.tagID] = _local2;
            };
            return (_local1);
        }
        public static function get tagIDLookup():Object{
            if (!_tagIDLookup){
                _tagIDLookup = buildLookup();
            };
            return (_tagIDLookup);
        }

        public function set tagID(_arg1:uint):void{
            var _local2:Object = this._110119477tagID;
            if (_local2 !== _arg1){
                this._110119477tagID = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "tagID", _local2, _arg1));
            };
        }
        public function get tagName():String{
            return (this._1549184699tagName);
        }
        public function set tagName(_arg1:String):void{
            var _local2:Object = this._1549184699tagName;
            if (_local2 !== _arg1){
                this._1549184699tagName = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "tagName", _local2, _arg1));
            };
        }
        override public function toString():String{
            return (((("[Tag] " + this.tagID) + ":") + this.tagName));
        }
        public function get tagID():uint{
            return (this._110119477tagID);
        }

    }
}//package com.grooveshark.framework.playback 
﻿package com.grooveshark.framework.playback {
    import flash.events.*;

    public final class GSSoundEvent extends Event {

        public static const URL_CHANGED:String = "urlChanged";
        public static const BUFFER_FULL:String = "bufferFull";
        public static const IO_ERROR:String = "ioError";
        public static const DOWNLOAD_COMPLETE:String = "downloadComplete";
        public static const BUFFER_EMPTY:String = "bufferEmpty";
        public static const PLAYBACK_BEGUN:String = "playbackBegun";
        public static const PLAYBACK_COMPLETE:String = "playbackComplete";

        public function GSSoundEvent(_arg1:String, _arg2:Boolean=false, _arg3:Boolean=false){
            super(_arg1, _arg2, _arg3);
        }
        override public function clone():Event{
            return (new GSSoundEvent(this.type, this.bubbles, this.cancelable));
        }

    }
}//package com.grooveshark.framework.playback 
﻿package com.grooveshark.framework.playback {
    import flash.events.*;
    import mx.events.*;
    import flash.utils.*;
    import com.grooveshark.framework.*;
    import com.grooveshark.jsonrpc.*;
    import mx.collections.*;
    import flash.net.*;
    import com.grooveshark.framework.playback.commands.*;

    public class PlayableSong extends EventDispatcher {

        public static const PLAY_STATUS_COMPLETED:int = 7;
        private static const PASSTHROUGH_PROP:Array = ["songName", "songID", "artistName", "artistID", "albumName", "albumID", "trackNum", "popularity", "isArtistVerified", "isAlbumVerified", "isFavorite", "token"];
        public static const PLAY_STATUS_PAUSED:int = 4;
        public static const MIN_BUFFER_SIZE:int = 3000;
        public static const PLAY_STATUS_NONE:int = 0;
        public static const PLAY_STATUS_FAILED:int = 6;
        public static const MAX_BUFFER_SIZE:int = 20000;
        public static const PLAY_STATUS_BUFFERING:int = 5;
        public static const PLAY_STATUS_INITIALIZING:int = 1;
        public static const PLAY_STATUS_PLAYING:int = 3;
        public static const PLAY_STATUS_LOADING:int = 2;

        private static var _1705597599useStagingScript:Boolean = false;
        private static var _705511159useMobile:Boolean = false;
        private static var _staticBindingEventDispatcher:EventDispatcher = new EventDispatcher();
        private static var _1444110662currentBufferSize:int = 3000;
        private static var _1662479664userForReporting:Object = null;
        private static var _603662715consecutiveFailedStreamKeys:int = 0;
        private static var _1498006282checkPolicyFile:Boolean = false;

        protected var playbackReported:Boolean = false;
        protected var _sound:IGSSound;
        protected var streamWatcher:Timer;
        private var _747804969position:Number = 0;
        protected var completeReported:Boolean = false;
        protected var noBufferCount:int = 0;
        private var _102002428currentStreamServer:String;
        private var _soundVolume:Number = 1;
        private var _1992012396duration:Number = 0;
        private var _1045430530thirtySecReported:Boolean = false;
        private var _1596130465fileLoaded:Boolean = false;
        private var _1582764102playStatus:int = 0;
        private var _2110014263lastStreamKey:String = "";
        protected var pausedPosition:int = 0;
        private var _1653441605secondsListened:Number = 0;
        private var _fadeTimerDown:Timer;
        protected var consecutiveBadFrames:int = 0;
        protected var downloadReported:Boolean = false;
        protected var isBuffering:Boolean = false;
        protected var bufferCount:int = 0;
        protected var service:IDualService;
        private var fadeAmountDown:Number = 600;
        private var _filters:Array;
        private var _341347244lastServerID:int;
        private var fadeAmountUp:Number = 1500;
        protected var playOnStreamKey:Boolean = false;
        private var fadeInOut:Boolean = false;
        private var _326983600bytesLoaded:Number = 0;
        private var _1382331801bytesTotal:Number = 0;
        protected var lastPosition:int = 0;
        private var _fadeTimerUp:Timer;
        private var _3536149song:BaseSong;
        protected var cancelPendingPlayback:Boolean = false;

        public function PlayableSong(_arg1:BaseSong, _arg2:IDualService){
            this.song = _arg1;
            if (_arg1.estimateDuration){
                this.duration = _arg1.estimateDuration;
            };
            _arg1.addEventListener(PropertyChangeEvent.PROPERTY_CHANGE, songPropChange);
            this.service = _arg2;
            this.streamWatcher = new Timer(500);
            this.streamWatcher.addEventListener(TimerEvent.TIMER, onStreamPoll);
        }
        public static function get currentBufferSize():int{
            return (PlayableSong._1444110662currentBufferSize);
        }
        public static function get consecutiveFailedStreamKeys():int{
            return (PlayableSong._603662715consecutiveFailedStreamKeys);
        }
        public static function set currentBufferSize(_arg1:int):void{
            var _local3:IEventDispatcher;
            var _local2:Object = PlayableSong._1444110662currentBufferSize;
            if (_local2 !== _arg1){
                PlayableSong._1444110662currentBufferSize = _arg1;
                _local3 = PlayableSong.staticEventDispatcher;
                if (_local3 != null){
                    _local3.dispatchEvent(PropertyChangeEvent.createUpdateEvent(PlayableSong, "currentBufferSize", _local2, _arg1));
                };
            };
        }
        public static function set checkPolicyFile(_arg1:Boolean):void{
            var _local3:IEventDispatcher;
            var _local2:Object = PlayableSong._1498006282checkPolicyFile;
            if (_local2 !== _arg1){
                PlayableSong._1498006282checkPolicyFile = _arg1;
                _local3 = PlayableSong.staticEventDispatcher;
                if (_local3 != null){
                    _local3.dispatchEvent(PropertyChangeEvent.createUpdateEvent(PlayableSong, "checkPolicyFile", _local2, _arg1));
                };
            };
        }
        public static function get userForReporting():Object{
            return (PlayableSong._1662479664userForReporting);
        }
        public static function set useMobile(_arg1:Boolean):void{
            var _local3:IEventDispatcher;
            var _local2:Object = PlayableSong._705511159useMobile;
            if (_local2 !== _arg1){
                PlayableSong._705511159useMobile = _arg1;
                _local3 = PlayableSong.staticEventDispatcher;
                if (_local3 != null){
                    _local3.dispatchEvent(PropertyChangeEvent.createUpdateEvent(PlayableSong, "useMobile", _local2, _arg1));
                };
            };
        }
        public static function get useMobile():Boolean{
            return (PlayableSong._705511159useMobile);
        }
        public static function set userForReporting(_arg1:Object):void{
            var _local3:IEventDispatcher;
            var _local2:Object = PlayableSong._1662479664userForReporting;
            if (_local2 !== _arg1){
                PlayableSong._1662479664userForReporting = _arg1;
                _local3 = PlayableSong.staticEventDispatcher;
                if (_local3 != null){
                    _local3.dispatchEvent(PropertyChangeEvent.createUpdateEvent(PlayableSong, "userForReporting", _local2, _arg1));
                };
            };
        }
        public static function set useStagingScript(_arg1:Boolean):void{
            var _local3:IEventDispatcher;
            var _local2:Object = PlayableSong._1705597599useStagingScript;
            if (_local2 !== _arg1){
                PlayableSong._1705597599useStagingScript = _arg1;
                _local3 = PlayableSong.staticEventDispatcher;
                if (_local3 != null){
                    _local3.dispatchEvent(PropertyChangeEvent.createUpdateEvent(PlayableSong, "useStagingScript", _local2, _arg1));
                };
            };
        }
        public static function get staticEventDispatcher():IEventDispatcher{
            return (_staticBindingEventDispatcher);
        }
        public static function set consecutiveFailedStreamKeys(_arg1:int):void{
            var _local3:IEventDispatcher;
            var _local2:Object = PlayableSong._603662715consecutiveFailedStreamKeys;
            if (_local2 !== _arg1){
                PlayableSong._603662715consecutiveFailedStreamKeys = _arg1;
                _local3 = PlayableSong.staticEventDispatcher;
                if (_local3 != null){
                    _local3.dispatchEvent(PropertyChangeEvent.createUpdateEvent(PlayableSong, "consecutiveFailedStreamKeys", _local2, _arg1));
                };
            };
        }
        public static function get useStagingScript():Boolean{
            return (PlayableSong._1705597599useStagingScript);
        }
        public static function get checkPolicyFile():Boolean{
            return (PlayableSong._1498006282checkPolicyFile);
        }

        public function get token():String{
            return (((((song) && (song.token))) ? song.token : ""));
        }
        public function stop():void{
            this.streamWatcher.stop();
            if (this.sound){
                this.sound.stop();
            };
            this.sound = null;
            this.cancelPendingPlayback = true;
            switch (this.playStatus){
                case PlayableSong.PLAY_STATUS_COMPLETED:
                case PlayableSong.PLAY_STATUS_FAILED:
                    break;
                default:
                    this.playStatus = PlayableSong.PLAY_STATUS_NONE;
            };
        }
        public function set thirtySecReported(_arg1:Boolean):void{
            var _local2:Object = this._1045430530thirtySecReported;
            if (_local2 !== _arg1){
                this._1045430530thirtySecReported = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "thirtySecReported", _local2, _arg1));
            };
        }
        public function set filters(_arg1:Array):void{
            var _local2:Object = this.filters;
            if (_local2 !== _arg1){
                this._854547461filters = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "filters", _local2, _arg1));
            };
        }
        public function get sound():IGSSound{
            return (_sound);
        }
        public function get thirtySecReported():Boolean{
            return (this._1045430530thirtySecReported);
        }
        public function set soundVolume(_arg1:Number):void{
            var _local2:Object = this.soundVolume;
            if (_local2 !== _arg1){
                this._2006668553soundVolume = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "soundVolume", _local2, _arg1));
            };
        }
        public function seekTo(_arg1:int):void{
            if (_arg1 < 0){
                _arg1 = 0;
            };
            this.playSoundFrom(_arg1, true);
        }
        public function get song():BaseSong{
            return (this._3536149song);
        }
        public function get soundVolume():Number{
            return (_soundVolume);
        }
        public function set sound(_arg1:IGSSound):void{
            var _local2:Object = this.sound;
            if (_local2 !== _arg1){
                this._109627663sound = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "sound", _local2, _arg1));
            };
        }
        private function set _854547461filters(_arg1:Array):void{
            _filters = _arg1;
            if (_sound){
                _sound.filters = _arg1;
            };
        }
        public function set duration(_arg1:Number):void{
            var _local2:Object = this._1992012396duration;
            if (_local2 !== _arg1){
                this._1992012396duration = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "duration", _local2, _arg1));
            };
        }
        public function get position():Number{
            return (this._747804969position);
        }
        public function set song(_arg1:BaseSong):void{
            var _local2:Object = this._3536149song;
            if (_local2 !== _arg1){
                this._3536149song = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "song", _local2, _arg1));
            };
        }
        protected function set _563277148fadeTimerUp(_arg1:Timer):void{
            if (_arg1 !== _fadeTimerUp){
                if (_fadeTimerUp){
                    _fadeTimerUp.removeEventListener(TimerEvent.TIMER, fadeInterval);
                    _fadeTimerUp.removeEventListener(TimerEvent.TIMER_COMPLETE, fadeStop);
                };
                _fadeTimerUp = _arg1;
                if (_fadeTimerUp){
                    _fadeTimerUp.addEventListener(TimerEvent.TIMER, fadeInterval);
                    _fadeTimerUp.addEventListener(TimerEvent.TIMER_COMPLETE, fadeStop);
                };
            };
        }
        public function resume():void{
            if (((_sound) && ((this.playStatus == PlayableSong.PLAY_STATUS_PAUSED)))){
                playSoundFrom(_sound.position);
            };
        }
        public function fadeOut():void{
            if (this._fadeTimerDown){
                if (this._fadeTimerDown.running){
                    this._fadeTimerDown.stop();
                };
                if (this._fadeTimerUp.running){
                    this._fadeTimerUp.stop();
                };
                this._fadeTimerDown.reset();
                this._fadeTimerDown.start();
            };
        }
        public function play(_arg1:String="", _arg2:String="", _arg3:int=0, _arg4:Number=0):void{
            switch (this.playStatus){
                case PlayableSong.PLAY_STATUS_INITIALIZING:
                    playOnStreamKey = true;
                    return;
                case PlayableSong.PLAY_STATUS_BUFFERING:
                case PlayableSong.PLAY_STATUS_PLAYING:
                    if (this.position < 5){
                        return;
                    };
                    break;
            };
            if (((_sound) && (!(this.thirtySecReported)))){
                playSoundFrom(0);
            } else {
                playOnStreamKey = true;
                fetchNewStreamKey(_arg1, _arg2, _arg3, _arg4);
            };
        }
        public function get popularity():Number{
            return (((((song) && (song.hasOwnProperty("popularity")))) ? song["popularity"] : 0));
        }
        public function set bytesTotal(_arg1:Number):void{
            var _local2:Object = this._1382331801bytesTotal;
            if (_local2 !== _arg1){
                this._1382331801bytesTotal = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "bytesTotal", _local2, _arg1));
            };
        }
        public function get trackNum():int{
            return (((song) ? song.trackNum : 0));
        }
        protected function set _143963541fadeTimerDown(_arg1:Timer):void{
            if (_arg1 !== _fadeTimerDown){
                if (_fadeTimerDown){
                    _fadeTimerDown.removeEventListener(TimerEvent.TIMER, fadeInterval);
                    _fadeTimerDown.removeEventListener(TimerEvent.TIMER_COMPLETE, fadeStop);
                };
                _fadeTimerDown = _arg1;
                if (_fadeTimerDown){
                    _fadeTimerDown.addEventListener(TimerEvent.TIMER, fadeInterval);
                    _fadeTimerDown.addEventListener(TimerEvent.TIMER_COMPLETE, fadeStop);
                };
            };
        }
        public function set fileLoaded(_arg1:Boolean):void{
            var _local2:Object = this._1596130465fileLoaded;
            if (_local2 !== _arg1){
                this._1596130465fileLoaded = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "fileLoaded", _local2, _arg1));
            };
        }
        public function get secondsListened():Number{
            return (this._1653441605secondsListened);
        }
        public function get playStatus():int{
            return (this._1582764102playStatus);
        }
        public function get songName():String{
            return (((song) ? song.songName : ""));
        }
        public function get isAlbumVerified():int{
            return (((((song) && (song.hasOwnProperty("isAlbumVerified")))) ? song["isAlbumVerified"] : -1));
        }
        protected function set fadeTimerUp(_arg1:Timer):void{
            var _local2:Object = this.fadeTimerUp;
            if (_local2 !== _arg1){
                this._563277148fadeTimerUp = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "fadeTimerUp", _local2, _arg1));
            };
        }
        public function get bytesLoaded():Number{
            return (this._326983600bytesLoaded);
        }
        public function set position(_arg1:Number):void{
            var _local2:Object = this._747804969position;
            if (_local2 !== _arg1){
                this._747804969position = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "position", _local2, _arg1));
            };
        }
        public function get lastServerID():int{
            return (this._341347244lastServerID);
        }
        private function onSongFailure(_arg1:int):void{
            this.streamWatcher.stop();
            if (this.sound){
                this.sound.stop();
            };
            this.sound = null;
            var _local2:int = this.playStatus;
            this.playStatus = PlayableSong.PLAY_STATUS_FAILED;
            dispatchEvent(new PlayableSongEvent(PlayableSongEvent.ERROR, _arg1, _local2));
        }
        public function fadeInterval(_arg1:TimerEvent=null):void{
            var _local2:Number;
            var _local3:Number;
            if (this.playStatus == PlayableSong.PLAY_STATUS_PAUSED){
                _local2 = (1 / ((Queue.CROSSFADE_STEPS * this.fadeAmountDown) / 1000));
                this.soundVolume = (((this.soundVolume >= _local2)) ? (this.soundVolume - _local2) : 0);
                this.pausedPosition = (this.position = _sound.position);
            } else {
                if (this.playStatus == PlayableSong.PLAY_STATUS_PLAYING){
                    _local3 = (1 / ((Queue.CROSSFADE_STEPS * this.fadeAmountUp) / 1000));
                    this.soundVolume = (((this.soundVolume <= (1 - _local3))) ? (this.soundVolume + _local3) : 1);
                };
            };
        }
        protected function get fadeTimerDown():Timer{
            return (_fadeTimerDown);
        }
        public function flag(_arg1:int):void{
            var _local2:FlagSong = new FlagSong(service, this);
            _local2.flagReason = _arg1;
            _local2.execute();
        }
        protected function loadSoundObject(_arg1:String, _arg2:Object, _arg3:Boolean=false):void{
            var _local5:String;
            var _local6:URLRequest;
            var _local7:SongCommand;
            var _local4:URLVariables = new URLVariables();
            for (_local5 in _arg2) {
                _local4[_local5] = _arg2[_local5];
            };
            _local6 = new URLRequest(_arg1);
            _local6.method = URLRequestMethod.POST;
            _local6.data = _local4;
            this.sound = new GSSound9(_local6, PlayableSong.currentBufferSize, PlayableSong.checkPolicyFile);
            this.playStatus = PlayableSong.PLAY_STATUS_LOADING;
            this.isBuffering = false;
            this.fileLoaded = false;
            this.streamWatcher.reset();
            this.streamWatcher.start();
            if (_arg3){
                playSoundFrom(0);
            };
            if (!this.downloadReported){
                _local7 = new MarkSongDownloaded(service, this);
                _local7.execute();
                this.downloadReported = true;
            };
        }
        public function get artistName():String{
            return (((song) ? song.artistName : ""));
        }
        private function onUrlChanged(_arg1:Event):void{
            var _local3:int;
            var _local2:String = (_arg1.currentTarget as IGSSound).url;
            if (_local2){
                _local3 = _local2.indexOf("/stream.php");
                if (_local3 != -1){
                    this.currentStreamServer = _local2.substring(0, _local3);
                };
            };
        }
        protected function playSoundFrom(_arg1:int, _arg2:Boolean=false):void{
            if (_sound){
                if (_arg1 < 0){
                    _arg1 = 0;
                };
                _sound.position = _arg1;
                this.position = (this.lastPosition = (this.pausedPosition = _sound.position));
                if (((!(_arg2)) && (((((_sound.isPaused) || (_sound.isStopped))) || (((this._fadeTimerDown) && (this._fadeTimerDown.running))))))){
                    if (this.fadeInOut){
                        _sound.play();
                        this.fadeIn();
                    } else {
                        _sound.play();
                    };
                };
                if (((((!(_sound.isPaused)) && (!(_sound.isStopped)))) && (!((_sound.position == _sound.duration))))){
                    if (!this.streamWatcher.running){
                        this.streamWatcher.reset();
                        this.streamWatcher.start();
                    };
                    this.playStatus = PlayableSong.PLAY_STATUS_PLAYING;
                };
            };
        }
        private function getStreamKeyResult(_arg1:Object, _arg2:Object=null):void{
            var _local4:String;
            var _local5:String;
            var _local6:int;
            var _local7:String;
            var _local8:Number;
            var _local9:String;
            var _local3:JSONResult = (_arg1 as JSONResult);
            if (((((_local3) && (_local3.result))) && (!(this.cancelPendingPlayback)))){
                _local4 = (_local3.result.streamKey as String);
                _local5 = (_local3.result.ip as String);
                _local6 = int(_local3.result.streamServerID);
                _local7 = (_local3.result.FileToken as String);
                _local8 = Number(_local3.result.uSecs);
                if ((((_local4 == "false")) && (Boolean(_arg2.prefetch)))){
                    if (this.playOnStreamKey){
                        this.playStatus = PlayableSong.PLAY_STATUS_NONE;
                        this.play();
                        return;
                    };
                    return;
                };
                if ((((((((_local4 == "false")) || ((_local4 == "null")))) || ((_local5 == "null")))) || (!(_local6)))){
                    PlayableSong.consecutiveFailedStreamKeys++;
                    onSongFailure(PlayableSongEvent.FAILED_STREAMKEY_OTHER);
                    trace("[PlayableSong] Error fetching streamKey: Result came back null.");
                    return;
                };
                if (PlayableSong.useStagingScript){
                    _local5 = ("staging." + _local5);
                };
                _local9 = (("http://" + _local5) + "/stream.php");
                this.lastStreamKey = _local4;
                this.lastServerID = _local6;
                this.currentStreamServer = ("http://" + _local5);
                loadSoundObject(_local9, {streamKey:_local4}, this.playOnStreamKey);
                PlayableSong.consecutiveFailedStreamKeys = 0;
                if (((((this.song.hasOwnProperty("token")) && (_local7))) && (!((_local7 == "null"))))){
                    this.song["token"] = _local7;
                };
                if (_local8){
                    this.duration = (this.song.estimateDuration = (_local8 / 1000));
                };
            } else {
                if (((!(_local3)) || (!(_local3.result)))){
                    PlayableSong.consecutiveFailedStreamKeys++;
                    onSongFailure(PlayableSongEvent.FAILED_STREAMKEY_OTHER);
                    trace("[PlayableSong] Error fetching streamKey: Empty result set");
                };
            };
        }
        public function set playStatus(_arg1:int):void{
            var _local2:Object = this._1582764102playStatus;
            if (_local2 !== _arg1){
                this._1582764102playStatus = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "playStatus", _local2, _arg1));
            };
        }
        override public function toString():String{
            return (((("[PlayableSong] " + song.songID) + ":") + song.songName));
        }
        public function set secondsListened(_arg1:Number):void{
            var _local2:Object = this._1653441605secondsListened;
            if (_local2 !== _arg1){
                this._1653441605secondsListened = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "secondsListened", _local2, _arg1));
            };
        }
        public function set lastStreamKey(_arg1:String):void{
            var _local2:Object = this._2110014263lastStreamKey;
            if (_local2 !== _arg1){
                this._2110014263lastStreamKey = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "lastStreamKey", _local2, _arg1));
            };
        }
        private function set _2006668553soundVolume(_arg1:Number):void{
            if (_arg1 !== _soundVolume){
                _soundVolume = _arg1;
                if (_sound){
                    _sound.volume = _arg1;
                };
            };
        }
        private function getStreamKeyFault(_arg1:Object, _arg2:Object=null):void{
            PlayableSong.consecutiveFailedStreamKeys++;
            var _local3:JSONFault = (_arg1 as JSONFault);
            if (_local3.code == 0x0200){
                onSongFailure(PlayableSongEvent.FAILED_STREAMKEY_LIMIT);
            } else {
                onSongFailure(PlayableSongEvent.FAILED_STREAMKEY_OTHER);
            };
            trace(("[PlayableSong] Error fetching streamKey: " + _local3.message), ("Raw result: " + _local3.rawResult));
        }
        public function get duration():Number{
            return (this._1992012396duration);
        }
        public function fadeStop(_arg1:TimerEvent=null):void{
            if (this.playStatus == PlayableSong.PLAY_STATUS_PAUSED){
                _sound.pause();
                this.soundVolume = 0;
                this.pausedPosition = (this.position = _sound.position);
            } else {
                if (this.playStatus == PlayableSong.PLAY_STATUS_PLAYING){
                    this.soundVolume = 1;
                };
            };
        }
        public function set bytesLoaded(_arg1:Number):void{
            var _local2:Object = this._326983600bytesLoaded;
            if (_local2 !== _arg1){
                this._326983600bytesLoaded = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "bytesLoaded", _local2, _arg1));
            };
        }
        public function get albumName():String{
            return (((song) ? song.albumName : ""));
        }
        protected function get fadeTimerUp():Timer{
            return (_fadeTimerUp);
        }
        private function onStreamPoll(_arg1:TimerEvent):void{
            var _local2:int;
            var _local3:SongCommand;
            var _local4:int;
            if (this.sound){
                if (this.isBuffering != this.sound.isBuffering){
                    if (this.sound.isBuffering){
                        if (((((!((this.playStatus == PlayableSong.PLAY_STATUS_INITIALIZING))) && (!((this.playStatus == PlayableSong.PLAY_STATUS_LOADING))))) && ((this.position > 0)))){
                            PlayableSong.currentBufferSize = (PlayableSong.currentBufferSize + 3000);
                            this.bufferCount++;
                            this.noBufferCount = 0;
                            if (PlayableSong.currentBufferSize > PlayableSong.MAX_BUFFER_SIZE){
                                PlayableSong.currentBufferSize = PlayableSong.MAX_BUFFER_SIZE;
                                if (this.bufferCount > 5){
                                    dispatchEvent(new PlayableSongEvent(PlayableSongEvent.ERROR, PlayableSongEvent.WARNING_FREQUENT_BUFFERING));
                                };
                            };
                        };
                        if (this.playStatus != PlayableSong.PLAY_STATUS_LOADING){
                            this.playStatus = PlayableSong.PLAY_STATUS_BUFFERING;
                        };
                    };
                    isBuffering = this.sound.isBuffering;
                };
                if (((((((!(this.sound.isBuffering)) && (!(this.sound.isPaused)))) && (!(this.sound.isStopped)))) && (((!(this._fadeTimerDown)) || (!(this._fadeTimerDown.running)))))){
                    this.playStatus = PlayableSong.PLAY_STATUS_PLAYING;
                };
                this.bytesLoaded = this.sound.bytesLoaded;
                this.bytesTotal = this.sound.bytesTotal;
                _local2 = this.sound.duration;
                if (this.playStatus != PlayableSong.PLAY_STATUS_PAUSED){
                    this.position = this.sound.position;
                };
                if ((((((this.playStatus == PlayableSong.PLAY_STATUS_PLAYING)) && ((this.position > this.lastPosition)))) && (((this.position + (PlayableSong.currentBufferSize * 1.5)) < this.sound.duration)))){
                    this.noBufferCount++;
                    if ((this.noBufferCount % 70) == 0){
                        PlayableSong.currentBufferSize = (PlayableSong.currentBufferSize - 4000);
                        if (PlayableSong.currentBufferSize < PlayableSong.MIN_BUFFER_SIZE){
                            PlayableSong.currentBufferSize = PlayableSong.MIN_BUFFER_SIZE;
                        };
                    };
                };
                if (((!(this.playbackReported)) && ((this.playStatus == PlayableSong.PLAY_STATUS_PLAYING)))){
                    this.dispatchEvent(new PlayableSongEvent(PlayableSongEvent.PLAYBACK_BEGUN));
                    _local3 = new MarkSongPlayed(service, this);
                    _local3.execute();
                    this.playbackReported = true;
                };
                if ((((this.duration == 0)) && (!(this.fileLoaded)))){
                    this.duration = _local2;
                };
                if (((((((!((this.position == 0))) && ((this.position == this.lastPosition)))) && ((this.playStatus == PlayableSong.PLAY_STATUS_PLAYING)))) && (this.fileLoaded))){
                    if ((_local2 - position) > 5000){
                        if (this.consecutiveBadFrames > 4){
                            onSongFailure(PlayableSongEvent.FAILED_TOO_MANY_BAD_FRAMES);
                        } else {
                            this.consecutiveBadFrames++;
                            switch (this.consecutiveBadFrames){
                                case 0:
                                default:
                                    _local4 = 10;
                                    break;
                                case 1:
                                    _local4 = 100;
                                    break;
                                case 2:
                                    _local4 = 250;
                                    break;
                                case 3:
                                    _local4 = 500;
                                    break;
                                case 4:
                                    _local4 = 1000;
                            };
                            trace((("[PlayableSong] Bad frame? Skipping " + _local4) + "ms"));
                            this.lastPosition = (this.position + _local4);
                            playSoundFrom(lastPosition);
                        };
                    } else {
                        trace("[PlayableSong] VBR Fake Stop");
                        onSoundComplete();
                    };
                } else {
                    this.consecutiveBadFrames = 0;
                    if (((((!((this.position == this.lastPosition))) && (!((this.position == 0))))) && ((this.playStatus == PlayableSong.PLAY_STATUS_PLAYING)))){
                        this.secondsListened = (this.secondsListened + 0.5);
                        if ((((this.secondsListened > 30)) && (!(this.thirtySecReported)))){
                            _local3 = new MarkSongOver30Seconds(service, this);
                            _local3.execute();
                            this.thirtySecReported = true;
                        };
                    };
                    this.lastPosition = this.position;
                };
            };
        }
        public function get bytesTotal():Number{
            return (this._1382331801bytesTotal);
        }
        public function get fileLoaded():Boolean{
            return (this._1596130465fileLoaded);
        }
        public function set lastServerID(_arg1:int):void{
            var _local2:Object = this._341347244lastServerID;
            if (_local2 !== _arg1){
                this._341347244lastServerID = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "lastServerID", _local2, _arg1));
            };
        }
        private function set _109627663sound(_arg1:IGSSound):void{
            if (_arg1 != _sound){
                if (_sound){
                    _sound.stop();
                    _sound.removeEventListener(GSSoundEvent.URL_CHANGED, onUrlChanged);
                    _sound.removeEventListener(GSSoundEvent.DOWNLOAD_COMPLETE, onDownloadComplete);
                    _sound.removeEventListener(GSSoundEvent.PLAYBACK_COMPLETE, onSoundComplete);
                    _sound.removeEventListener(GSSoundEvent.IO_ERROR, onIOError);
                };
                _sound = _arg1;
                if (_sound){
                    _sound.addEventListener(GSSoundEvent.URL_CHANGED, onUrlChanged, false, 0, true);
                    _sound.addEventListener(GSSoundEvent.DOWNLOAD_COMPLETE, onDownloadComplete, false, 0, true);
                    _sound.addEventListener(GSSoundEvent.PLAYBACK_COMPLETE, onSoundComplete, false, 0, true);
                    _sound.addEventListener(GSSoundEvent.IO_ERROR, onIOError, false, 0, true);
                    _sound.volume = _soundVolume;
                    _sound.filters = _filters;
                };
            };
        }
        public function setFadeOptions(_arg1:Boolean=false, _arg2:Number=1500, _arg3:Number=600):void{
            if (this.fadeAmountUp != _arg2){
                this.fadeAmountUp = _arg2;
            };
            if (this.fadeAmountDown != _arg3){
                this.fadeAmountDown = _arg3;
            };
            if (this.fadeInOut != _arg1){
                this.fadeInOut = _arg1;
                if (_arg1){
                    this.fadeTimerDown = new Timer(((1 / Queue.CROSSFADE_STEPS) * 1000), ((Queue.CROSSFADE_STEPS * this.fadeAmountDown) / 1000));
                    this.fadeTimerUp = new Timer(((1 / Queue.CROSSFADE_STEPS) * 1000), ((Queue.CROSSFADE_STEPS * this.fadeAmountUp) / 1000));
                } else {
                    this.fadeTimerDown = null;
                    this.fadeTimerUp = null;
                };
            };
        }
        private function onIOError(_arg1:Event):void{
            trace(("[PlayableSong] IOError: " + _arg1));
            onSongFailure(PlayableSongEvent.FAILED_IO_ERROR);
        }
        public function fadeIn():void{
            if (this._fadeTimerUp){
                if (this._fadeTimerUp.running){
                    this._fadeTimerUp.stop();
                };
                if (this._fadeTimerDown.running){
                    this._fadeTimerDown.stop();
                };
                this._fadeTimerUp.reset();
                this._fadeTimerUp.start();
            };
        }
        private function onSoundComplete(_arg1:Event=null):void{
            var _local2:int;
            var _local3:SongCommand;
            trace(("[PlayableSong] onSoundComplete: " + _arg1));
            this.streamWatcher.stop();
            this.playStatus = PlayableSong.PLAY_STATUS_COMPLETED;
            PlayableSong.currentBufferSize = (PlayableSong.currentBufferSize - 1000);
            if (PlayableSong.currentBufferSize < PlayableSong.MIN_BUFFER_SIZE){
                PlayableSong.currentBufferSize = PlayableSong.MIN_BUFFER_SIZE;
            };
            if (!this.completeReported){
                _local3 = new MarkSongComplete(service, this);
                _local3.execute();
                completeReported = true;
            };
            if (_arg1){
                _local2 = PlayableSongEvent.COMPLETE_SOUND_COMPLETE;
            } else {
                _local2 = PlayableSongEvent.COMPLETE_VBR_COMPLETE;
            };
            dispatchEvent(new PlayableSongEvent(PlayableSongEvent.COMPLETE, _local2));
        }
        public function get lastStreamKey():String{
            return (this._2110014263lastStreamKey);
        }
        protected function fetchNewStreamKey(_arg1:String="", _arg2:String="", _arg3:int=0, _arg4:Number=0):void{
            var _local5:JSONResult;
            this.sound = null;
            this.lastStreamKey = "";
            this.lastServerID = 0;
            this.secondsListened = 0;
            this.downloadReported = false;
            this.playbackReported = false;
            this.thirtySecReported = false;
            this.completeReported = false;
            this.position = 0;
            this.bytesLoaded = 0;
            this.bytesTotal = 0;
            this.consecutiveBadFrames = 0;
            this.bufferCount = 0;
            this.noBufferCount = 0;
            this.cancelPendingPlayback = false;
            this.playStatus = PlayableSong.PLAY_STATUS_INITIALIZING;
            if (((((_arg1) && (_arg2))) && (_arg3))){
                _local5 = new JSONResult();
                _local5.result = {
                    streamKey:_arg1,
                    ip:_arg2,
                    streamServerID:_arg3,
                    FileToken:"",
                    uSecs:0
                };
                getStreamKeyResult(_local5, {prefetch:!(playOnStreamKey)});
            } else {
                if (song.songID === 0){
                    dispatchEvent(new PlayableSongEvent(PlayableSongEvent.ERROR, PlayableSongEvent.FAILED_MUST_PROVIDE_STREAMKEY));
                } else {
                    if (PlayableSong.consecutiveFailedStreamKeys > 4){
                        this.playStatus = PlayableSong.PLAY_STATUS_NONE;
                        PlayableSong.consecutiveFailedStreamKeys = 0;
                        dispatchEvent(new PlayableSongEvent(PlayableSongEvent.ERROR, PlayableSongEvent.FAILED_TOO_MANY_STREAMKEY_FAILS));
                    } else {
                        service.send(false, "getStreamKeyFromSongIDEx", {
                            songID:song.songID,
                            prefetch:!(this.playOnStreamKey),
                            country:service.country,
                            mobile:PlayableSong.useMobile
                        }, new ItemResponder(getStreamKeyResult, getStreamKeyFault, {prefetch:!(this.playOnStreamKey)}));
                    };
                };
            };
        }
        protected function set fadeTimerDown(_arg1:Timer):void{
            var _local2:Object = this.fadeTimerDown;
            if (_local2 !== _arg1){
                this._143963541fadeTimerDown = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "fadeTimerDown", _local2, _arg1));
            };
        }
        public function load(_arg1:String="", _arg2:String="", _arg3:int=0, _arg4:Number=0):void{
            if (this.playStatus == PlayableSong.PLAY_STATUS_INITIALIZING){
                return;
            };
            if (((this.sound) && (!(this.thirtySecReported)))){
                return;
            };
            playOnStreamKey = false;
            fetchNewStreamKey(_arg1, _arg2, _arg3, _arg4);
        }
        private function songPropChange(_arg1:PropertyChangeEvent):void{
            if (PlayableSong.PASSTHROUGH_PROP.indexOf(_arg1.property) != -1){
                dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, _arg1.property, _arg1.oldValue, _arg1.newValue));
            };
        }
        public function get isFavorite():Boolean{
            return (((((song) && (song.hasOwnProperty("isFavorite")))) ? song["isFavorite"] : false));
        }
        private function onDownloadComplete(_arg1:Event):void{
            var _local2:int;
            var _local3:SongCommand;
            trace(((("[PlayableSong] onDownloadComplete: " + _arg1) + ", duration: ") + sound.duration));
            this.fileLoaded = true;
            if (this.sound){
                if (this.sound.duration == 0){
                    this.sound.stop();
                    this.sound = null;
                    _local2 = this.playStatus;
                    this.playStatus = PlayableSong.PLAY_STATUS_FAILED;
                    dispatchEvent(new PlayableSongEvent(PlayableSongEvent.ERROR, PlayableSongEvent.FAILED_IO_ERROR, _local2));
                } else {
                    this.duration = this.sound.duration;
                    if (Math.abs((this.song.estimateDuration - this.duration)) > 999){
                        _local3 = new ReportCorrectDuration(service, this);
                        _local3.execute();
                    };
                };
            };
        }
        public function get isArtistVerified():int{
            return (((((song) && (song.hasOwnProperty("isArtistVerified")))) ? song["isArtistVerified"] : -1));
        }
        public function get filters():Array{
            return (((_sound) ? _sound.filters : null));
        }
        public function get currentStreamServer():String{
            return (this._102002428currentStreamServer);
        }
        public function pause():void{
            if (_sound){
                if (this.fadeInOut){
                    this.fadeOut();
                } else {
                    _sound.pause();
                };
                this.playStatus = PlayableSong.PLAY_STATUS_PAUSED;
            } else {
                playOnStreamKey = false;
            };
        }
        public function set currentStreamServer(_arg1:String):void{
            var _local2:Object = this._102002428currentStreamServer;
            if (_local2 !== _arg1){
                this._102002428currentStreamServer = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "currentStreamServer", _local2, _arg1));
            };
        }

    }
}//package com.grooveshark.framework.playback 
﻿package com.grooveshark.framework {
    import flash.events.*;

    public class CommandQueue {

        protected var queue:Array;
        protected var currentCommand:ICommand;

        public function CommandQueue(){
            queue = [];
            super();
        }
        protected function onCommandComplete(_arg1:Event):void{
            var _local3:int;
            var _local2:ICommand = (_arg1.currentTarget as ICommand);
            _local2.removeEventListener(Event.COMPLETE, onCommandComplete);
            _local2.removeEventListener("failed", onCommandComplete);
            if (_local2 != currentCommand){
                if (currentCommand.hasEventListener(Event.COMPLETE)){
                    currentCommand.removeEventListener(Event.COMPLETE, onCommandComplete);
                };
                if (currentCommand.hasEventListener("failed")){
                    currentCommand.removeEventListener("failed", onCommandComplete);
                };
                _local3 = queue.indexOf(_local2);
                if (_local3 != -1){
                    queue.splice(_local3, 1);
                };
            };
            if (queue.length){
                currentCommand = queue.shift();
                currentCommand.addEventListener(Event.COMPLETE, onCommandComplete);
                currentCommand.addEventListener("failed", onCommandComplete);
                currentCommand.execute();
            } else {
                currentCommand = null;
            };
        }
        public function queueCommand(_arg1:ICommand):void{
            if (!currentCommand){
                currentCommand = _arg1;
                currentCommand.addEventListener(Event.COMPLETE, onCommandComplete);
                currentCommand.addEventListener("failed", onCommandComplete);
                currentCommand.execute();
            } else {
                queue.push(_arg1);
            };
        }

    }
}//package com.grooveshark.framework 
﻿package com.grooveshark.framework {
    import flash.events.*;
    import mx.events.*;
    import com.grooveshark.utils.*;

    public class BaseSong extends EventDispatcher {

        public static const DEFAULT_ART_PATH:String = "http://beta.grooveshark.com/static/amazonart/";

        private var _980229514artFilename:String = "";
        private var _110541305token:String = "";
        private var _150262052estimateDuration:Number = 0;
        private var _920410166albumID:int;
        private var _1270463035trackNum:int = 0;
        private var _249273754albumName:String = "";
        private var _896725776songID:int;
        private var _629723762artistName:String = "";
        private var _97513095flags:uint = 0;
        private var _1228393822artistID:int;
        private var _1535136064songName:String = "";

        public function get artistName():String{
            return (this._629723762artistName);
        }
        public function get songName():String{
            return (this._1535136064songName);
        }
        public function get albumID():int{
            return (this._920410166albumID);
        }
        public function get token():String{
            return (this._110541305token);
        }
        public function get flags():uint{
            return (this._97513095flags);
        }
        public function set songName(_arg1:String):void{
            var _local2:Object = this._1535136064songName;
            if (_local2 !== _arg1){
                this._1535136064songName = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "songName", _local2, _arg1));
            };
        }
        public function get artFilename():String{
            return (this._980229514artFilename);
        }
        public function set flags(_arg1:uint):void{
            var _local2:Object = this._97513095flags;
            if (_local2 !== _arg1){
                this._97513095flags = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "flags", _local2, _arg1));
            };
        }
        public function set artistID(_arg1:int):void{
            var _local2:Object = this._1228393822artistID;
            if (_local2 !== _arg1){
                this._1228393822artistID = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "artistID", _local2, _arg1));
            };
        }
        public function set albumID(_arg1:int):void{
            var _local2:Object = this._920410166albumID;
            if (_local2 !== _arg1){
                this._920410166albumID = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "albumID", _local2, _arg1));
            };
        }
        public function get estimateDuration():Number{
            return (this._150262052estimateDuration);
        }
        public function get trackNum():int{
            return (this._1270463035trackNum);
        }
        public function set token(_arg1:String):void{
            var _local2:Object = this._110541305token;
            if (_local2 !== _arg1){
                this._110541305token = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "token", _local2, _arg1));
            };
        }
        public function set songID(_arg1:int):void{
            var _local2:Object = this._896725776songID;
            if (_local2 !== _arg1){
                this._896725776songID = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "songID", _local2, _arg1));
            };
        }
        public function get albumName():String{
            return (this._249273754albumName);
        }
        public function set artFilename(_arg1:String):void{
            var _local2:Object = this._980229514artFilename;
            if (_local2 !== _arg1){
                this._980229514artFilename = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "artFilename", _local2, _arg1));
            };
        }
        public function set artistName(_arg1:String):void{
            var _local2:Object = this._629723762artistName;
            if (_local2 !== _arg1){
                this._629723762artistName = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "artistName", _local2, _arg1));
            };
        }
        public function get artistID():int{
            return (this._1228393822artistID);
        }
        override public function toString():String{
            return (((("[BaseSong] " + songID) + ":") + songName));
        }
        public function get songID():int{
            return (this._896725776songID);
        }
        public function set trackNum(_arg1:int):void{
            var _local2:Object = this._1270463035trackNum;
            if (_local2 !== _arg1){
                this._1270463035trackNum = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "trackNum", _local2, _arg1));
            };
        }
        public function set estimateDuration(_arg1:Number):void{
            var _local2:Object = this._150262052estimateDuration;
            if (_local2 !== _arg1){
                this._150262052estimateDuration = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "estimateDuration", _local2, _arg1));
            };
        }
        public function getURL():String{
            if (songID){
                return (LiteURLUtils.generateURL(songName, songID, "song"));
            };
            return ("");
        }
        public function set albumName(_arg1:String):void{
            var _local2:Object = this._249273754albumName;
            if (_local2 !== _arg1){
                this._249273754albumName = _arg1;
                this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "albumName", _local2, _arg1));
            };
        }

    }
}//package com.grooveshark.framework 
﻿package com.grooveshark.framework {
    import flash.events.*;

    public interface ICommand extends IEventDispatcher {

        function execute():void;

    }
}//package com.grooveshark.framework 
﻿package com.grooveshark.jsonrpc {
    import com.adobe.serialization.json.*;

    public class JSONRequest {

        public var method:String = "";
        public var parameters:Object;
        public var header:Object;

        public function JSONRequest(){
            header = {};
            parameters = {};
            super();
        }
        public function toString():String{
            return (JSON.encode(this));
        }

    }
}//package com.grooveshark.jsonrpc 
﻿package com.grooveshark.jsonrpc.events {
    import flash.events.*;
    import com.grooveshark.jsonrpc.*;

    public class ResultEvent extends Event {

        public static const RESULT:String = "result";

        public var result:JSONResult;

        public function ResultEvent(_arg1:String, _arg2:JSONResult, _arg3:Boolean=false, _arg4:Boolean=false){
            super(_arg1, _arg3, _arg4);
            this.result = _arg2;
        }
        override public function clone():Event{
            return (new ResultEvent(type, result, bubbles, cancelable));
        }

    }
}//package com.grooveshark.jsonrpc.events 
﻿package com.grooveshark.jsonrpc.events {
    import flash.events.*;
    import com.grooveshark.jsonrpc.*;

    public class FaultEvent extends Event {

        public static const FAULT:String = "fault";

        public var fault:JSONFault;

        public function FaultEvent(_arg1:String, _arg2:JSONFault, _arg3:Boolean=false, _arg4:Boolean=false){
            super(_arg1, _arg3, _arg4);
            this.fault = _arg2;
        }
        override public function clone():Event{
            return (new FaultEvent(type, fault, bubbles, cancelable));
        }

    }
}//package com.grooveshark.jsonrpc.events 
﻿package com.grooveshark.jsonrpc.events {
    import flash.events.*;

    public class HeaderEvent extends Event {

        public static const HEADER:String = "header";

        public var header:Object;

        public function HeaderEvent(_arg1:String, _arg2:Object, _arg3:Boolean=false, _arg4:Boolean=false){
            super(_arg1, _arg3, _arg4);
            this.header = _arg2;
        }
        override public function clone():Event{
            return (new HeaderEvent(type, header, bubbles, cancelable));
        }

    }
}//package com.grooveshark.jsonrpc.events 
﻿package com.grooveshark.jsonrpc {
    import com.adobe.serialization.json.*;

    public class JSONFault {

        public static const CLIENT_EXPIRED:int = 0x0400;
        public static const HTTP_ERROR:int = 2;
        public static const DOWN_FOR_MAINTENCE:int = 10;
        public static const PARSE_ERROR:int = 4;

        public static var lastError:Array;

        public var rawResult:String;
        public var message:String;
        public var method:String;
        public var code:Number;

        public function JSONFault(_arg1:Number, _arg2:String, _arg3:String, _arg4:String){
            var _local5:String;
            var _local6:RegExp;
            var _local7:RegExp;
            super();
            this.code = _arg1;
            this.message = _arg2;
            this.rawResult = _arg3;
            this.method = _arg4;
            if (((!((_arg1 == DOWN_FOR_MAINTENCE))) && (!((_arg1 == CLIENT_EXPIRED))))){
                if (!lastError){
                    lastError = [];
                };
                _local5 = _arg2;
                _local6 = /url:.*?http.*?(?="|\s|])/gi;
                _local7 = /(?:bubbles|cancelable|eventphase)(?::|=).*?(?="|\s|])/gi;
                _local5 = _local5.replace(_local6, "").replace(_local7, "");
                lastError.push({
                    message:_arg2,
                    code:_arg1,
                    rawResult:_arg3,
                    method:_arg4,
                    string:(((((((_arg1 == HTTP_ERROR)) ? "HTTP_ERROR:" : "ERROR:") + "(") + _arg4) + "): ") + _local5)
                });
                if (lastError.length > 3){
                    lastError.shift();
                };
            };
        }
        public function toString():String{
            return (JSON.encode(this));
        }

    }
}//package com.grooveshark.jsonrpc 
﻿package com.grooveshark.jsonrpc {
    import com.adobe.serialization.json.*;

    public class JSONResult {

        public var header:Object;
        public var rawResult:String;
        public var method:String;
        public var result:Object;

        public function toString():String{
            return (JSON.encode(this));
        }

    }
}//package com.grooveshark.jsonrpc 
﻿package com.grooveshark.jsonrpc {
    import flash.events.*;
    import mx.rpc.*;

    public interface IDualService extends IEventDispatcher {

        function getClient():String;
        function get country():Object;
        function send(_arg1:Boolean, _arg2:String, _arg3:Object=null, _arg4:IResponder=null, _arg5:String="", _arg6:Object=null, _arg7:String=""):void;
        function set country(_arg1:Object):void;
        function fetchCountry():void;

    }
}//package com.grooveshark.jsonrpc 
﻿package com.grooveshark.jsonrpc {
    import flash.events.*;
    import mx.rpc.*;
    import com.grooveshark.jsonrpc.events.*;
    import flash.utils.*;
    import com.adobe.serialization.json.*;
    import mx.collections.*;
    import mx.rpc.http.*;

    public class JSONService extends EventDispatcher {

        private var _headers:Object;
        private var httpService:HTTPService;
        public var debug:Boolean = false;

        public function JSONService(_arg1:String=""){
            httpService = new HTTPService();
            _headers = {};
            super();
            httpService.method = "POST";
            httpService.contentType = "application/json";
            httpService.resultFormat = "text";
            this.url = _arg1;
        }
        private function throwResult(_arg1:JSONResult, _arg2:IResponder=null):void{
            if (_arg2){
                _arg2.result(_arg1);
            };
            dispatchEvent(new ResultEvent(ResultEvent.RESULT, _arg1));
        }
        private function handleResult(_arg1:Object, _arg2:Object=null):void{
            var responder:* = null;
            var rawResult:* = null;
            var jsonFault:* = null;
            var parsedResult:* = null;
            var jsonResult:* = null;
            var result:* = _arg1;
            var token = _arg2;
            responder = null;
            if (((token) && (token.responder))){
                responder = (token.responder as ItemResponder);
            };
            rawResult = String(result.result);
            var i:* = rawResult.indexOf("{\"");
            var j:* = rawResult.lastIndexOf("}");
            if (debug){
                trace(((((("[" + token.method) + "][") + getTimer()) + "] Received raw response: ") + rawResult));
            };
            if (((!((i == -1))) && (!((j == -1))))){
                try {
                    parsedResult = JSON.decode(rawResult.substring(i, (j + 1)));
                } catch(err:Error) {
                    jsonFault = new JSONFault(JSONFault.PARSE_ERROR, ("Unable to parse result: " + err.message), rawResult, token.method);
                    throwFault(jsonFault, responder);
                    return;
                };
                if (parsedResult.fault){
                    jsonFault = new JSONFault(parsedResult.fault.code, parsedResult.fault.message, rawResult, token.method);
                    throwFault(jsonFault, responder);
                } else {
                    jsonResult = new JSONResult();
                    jsonResult.header = parsedResult.header;
                    jsonResult.result = parsedResult.result;
                    jsonResult.rawResult = rawResult;
                    jsonResult.method = token.method;
                    throwResult(jsonResult, responder);
                };
                if (parsedResult.header){
                    dispatchEvent(new HeaderEvent(HeaderEvent.HEADER, parsedResult.header));
                };
            } else {
                jsonFault = new JSONFault(JSONFault.PARSE_ERROR, "Unable to parse result: Not valid JSON", rawResult, token.method);
                throwFault(jsonFault, responder);
            };
        }
        public function get headers():Object{
            return (_headers);
        }
        public function send(_arg1:String, _arg2:Object=null, _arg3:Object=null, _arg4:IResponder=null):void{
            var _local7:String;
            var _local5:JSONRequest = new JSONRequest();
            _local5.header = _headers;
            _local5.method = _arg1;
            _local5.parameters = _arg2;
            if (_arg3){
                for (_local7 in _arg3) {
                    _local5.header[_local7] = _arg3[_local7];
                };
            };
            var _local6:AsyncToken = httpService.send(JSON.encode(_local5));
            _local6.addResponder(new ItemResponder(handleResult, handleFault, {
                responder:_arg4,
                method:_local5.method
            }));
            if (debug){
                trace(((((((("[" + this.url) + ":") + _local5.method) + "][") + getTimer()) + "] Sending request: ") + JSON.encode(_local5)));
            };
        }
        private function handleFault(_arg1:Object, _arg2:Object=null):void{
            var _local3:IResponder;
            if (((_arg2) && (_arg2.responder))){
                _local3 = (_arg2.responder as ItemResponder);
            };
            if (debug){
                trace(((((("[" + _arg2.method) + "][") + getTimer()) + "] Received server fault: ") + _arg1.toString()));
            };
            var _local4:JSONFault = new JSONFault(JSONFault.HTTP_ERROR, ("A server error occured: " + _arg1.toString()), "", _arg2.method);
            throwFault(_local4, _local3);
        }
        public function addHeader(_arg1:String, _arg2:Object):void{
            _headers[_arg1] = _arg2;
        }
        public function get url():String{
            return (httpService.url);
        }
        public function removeHeader(_arg1:String):void{
            if (_headers[_arg1]){
                _headers[_arg1] = undefined;
            };
        }
        public function clearHeaders():void{
            _headers = {};
        }
        private function throwFault(_arg1:JSONFault, _arg2:IResponder=null):void{
            if (_arg2){
                _arg2.fault(_arg1);
            };
            dispatchEvent(new FaultEvent(FaultEvent.FAULT, _arg1));
        }
        public function set url(_arg1:String):void{
            httpService.url = _arg1;
        }

    }
}//package com.grooveshark.jsonrpc 
﻿package com.adobe.utils {

    public class IntUtil {

        private static var hexChars:String = "0123456789abcdef";

        public static function toHex(_arg1:int, _arg2:Boolean=false):String{
            var _local4:int;
            var _local5:int;
            var _local3 = "";
            if (_arg2){
                _local4 = 0;
                while (_local4 < 4) {
                    _local3 = (_local3 + (hexChars.charAt(((_arg1 >> (((3 - _local4) * 8) + 4)) & 15)) + hexChars.charAt(((_arg1 >> ((3 - _local4) * 8)) & 15))));
                    _local4++;
                };
            } else {
                _local5 = 0;
                while (_local5 < 4) {
                    _local3 = (_local3 + (hexChars.charAt(((_arg1 >> ((_local5 * 8) + 4)) & 15)) + hexChars.charAt(((_arg1 >> (_local5 * 8)) & 15))));
                    _local5++;
                };
            };
            return (_local3);
        }
        public static function ror(_arg1:int, _arg2:int):uint{
            var _local3:int = (32 - _arg2);
            return (((_arg1 << _local3) | (_arg1 >>> (32 - _local3))));
        }
        public static function rol(_arg1:int, _arg2:int):int{
            return (((_arg1 << _arg2) | (_arg1 >>> (32 - _arg2))));
        }

    }
}//package com.adobe.utils 
﻿package com.adobe.crypto {
    import flash.utils.*;
    import mx.utils.*;
    import com.adobe.utils.*;

    public class SHA1 {

        public static var digest:ByteArray;

        private static function createBlocksFromByteArray(_arg1:ByteArray):Array{
            var _local2:int = _arg1.position;
            _arg1.position = 0;
            var _local3:Array = new Array();
            var _local4:int = (_arg1.length * 8);
            var _local5 = 0xFF;
            var _local6:int;
            while (_local6 < _local4) {
                _local3[(_local6 >> 5)] = (_local3[(_local6 >> 5)] | ((_arg1.readByte() & _local5) << (24 - (_local6 % 32))));
                _local6 = (_local6 + 8);
            };
            _local3[(_local4 >> 5)] = (_local3[(_local4 >> 5)] | (128 << (24 - (_local4 % 32))));
            _local3[((((_local4 + 64) >> 9) << 4) + 15)] = _local4;
            _arg1.position = _local2;
            return (_local3);
        }
        private static function hashBlocks(_arg1:Array):ByteArray{
            var _local9:int;
            var _local12:int;
            var _local13:int;
            var _local14:int;
            var _local15:int;
            var _local16:int;
            var _local17:int;
            var _local2 = 1732584193;
            var _local3:int = 4023233417;
            var _local4:int = 2562383102;
            var _local5 = 271733878;
            var _local6:int = 3285377520;
            var _local7:int = _arg1.length;
            var _local8:Array = new Array(80);
            var _local10:int;
            while (_local10 < _local7) {
                _local12 = _local2;
                _local13 = _local3;
                _local14 = _local4;
                _local15 = _local5;
                _local16 = _local6;
                _local17 = 0;
                while (_local17 < 20) {
                    if (_local17 < 16){
                        _local8[_local17] = _arg1[(_local10 + _local17)];
                    } else {
                        _local9 = (((_local8[(_local17 - 3)] ^ _local8[(_local17 - 8)]) ^ _local8[(_local17 - 14)]) ^ _local8[(_local17 - 16)]);
                        _local8[_local17] = ((_local9 << 1) | (_local9 >>> 31));
                    };
                    _local9 = ((((((_local12 << 5) | (_local12 >>> 27)) + ((_local13 & _local14) | (~(_local13) & _local15))) + _local16) + int(_local8[_local17])) + 1518500249);
                    _local16 = _local15;
                    _local15 = _local14;
                    _local14 = ((_local13 << 30) | (_local13 >>> 2));
                    _local13 = _local12;
                    _local12 = _local9;
                    _local17++;
                };
                while (_local17 < 40) {
                    _local9 = (((_local8[(_local17 - 3)] ^ _local8[(_local17 - 8)]) ^ _local8[(_local17 - 14)]) ^ _local8[(_local17 - 16)]);
                    _local8[_local17] = ((_local9 << 1) | (_local9 >>> 31));
                    _local9 = ((((((_local12 << 5) | (_local12 >>> 27)) + ((_local13 ^ _local14) ^ _local15)) + _local16) + int(_local8[_local17])) + 1859775393);
                    _local16 = _local15;
                    _local15 = _local14;
                    _local14 = ((_local13 << 30) | (_local13 >>> 2));
                    _local13 = _local12;
                    _local12 = _local9;
                    _local17++;
                };
                while (_local17 < 60) {
                    _local9 = (((_local8[(_local17 - 3)] ^ _local8[(_local17 - 8)]) ^ _local8[(_local17 - 14)]) ^ _local8[(_local17 - 16)]);
                    _local8[_local17] = ((_local9 << 1) | (_local9 >>> 31));
                    _local9 = ((((((_local12 << 5) | (_local12 >>> 27)) + (((_local13 & _local14) | (_local13 & _local15)) | (_local14 & _local15))) + _local16) + int(_local8[_local17])) + 2400959708);
                    _local16 = _local15;
                    _local15 = _local14;
                    _local14 = ((_local13 << 30) | (_local13 >>> 2));
                    _local13 = _local12;
                    _local12 = _local9;
                    _local17++;
                };
                while (_local17 < 80) {
                    _local9 = (((_local8[(_local17 - 3)] ^ _local8[(_local17 - 8)]) ^ _local8[(_local17 - 14)]) ^ _local8[(_local17 - 16)]);
                    _local8[_local17] = ((_local9 << 1) | (_local9 >>> 31));
                    _local9 = ((((((_local12 << 5) | (_local12 >>> 27)) + ((_local13 ^ _local14) ^ _local15)) + _local16) + int(_local8[_local17])) + 3395469782);
                    _local16 = _local15;
                    _local15 = _local14;
                    _local14 = ((_local13 << 30) | (_local13 >>> 2));
                    _local13 = _local12;
                    _local12 = _local9;
                    _local17++;
                };
                _local2 = (_local2 + _local12);
                _local3 = (_local3 + _local13);
                _local4 = (_local4 + _local14);
                _local5 = (_local5 + _local15);
                _local6 = (_local6 + _local16);
                _local10 = (_local10 + 16);
            };
            var _local11:ByteArray = new ByteArray();
            _local11.writeInt(_local2);
            _local11.writeInt(_local3);
            _local11.writeInt(_local4);
            _local11.writeInt(_local5);
            _local11.writeInt(_local6);
            _local11.position = 0;
            digest = new ByteArray();
            digest.writeBytes(_local11);
            digest.position = 0;
            return (_local11);
        }
        private static function createBlocksFromString(_arg1:String):Array{
            var _local2:Array = new Array();
            var _local3:int = (_arg1.length * 8);
            var _local4 = 0xFF;
            var _local5:int;
            while (_local5 < _local3) {
                _local2[(_local5 >> 5)] = (_local2[(_local5 >> 5)] | ((_arg1.charCodeAt((_local5 / 8)) & _local4) << (24 - (_local5 % 32))));
                _local5 = (_local5 + 8);
            };
            _local2[(_local3 >> 5)] = (_local2[(_local3 >> 5)] | (128 << (24 - (_local3 % 32))));
            _local2[((((_local3 + 64) >> 9) << 4) + 15)] = _local3;
            return (_local2);
        }
        public static function hashBytes(_arg1:ByteArray):String{
            var _local2:Array = SHA1.createBlocksFromByteArray(_arg1);
            var _local3:ByteArray = hashBlocks(_local2);
            return (((((IntUtil.toHex(_local3.readInt(), true) + IntUtil.toHex(_local3.readInt(), true)) + IntUtil.toHex(_local3.readInt(), true)) + IntUtil.toHex(_local3.readInt(), true)) + IntUtil.toHex(_local3.readInt(), true)));
        }
        public static function hash(_arg1:String):String{
            var _local2:Array = createBlocksFromString(_arg1);
            var _local3:ByteArray = hashBlocks(_local2);
            return (((((IntUtil.toHex(_local3.readInt(), true) + IntUtil.toHex(_local3.readInt(), true)) + IntUtil.toHex(_local3.readInt(), true)) + IntUtil.toHex(_local3.readInt(), true)) + IntUtil.toHex(_local3.readInt(), true)));
        }
        public static function hashToBase64(_arg1:String):String{
            var _local7:uint;
            var _local2:Array = SHA1.createBlocksFromString(_arg1);
            var _local3:ByteArray = hashBlocks(_local2);
            var _local4 = "";
            _local3.position = 0;
            var _local5:int;
            while (_local5 < _local3.length) {
                _local7 = _local3.readUnsignedByte();
                _local4 = (_local4 + String.fromCharCode(_local7));
                _local5++;
            };
            var _local6:Base64Encoder = new Base64Encoder();
            _local6.encode(_local4);
            return (_local6.flush());
        }

    }
}//package com.adobe.crypto 
﻿package com.adobe.crypto {
    import flash.utils.*;
    import com.adobe.utils.*;

    public class MD5 {

        public static var digest:ByteArray;

        private static function ff(_arg1:int, _arg2:int, _arg3:int, _arg4:int, _arg5:int, _arg6:int, _arg7:int):int{
            return (transform(f, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7));
        }
        private static function f(_arg1:int, _arg2:int, _arg3:int):int{
            return (((_arg1 & _arg2) | (~(_arg1) & _arg3)));
        }
        private static function g(_arg1:int, _arg2:int, _arg3:int):int{
            return (((_arg1 & _arg3) | (_arg2 & ~(_arg3))));
        }
        private static function h(_arg1:int, _arg2:int, _arg3:int):int{
            return (((_arg1 ^ _arg2) ^ _arg3));
        }
        private static function i(_arg1:int, _arg2:int, _arg3:int):int{
            return ((_arg2 ^ (_arg1 | ~(_arg3))));
        }
        private static function transform(_arg1:Function, _arg2:int, _arg3:int, _arg4:int, _arg5:int, _arg6:int, _arg7:int, _arg8:int):int{
            var _local9:int = (((_arg2 + int(_arg1(_arg3, _arg4, _arg5))) + _arg6) + _arg8);
            return ((IntUtil.rol(_local9, _arg7) + _arg3));
        }
        private static function hh(_arg1:int, _arg2:int, _arg3:int, _arg4:int, _arg5:int, _arg6:int, _arg7:int):int{
            return (transform(h, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7));
        }
        public static function hash(_arg1:String):String{
            var _local2:ByteArray = new ByteArray();
            _local2.writeUTFBytes(_arg1);
            return (hashBinary(_local2));
        }
        private static function createBlocks(_arg1:ByteArray):Array{
            var _local2:Array = new Array();
            var _local3:int = (_arg1.length * 8);
            var _local4 = 0xFF;
            var _local5:int;
            while (_local5 < _local3) {
                _local2[int((_local5 >> 5))] = (_local2[int((_local5 >> 5))] | ((_arg1[(_local5 / 8)] & _local4) << (_local5 % 32)));
                _local5 = (_local5 + 8);
            };
            _local2[int((_local3 >> 5))] = (_local2[int((_local3 >> 5))] | (128 << (_local3 % 32)));
            _local2[int(((((_local3 + 64) >>> 9) << 4) + 14))] = _local3;
            return (_local2);
        }
        public static function hashBinary(_arg1:ByteArray):String{
            var _local6:int;
            var _local7:int;
            var _local8:int;
            var _local9:int;
            var _local2 = 1732584193;
            var _local3 = -271733879;
            var _local4 = -1732584194;
            var _local5 = 271733878;
            var _local10:Array = createBlocks(_arg1);
            var _local11:int = _local10.length;
            var _local12:int;
            while (_local12 < _local11) {
                _local6 = _local2;
                _local7 = _local3;
                _local8 = _local4;
                _local9 = _local5;
                _local2 = ff(_local2, _local3, _local4, _local5, _local10[int((_local12 + 0))], 7, -680876936);
                _local5 = ff(_local5, _local2, _local3, _local4, _local10[int((_local12 + 1))], 12, -389564586);
                _local4 = ff(_local4, _local5, _local2, _local3, _local10[int((_local12 + 2))], 17, 606105819);
                _local3 = ff(_local3, _local4, _local5, _local2, _local10[int((_local12 + 3))], 22, -1044525330);
                _local2 = ff(_local2, _local3, _local4, _local5, _local10[int((_local12 + 4))], 7, -176418897);
                _local5 = ff(_local5, _local2, _local3, _local4, _local10[int((_local12 + 5))], 12, 1200080426);
                _local4 = ff(_local4, _local5, _local2, _local3, _local10[int((_local12 + 6))], 17, -1473231341);
                _local3 = ff(_local3, _local4, _local5, _local2, _local10[int((_local12 + 7))], 22, -45705983);
                _local2 = ff(_local2, _local3, _local4, _local5, _local10[int((_local12 + 8))], 7, 1770035416);
                _local5 = ff(_local5, _local2, _local3, _local4, _local10[int((_local12 + 9))], 12, -1958414417);
                _local4 = ff(_local4, _local5, _local2, _local3, _local10[int((_local12 + 10))], 17, -42063);
                _local3 = ff(_local3, _local4, _local5, _local2, _local10[int((_local12 + 11))], 22, -1990404162);
                _local2 = ff(_local2, _local3, _local4, _local5, _local10[int((_local12 + 12))], 7, 1804603682);
                _local5 = ff(_local5, _local2, _local3, _local4, _local10[int((_local12 + 13))], 12, -40341101);
                _local4 = ff(_local4, _local5, _local2, _local3, _local10[int((_local12 + 14))], 17, -1502002290);
                _local3 = ff(_local3, _local4, _local5, _local2, _local10[int((_local12 + 15))], 22, 1236535329);
                _local2 = gg(_local2, _local3, _local4, _local5, _local10[int((_local12 + 1))], 5, -165796510);
                _local5 = gg(_local5, _local2, _local3, _local4, _local10[int((_local12 + 6))], 9, -1069501632);
                _local4 = gg(_local4, _local5, _local2, _local3, _local10[int((_local12 + 11))], 14, 643717713);
                _local3 = gg(_local3, _local4, _local5, _local2, _local10[int((_local12 + 0))], 20, -373897302);
                _local2 = gg(_local2, _local3, _local4, _local5, _local10[int((_local12 + 5))], 5, -701558691);
                _local5 = gg(_local5, _local2, _local3, _local4, _local10[int((_local12 + 10))], 9, 38016083);
                _local4 = gg(_local4, _local5, _local2, _local3, _local10[int((_local12 + 15))], 14, -660478335);
                _local3 = gg(_local3, _local4, _local5, _local2, _local10[int((_local12 + 4))], 20, -405537848);
                _local2 = gg(_local2, _local3, _local4, _local5, _local10[int((_local12 + 9))], 5, 568446438);
                _local5 = gg(_local5, _local2, _local3, _local4, _local10[int((_local12 + 14))], 9, -1019803690);
                _local4 = gg(_local4, _local5, _local2, _local3, _local10[int((_local12 + 3))], 14, -187363961);
                _local3 = gg(_local3, _local4, _local5, _local2, _local10[int((_local12 + 8))], 20, 1163531501);
                _local2 = gg(_local2, _local3, _local4, _local5, _local10[int((_local12 + 13))], 5, -1444681467);
                _local5 = gg(_local5, _local2, _local3, _local4, _local10[int((_local12 + 2))], 9, -51403784);
                _local4 = gg(_local4, _local5, _local2, _local3, _local10[int((_local12 + 7))], 14, 1735328473);
                _local3 = gg(_local3, _local4, _local5, _local2, _local10[int((_local12 + 12))], 20, -1926607734);
                _local2 = hh(_local2, _local3, _local4, _local5, _local10[int((_local12 + 5))], 4, -378558);
                _local5 = hh(_local5, _local2, _local3, _local4, _local10[int((_local12 + 8))], 11, -2022574463);
                _local4 = hh(_local4, _local5, _local2, _local3, _local10[int((_local12 + 11))], 16, 1839030562);
                _local3 = hh(_local3, _local4, _local5, _local2, _local10[int((_local12 + 14))], 23, -35309556);
                _local2 = hh(_local2, _local3, _local4, _local5, _local10[int((_local12 + 1))], 4, -1530992060);
                _local5 = hh(_local5, _local2, _local3, _local4, _local10[int((_local12 + 4))], 11, 1272893353);
                _local4 = hh(_local4, _local5, _local2, _local3, _local10[int((_local12 + 7))], 16, -155497632);
                _local3 = hh(_local3, _local4, _local5, _local2, _local10[int((_local12 + 10))], 23, -1094730640);
                _local2 = hh(_local2, _local3, _local4, _local5, _local10[int((_local12 + 13))], 4, 681279174);
                _local5 = hh(_local5, _local2, _local3, _local4, _local10[int((_local12 + 0))], 11, -358537222);
                _local4 = hh(_local4, _local5, _local2, _local3, _local10[int((_local12 + 3))], 16, -722521979);
                _local3 = hh(_local3, _local4, _local5, _local2, _local10[int((_local12 + 6))], 23, 76029189);
                _local2 = hh(_local2, _local3, _local4, _local5, _local10[int((_local12 + 9))], 4, -640364487);
                _local5 = hh(_local5, _local2, _local3, _local4, _local10[int((_local12 + 12))], 11, -421815835);
                _local4 = hh(_local4, _local5, _local2, _local3, _local10[int((_local12 + 15))], 16, 530742520);
                _local3 = hh(_local3, _local4, _local5, _local2, _local10[int((_local12 + 2))], 23, -995338651);
                _local2 = ii(_local2, _local3, _local4, _local5, _local10[int((_local12 + 0))], 6, -198630844);
                _local5 = ii(_local5, _local2, _local3, _local4, _local10[int((_local12 + 7))], 10, 1126891415);
                _local4 = ii(_local4, _local5, _local2, _local3, _local10[int((_local12 + 14))], 15, -1416354905);
                _local3 = ii(_local3, _local4, _local5, _local2, _local10[int((_local12 + 5))], 21, -57434055);
                _local2 = ii(_local2, _local3, _local4, _local5, _local10[int((_local12 + 12))], 6, 1700485571);
                _local5 = ii(_local5, _local2, _local3, _local4, _local10[int((_local12 + 3))], 10, -1894986606);
                _local4 = ii(_local4, _local5, _local2, _local3, _local10[int((_local12 + 10))], 15, -1051523);
                _local3 = ii(_local3, _local4, _local5, _local2, _local10[int((_local12 + 1))], 21, -2054922799);
                _local2 = ii(_local2, _local3, _local4, _local5, _local10[int((_local12 + 8))], 6, 1873313359);
                _local5 = ii(_local5, _local2, _local3, _local4, _local10[int((_local12 + 15))], 10, -30611744);
                _local4 = ii(_local4, _local5, _local2, _local3, _local10[int((_local12 + 6))], 15, -1560198380);
                _local3 = ii(_local3, _local4, _local5, _local2, _local10[int((_local12 + 13))], 21, 1309151649);
                _local2 = ii(_local2, _local3, _local4, _local5, _local10[int((_local12 + 4))], 6, -145523070);
                _local5 = ii(_local5, _local2, _local3, _local4, _local10[int((_local12 + 11))], 10, -1120210379);
                _local4 = ii(_local4, _local5, _local2, _local3, _local10[int((_local12 + 2))], 15, 718787259);
                _local3 = ii(_local3, _local4, _local5, _local2, _local10[int((_local12 + 9))], 21, -343485551);
                _local2 = (_local2 + _local6);
                _local3 = (_local3 + _local7);
                _local4 = (_local4 + _local8);
                _local5 = (_local5 + _local9);
                _local12 = (_local12 + 16);
            };
            digest = new ByteArray();
            digest.writeInt(_local2);
            digest.writeInt(_local3);
            digest.writeInt(_local4);
            digest.writeInt(_local5);
            digest.position = 0;
            return ((((IntUtil.toHex(_local2) + IntUtil.toHex(_local3)) + IntUtil.toHex(_local4)) + IntUtil.toHex(_local5)));
        }
        private static function gg(_arg1:int, _arg2:int, _arg3:int, _arg4:int, _arg5:int, _arg6:int, _arg7:int):int{
            return (transform(g, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7));
        }
        private static function ii(_arg1:int, _arg2:int, _arg3:int, _arg4:int, _arg5:int, _arg6:int, _arg7:int):int{
            return (transform(i, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7));
        }
        public static function hashBytes(_arg1:ByteArray):String{
            return (hashBinary(_arg1));
        }

    }
}//package com.adobe.crypto 
﻿package com.adobe.serialization.json {

    public class JSONToken {

        private var _value:Object;
        private var _type:int;

        public function JSONToken(_arg1:int=-1, _arg2:Object=null){
            this._type = _arg1;
            this._value = _arg2;
        }
        public function get value():Object{
            return (this._value);
        }
        public function get type():int{
            return (this._type);
        }
        public function set type(_arg1:int):void{
            this._type = _arg1;
        }
        public function set value(_arg1:Object):void{
            this._value = _arg1;
        }

    }
}//package com.adobe.serialization.json 
﻿package com.adobe.serialization.json {

    public class JSONDecoder {

        private var strict:Boolean;
        private var value;
        private var tokenizer:JSONTokenizer;
        private var token:JSONToken;

        public function JSONDecoder(_arg1:String, _arg2:Boolean){
            this.strict = _arg2;
            this.tokenizer = new JSONTokenizer(_arg1, _arg2);
            this.nextToken();
            this.value = this.parseValue();
            if (((_arg2) && (!((this.nextToken() == null))))){
                this.tokenizer.parseError("Unexpected characters left in input stream");
            };
        }
        private function nextToken():JSONToken{
            return ((this.token = this.tokenizer.getNextToken()));
        }
        private function parseObject():Object{
            var _local2:String;
            var _local1:Object = new Object();
            this.nextToken();
            if (this.token.type == JSONTokenType.RIGHT_BRACE){
                return (_local1);
            };
            if (((!(this.strict)) && ((this.token.type == JSONTokenType.COMMA)))){
                this.nextToken();
                if (this.token.type == JSONTokenType.RIGHT_BRACE){
                    return (_local1);
                };
                this.tokenizer.parseError(("Leading commas are not supported.  Expecting '}' but found " + this.token.value));
            };
            if (this.token.type == JSONTokenType.STRING){
                _local2 = String(this.token.value);
                this.nextToken();
                if (this.token.type == JSONTokenType.COLON){
                    this.nextToken();
                    _local1[_local2] = this.parseValue();
                    this.nextToken();
                    if (this.token.type == JSONTokenType.RIGHT_BRACE){
                        return (_local1);
                    };
                    if (this.token.type == JSONTokenType.COMMA){
                        this.nextToken();
                        if (!this.strict){
                            if (this.token.type == JSONTokenType.RIGHT_BRACE){
                                return (_local1);
                            };
                        };
                    } else {
                        this.tokenizer.parseError(("Expecting } or , but found " + this.token.value));
                    };
                } else {
                    this.tokenizer.parseError(("Expecting : but found " + this.token.value));
                };
            } else {
                this.tokenizer.parseError(("Expecting string but found " + this.token.value));
            };
            //unresolved jump
        }
        private function parseArray():Array{
            var _local1:Array = new Array();
            this.nextToken();
            if (this.token.type == JSONTokenType.RIGHT_BRACKET){
                return (_local1);
            };
            if (((!(this.strict)) && ((this.token.type == JSONTokenType.COMMA)))){
                this.nextToken();
                if (this.token.type == JSONTokenType.RIGHT_BRACKET){
                    return (_local1);
                };
                this.tokenizer.parseError(("Leading commas are not supported.  Expecting ']' but found " + this.token.value));
            };
            _local1.push(this.parseValue());
            this.nextToken();
            if (this.token.type == JSONTokenType.RIGHT_BRACKET){
                return (_local1);
            };
            if (this.token.type == JSONTokenType.COMMA){
                this.nextToken();
                if (!this.strict){
                    if (this.token.type == JSONTokenType.RIGHT_BRACKET){
                        return (_local1);
                    };
                };
            } else {
                this.tokenizer.parseError(("Expecting ] or , but found " + this.token.value));
            };
            //unresolved jump
        }
        public function getValue(){
            return (this.value);
        }
        private function parseValue():Object{
            if (this.token == null){
                this.tokenizer.parseError("Unexpected end of input");
            };
            switch (this.token.type){
                case JSONTokenType.LEFT_BRACE:
                    return (this.parseObject());
                case JSONTokenType.LEFT_BRACKET:
                    return (this.parseArray());
                case JSONTokenType.STRING:
                case JSONTokenType.NUMBER:
                case JSONTokenType.TRUE:
                case JSONTokenType.FALSE:
                case JSONTokenType.NULL:
                    return (this.token.value);
                case JSONTokenType.NAN:
                    if (!this.strict){
                        return (this.token.value);
                    };
                    this.tokenizer.parseError(("Unexpected " + this.token.value));
                default:
                    this.tokenizer.parseError(("Unexpected " + this.token.value));
            };
            return (null);
        }

    }
}//package com.adobe.serialization.json 
﻿package com.adobe.serialization.json {

    public class JSONTokenType {

        public static const FALSE:int = 8;
        public static const RIGHT_BRACKET:int = 4;
        public static const NULL:int = 9;
        public static const NUMBER:int = 11;
        public static const TRUE:int = 7;
        public static const RIGHT_BRACE:int = 2;
        public static const STRING:int = 10;
        public static const LEFT_BRACKET:int = 3;
        public static const LEFT_BRACE:int = 1;
        public static const UNKNOWN:int = -1;
        public static const COMMA:int = 0;
        public static const NAN:int = 12;
        public static const COLON:int = 6;

    }
}//package com.adobe.serialization.json 
﻿package com.adobe.serialization.json {

    public class JSON {

        public static function decode(_arg1:String, _arg2:Boolean=true){
            return (new JSONDecoder(_arg1, _arg2).getValue());
        }
        public static function encode(_arg1:Object):String{
            return (new JSONEncoder(_arg1).getString());
        }

    }
}//package com.adobe.serialization.json 
﻿package com.adobe.serialization.json {
    import flash.utils.*;

    public class JSONEncoder {

        private var jsonString:String;

        public function JSONEncoder(_arg1){
            this.jsonString = this.convertToString(_arg1);
        }
        private function escapeString(_arg1:String):String{
            var _local3:String;
            var _local6:String;
            var _local7:String;
            var _local2 = "";
            var _local4:Number = _arg1.length;
            var _local5:int;
            while (_local5 < _local4) {
                _local3 = _arg1.charAt(_local5);
                switch (_local3){
                    case "\"":
                        _local2 = (_local2 + "\\\"");
                        break;
                    case "\\":
                        _local2 = (_local2 + "\\\\");
                        break;
                    case "\b":
                        _local2 = (_local2 + "\\b");
                        break;
                    case "\f":
                        _local2 = (_local2 + "\\f");
                        break;
                    case "\n":
                        _local2 = (_local2 + "\\n");
                        break;
                    case "\r":
                        _local2 = (_local2 + "\\r");
                        break;
                    case "\t":
                        _local2 = (_local2 + "\\t");
                        break;
                    default:
                        if (_local3 < " "){
                            _local6 = _local3.charCodeAt(0).toString(16);
                            _local7 = (((_local6.length == 2)) ? "00" : "000");
                            _local2 = (_local2 + (("\\u" + _local7) + _local6));
                        } else {
                            _local2 = (_local2 + _local3);
                        };
                };
                _local5++;
            };
            return ((("\"" + _local2) + "\""));
        }
        private function arrayToString(_arg1:Array):String{
            var _local2 = "";
            var _local3:int;
            while (_local3 < _arg1.length) {
                if (_local2.length > 0){
                    _local2 = (_local2 + ",");
                };
                _local2 = (_local2 + this.convertToString(_arg1[_local3]));
                _local3++;
            };
            return ((("[" + _local2) + "]"));
        }
        public function getString():String{
            return (this.jsonString);
        }
        private function objectToString(_arg1:Object):String{
            var value:* = null;
            var key:* = null;
            var v:* = null;
            var o:* = _arg1;
            var s:* = "";
            var classInfo:* = describeType(o);
            if (classInfo.@name.toString() == "Object"){
                for (key in o) {
                    value = o[key];
                    if ((value is Function)){
                    } else {
                        if (s.length > 0){
                            s = (s + ",");
                        };
                        s = (s + ((this.escapeString(key) + ":") + this.convertToString(value)));
                    };
                };
            } else {
                for each (v in classInfo..*.(((name() == "variable")) || ((((name() == "accessor")) && ((attribute("access").charAt(0) == "r")))))) {
                    if (((v.metadata) && ((v.metadata.(@name == "Transient").length() > 0)))){
                    } else {
                        if (s.length > 0){
                            s = (s + ",");
                        };
                        s = (s + ((this.escapeString(v.@name.toString()) + ":") + this.convertToString(o[v.@name])));
                    };
                };
            };
            return ((("{" + s) + "}"));
        }
        private function convertToString(_arg1):String{
            if ((_arg1 is String)){
                return (this.escapeString((_arg1 as String)));
            };
            if ((_arg1 is Number)){
                return (((isFinite((_arg1 as Number))) ? _arg1.toString() : "null"));
            };
            if ((_arg1 is Boolean)){
                return (((_arg1) ? "true" : "false"));
            };
            if ((_arg1 is Array)){
                return (this.arrayToString((_arg1 as Array)));
            };
            if ((((_arg1 is Object)) && (!((_arg1 == null))))){
                return (this.objectToString(_arg1));
            };
            return ("null");
        }

    }
}//package com.adobe.serialization.json 
﻿package com.adobe.serialization.json {

    public class JSONTokenizer {

        private var ch:String;
        private var loc:int;
        private var jsonString:String;
        private var strict:Boolean;
        private var controlCharsRegExp:RegExp;
        private var obj:Object;

        public function JSONTokenizer(_arg1:String, _arg2:Boolean){
            this.controlCharsRegExp = /[\x00-\x1F]/;
            super();
            this.jsonString = _arg1;
            this.strict = _arg2;
            this.loc = 0;
            this.nextChar();
        }
        private function skipComments():void{
            if (this.ch == "/"){
                this.nextChar();
                switch (this.ch){
                    case "/":
                        do  {
                            this.nextChar();
                        } while (((!((this.ch == "\n"))) && (!((this.ch == "")))));
                        this.nextChar();
                        break;
                    case "*":
                        this.nextChar();
                        while (true) {
                            if (this.ch == "*"){
                                this.nextChar();
                                if (this.ch == "/"){
                                    this.nextChar();
                                    break;
                                };
                            } else {
                                this.nextChar();
                            };
                            if (this.ch == ""){
                                this.parseError("Multi-line comment not closed");
                            };
                        };
                        break;
                    default:
                        this.parseError((("Unexpected " + this.ch) + " encountered (expecting '/' or '*' )"));
                };
            };
        }
        private function isDigit(_arg1:String):Boolean{
            return ((((_arg1 >= "0")) && ((_arg1 <= "9"))));
        }
        private function readNumber():JSONToken{
            var _local3:JSONToken;
            var _local1 = "";
            if (this.ch == "-"){
                _local1 = (_local1 + "-");
                this.nextChar();
            };
            if (!this.isDigit(this.ch)){
                this.parseError("Expecting a digit");
            };
            if (this.ch == "0"){
                _local1 = (_local1 + this.ch);
                this.nextChar();
                if (this.isDigit(this.ch)){
                    this.parseError("A digit cannot immediately follow 0");
                } else {
                    if (((!(this.strict)) && ((this.ch == "x")))){
                        _local1 = (_local1 + this.ch);
                        this.nextChar();
                        if (this.isHexDigit(this.ch)){
                            _local1 = (_local1 + this.ch);
                            this.nextChar();
                        } else {
                            this.parseError("Number in hex format require at least one hex digit after \"0x\"");
                        };
                        while (this.isHexDigit(this.ch)) {
                            _local1 = (_local1 + this.ch);
                            this.nextChar();
                        };
                    };
                };
            } else {
                while (this.isDigit(this.ch)) {
                    _local1 = (_local1 + this.ch);
                    this.nextChar();
                };
            };
            if (this.ch == "."){
                _local1 = (_local1 + ".");
                this.nextChar();
                if (!this.isDigit(this.ch)){
                    this.parseError("Expecting a digit");
                };
                while (this.isDigit(this.ch)) {
                    _local1 = (_local1 + this.ch);
                    this.nextChar();
                };
            };
            if ((((this.ch == "e")) || ((this.ch == "E")))){
                _local1 = (_local1 + "e");
                this.nextChar();
                if ((((this.ch == "+")) || ((this.ch == "-")))){
                    _local1 = (_local1 + this.ch);
                    this.nextChar();
                };
                if (!this.isDigit(this.ch)){
                    this.parseError("Scientific notation number needs exponent value");
                };
                while (this.isDigit(this.ch)) {
                    _local1 = (_local1 + this.ch);
                    this.nextChar();
                };
            };
            var _local2:Number = Number(_local1);
            if (((isFinite(_local2)) && (!(isNaN(_local2))))){
                _local3 = new JSONToken();
                _local3.type = JSONTokenType.NUMBER;
                _local3.value = _local2;
                return (_local3);
            };
            this.parseError((("Number " + _local2) + " is not valid!"));
            return (null);
        }
        public function unescapeString(_arg1:String):String{
            var _local6:*;
            var _local7:*;
            var _local8:*;
            var _local9:*;
            var _local10:*;
            if (((this.strict) && (this.controlCharsRegExp.test(_arg1)))){
                this.parseError("String contains unescaped control character (0x00-0x1F)");
            };
            var _local2 = "";
            var _local3:int;
            var _local4:int;
            var _local5:int = _arg1.length;
            do  {
                _local3 = _arg1.indexOf("\\", _local4);
                if (_local3 >= 0){
                    _local2 = (_local2 + _arg1.substr(_local4, (_local3 - _local4)));
                    _local4 = (_local3 + 2);
                    _local6 = (_local3 + 1);
                    _local7 = _arg1.charAt(_local6);
                    switch (_local7){
                        case "\"":
                            _local2 = (_local2 + "\"");
                            break;
                        case "\\":
                            _local2 = (_local2 + "\\");
                            break;
                        case "n":
                            _local2 = (_local2 + "\n");
                            break;
                        case "r":
                            _local2 = (_local2 + "\r");
                            break;
                        case "t":
                            _local2 = (_local2 + "\t");
                            break;
                        case "u":
                            _local8 = "";
                            if ((_local4 + 4) > _local5){
                                this.parseError("Unexpected end of input.  Expecting 4 hex digits after \\u.");
                            };
                            _local9 = _local4;
                            while (_local9 < (_local4 + 4)) {
                                _local10 = _arg1.charAt(_local9);
                                if (!this.isHexDigit(_local10)){
                                    this.parseError(("Excepted a hex digit, but found: " + _local10));
                                };
                                _local8 = (_local8 + _local10);
                                _local9++;
                            };
                            _local2 = (_local2 + String.fromCharCode(parseInt(_local8, 16)));
                            _local4 = (_local4 + 4);
                            break;
                        case "f":
                            _local2 = (_local2 + "\f");
                            break;
                        case "/":
                            _local2 = (_local2 + "/");
                            break;
                        case "b":
                            _local2 = (_local2 + "\b");
                            break;
                        default:
                            _local2 = (_local2 + ("\\" + _local7));
                    };
                } else {
                    _local2 = (_local2 + _arg1.substr(_local4));
                    break;
                };
            } while (_local4 < _local5);
            return (_local2);
        }
        private function skipWhite():void{
            while (this.isWhiteSpace(this.ch)) {
                this.nextChar();
            };
        }
        private function isWhiteSpace(_arg1:String):Boolean{
            if ((((((((_arg1 == " ")) || ((_arg1 == "\t")))) || ((_arg1 == "\n")))) || ((_arg1 == "\r")))){
                return (true);
            };
            if (((!(this.strict)) && ((_arg1.charCodeAt(0) == 160)))){
                return (true);
            };
            return (false);
        }
        public function parseError(_arg1:String):void{
            throw (new JSONParseError(_arg1, this.loc, this.jsonString));
        }
        private function readString():JSONToken{
            var _local3:*;
            var _local4:*;
            var _local1:int = this.loc;
            do  {
                _local1 = this.jsonString.indexOf("\"", _local1);
                if (_local1 >= 0){
                    _local3 = 0;
                    _local4 = (_local1 - 1);
                    while (this.jsonString.charAt(_local4) == "\\") {
                        _local3++;
                        _local4--;
                    };
                    if ((_local3 % 2) == 0){
                        break;
                    };
                    _local1++;
                } else {
                    this.parseError("Unterminated string literal");
                };
            } while (true);
            var _local2:JSONToken = new JSONToken();
            _local2.type = JSONTokenType.STRING;
            _local2.value = this.unescapeString(this.jsonString.substr(this.loc, (_local1 - this.loc)));
            this.loc = (_local1 + 1);
            this.nextChar();
            return (_local2);
        }
        private function nextChar():String{
            return ((this.ch = this.jsonString.charAt(this.loc++)));
        }
        private function skipIgnored():void{
            var _local1:int;
            do  {
                _local1 = this.loc;
                this.skipWhite();
                this.skipComments();
            } while (_local1 != this.loc);
        }
        private function isHexDigit(_arg1:String):Boolean{
            return (((((this.isDigit(_arg1)) || ((((_arg1 >= "A")) && ((_arg1 <= "F")))))) || ((((_arg1 >= "a")) && ((_arg1 <= "f"))))));
        }
        public function getNextToken():JSONToken{
            var _local2:String;
            var _local3:String;
            var _local4:String;
            var _local5:String;
            var _local1:JSONToken = new JSONToken();
            this.skipIgnored();
            switch (this.ch){
                case "{":
                    _local1.type = JSONTokenType.LEFT_BRACE;
                    _local1.value = "{";
                    this.nextChar();
                    break;
                case "}":
                    _local1.type = JSONTokenType.RIGHT_BRACE;
                    _local1.value = "}";
                    this.nextChar();
                    break;
                case "[":
                    _local1.type = JSONTokenType.LEFT_BRACKET;
                    _local1.value = "[";
                    this.nextChar();
                    break;
                case "]":
                    _local1.type = JSONTokenType.RIGHT_BRACKET;
                    _local1.value = "]";
                    this.nextChar();
                    break;
                case ",":
                    _local1.type = JSONTokenType.COMMA;
                    _local1.value = ",";
                    this.nextChar();
                    break;
                case ":":
                    _local1.type = JSONTokenType.COLON;
                    _local1.value = ":";
                    this.nextChar();
                    break;
                case "t":
                    _local2 = ((("t" + this.nextChar()) + this.nextChar()) + this.nextChar());
                    if (_local2 == "true"){
                        _local1.type = JSONTokenType.TRUE;
                        _local1.value = true;
                        this.nextChar();
                    } else {
                        this.parseError(("Expecting 'true' but found " + _local2));
                    };
                    break;
                case "f":
                    _local3 = (((("f" + this.nextChar()) + this.nextChar()) + this.nextChar()) + this.nextChar());
                    if (_local3 == "false"){
                        _local1.type = JSONTokenType.FALSE;
                        _local1.value = false;
                        this.nextChar();
                    } else {
                        this.parseError(("Expecting 'false' but found " + _local3));
                    };
                    break;
                case "n":
                    _local4 = ((("n" + this.nextChar()) + this.nextChar()) + this.nextChar());
                    if (_local4 == "null"){
                        _local1.type = JSONTokenType.NULL;
                        _local1.value = null;
                        this.nextChar();
                    } else {
                        this.parseError(("Expecting 'null' but found " + _local4));
                    };
                    break;
                case "N":
                    _local5 = (("N" + this.nextChar()) + this.nextChar());
                    if (_local5 == "NaN"){
                        _local1.type = JSONTokenType.NAN;
                        _local1.value = NaN;
                        this.nextChar();
                    } else {
                        this.parseError(("Expecting 'NaN' but found " + _local5));
                    };
                    break;
                case "\"":
                    _local1 = this.readString();
                    break;
                default:
                    if (((this.isDigit(this.ch)) || ((this.ch == "-")))){
                        _local1 = this.readNumber();
                    } else {
                        if (this.ch == ""){
                            return (null);
                        };
                        this.parseError((("Unexpected " + this.ch) + " encountered"));
                    };
            };
            return (_local1);
        }

    }
}//package com.adobe.serialization.json 
﻿package com.adobe.serialization.json {

    public class JSONParseError extends Error {

        private var _location:int;
        private var _text:String;

        public function JSONParseError(_arg1:String="", _arg2:int=0, _arg3:String=""){
            super(_arg1);
            name = "JSONParseError";
            this._location = _arg2;
            this._text = _arg3;
        }
        public function get location():int{
            return (this._location);
        }
        public function get text():String{
            return (this._text);
        }

    }
}//package com.adobe.serialization.json 
﻿package {
    import mx.resources.*;

    public class en_US$validators_properties extends ResourceBundle {

        public function en_US$validators_properties(){
            super("en_US", "validators");
        }
        override protected function getContent():Object{
            var _local1:Object = {
                PAttributeMissing:"The property attribute must be specified when the source attribute is specified.",
                wrongLengthErrorDV:"Type the date in the format.",
                maxLength:"NaN",
                invalidDomainErrorZCV:"The domain parameter is invalid. It must be either 'US Only', 'Canada Only', or 'US or Canada'.",
                creditCardValidatorAllowedFormatChars:" -",
                wrongFormatError:"The Social Security number must be 9 digits or in the form NNN-NN-NNNN.",
                invalidNumberError:"The credit card number is invalid.",
                CNSAttribute:"The cardNumberSource attribute, '{0}', can not be of type String.",
                invalidCharErrorCCV:"Invalid characters in your credit card number. (Enter numbers only.)",
                thousandsSeparator:",",
                minDigitsPNV:"10",
                wrongLengthErrorPNV:"Your telephone number must contain at least {0} digits.",
                invalidPeriodsInDomainError:"The domain in your e-mail address has consecutive periods.",
                precisionError:"The amount entered has too many digits beyond the decimal point.",
                wrongUSFormatError:"The ZIP+4 code must be formatted '12345-6789'.",
                separationError:"The thousands separator must be followed by three digits.",
                DSAttribute:"The daySource attribute, '{0}', can not be of type String.",
                zipCodeValidatorDomain:"US Only",
                exceedsMaxErrorCV:"The amount entered is too large.",
                allowNegative:"true",
                decimalPointCountError:"The decimal separator can occur only once.",
                requiredFieldError:"This field is required.",
                missingPeriodInDomainError:"The domain in your e-mail address is missing a period.",
                invalidCharError:"The input contains invalid characters.",
                SAttribute:"The source attribute, '{0}', can not be of type String.",
                wrongCAFormatError:"The Canadian postal code must be formatted 'A1B 2C3'.",
                wrongLengthErrorCCV:"Your credit card number contains the wrong number of digits.",
                tooShortError:"This string is shorter than the minimum allowed length. This must be at least {0} characters long.",
                decimalSeparator:".",
                zeroStartError:"Invalid Social Security number; the number cannot start with 000.",
                invalidFormatChars:"The allowedFormatChars parameter is invalid. It cannot contain any digits.",
                validateAsString:"true",
                invalidCharErrorZCV:"The ZIP code contains invalid characters.",
                exceedsMaxErrorNV:"The number entered is too large.",
                missingCardNumber:"The value being validated doesn't contain a cardNumber property.",
                CTSAttribute:"The cardTypeSource attribute, '{0}', can not be of type String.",
                numberValidatorPrecision:"-1",
                YSAttribute:"The yearSource attribute, '{0}', can not be of type String.",
                negativeError:"The amount may not be negative.",
                fieldNotFound:"'{0}' field not found.",
                noNumError:"No credit card number is specified.",
                SAttributeMissing:"The source attribute must be specified when the property attribute is specified.",
                noTypeError:"No credit card type is specified or the type is not valid.",
                tooManyAtSignsError:"Your e-mail address contains too many @ characters.",
                wrongLengthErrorZCV:"The ZIP code must be 5 digits or 5+4 digits.",
                socialSecurityValidatorAllowedFormatChars:" -",
                wrongYearError:"Enter a year between 0 and 9999.",
                minLength:"NaN",
                missingCardType:"The value being validated doesn't contain a cardType property.",
                noExpressionError:"The expression is missing.",
                maxValue:"NaN",
                invalidDomainErrorEV:"The domain in your e-mail address is incorrectly formatted.",
                numberValidatorDomain:"real",
                minValue:"NaN",
                missingUsernameError:"The username in your e-mail address is missing.",
                invalidCharErrorEV:"Your e-mail address contains invalid characters.",
                MSAttribute:"The monthSource attribute, '{0}', can not be of type String.",
                phoneNumberValidatorAllowedFormatChars:"-()+ .",
                noMatchError:"The field is invalid.",
                wrongMonthError:"Enter a month between 1 and 12.",
                invalidIPDomainError:"The IP domain in your e-mail address is incorrectly formatted.",
                dateValidatorAllowedFormatChars:"/- \\.",
                integerError:"The number must be an integer.",
                currencyValidatorPrecision:"2",
                invalidFormatCharsZCV:"The allowedFormatChars parameter is invalid. Alphanumeric characters are not allowed (a-z A-Z 0-9).",
                formatError:"Configuration error: Incorrect formatting string.",
                wrongDayError:"Enter a valid day for the month.",
                lowerThanMinError:"The amount entered is too small.",
                zipCodeValidatorAllowedFormatChars:" -",
                invalidCharErrorPNV:"Your telephone number contains invalid characters.",
                invalidCharErrorDV:"The date contains invalid characters.",
                missingAtSignError:"An at sign (@) is missing in your e-mail address.",
                invalidFormatCharsError:"One of the formatting parameters is invalid.",
                wrongTypeError:"Incorrect card type is specified.",
                tooLongError:"This string is longer than the maximum allowed length. This must be less than {0} characters long.",
                currencySymbolError:"The currency symbol occurs in an invalid location.",
                invalidCharErrorSSV:"You entered invalid characters in your Social Security number."
            };
            return (_local1);
        }

    }
}//package 
﻿package mx.rpc {
    import mx.messaging.messages.*;
    import mx.messaging.events.*;
    import mx.messaging.*;

    public class AsyncRequest extends Producer {

        private var _pendingRequests:Object;

        public function AsyncRequest(){
            _pendingRequests = {};
            super();
        }
        override public function hasPendingRequestForMessage(_arg1:IMessage):Boolean{
            var _local2:String = _arg1.messageId;
            return (_pendingRequests[_local2]);
        }
        override public function fault(_arg1:ErrorMessage, _arg2:IMessage):void{
            super.fault(_arg1, _arg2);
            if (_ignoreFault){
                return;
            };
            var _local3:String = _arg2.messageId;
            var _local4:IResponder = IResponder(_pendingRequests[_local3]);
            if (_local4){
                delete _pendingRequests[_local3];
                _local4.fault(MessageFaultEvent.createEvent(_arg1));
            };
        }
        public function invoke(_arg1:IMessage, _arg2:IResponder):void{
            _pendingRequests[_arg1.messageId] = _arg2;
            send(_arg1);
        }
        override public function acknowledge(_arg1:AcknowledgeMessage, _arg2:IMessage):void{
            var _local4:String;
            var _local5:IResponder;
            var _local3:Boolean = _arg1.headers[AcknowledgeMessage.ERROR_HINT_HEADER];
            super.acknowledge(_arg1, _arg2);
            if (!_local3){
                _local4 = _arg1.correlationId;
                _local5 = IResponder(_pendingRequests[_local4]);
                if (_local5){
                    delete _pendingRequests[_local4];
                    _local5.result(MessageEvent.createEvent(MessageEvent.RESULT, _arg1));
                };
            };
        }

    }
}//package mx.rpc 
﻿package mx.rpc {

    public class ActiveCalls {

        private var callOrder:Array;
        private var calls:Object;

        public function ActiveCalls(){
            calls = {};
            callOrder = [];
        }
        public function removeCall(_arg1:String):AsyncToken{
            var _local2:AsyncToken = calls[_arg1];
            if (_local2 != null){
                delete calls[_arg1];
                callOrder.splice(callOrder.lastIndexOf(_arg1), 1);
            };
            return (_local2);
        }
        public function cancelLast():AsyncToken{
            if (callOrder.length > 0){
                return (removeCall((callOrder[(callOrder.length - 1)] as String)));
            };
            return (null);
        }
        public function hasActiveCalls():Boolean{
            return ((callOrder.length > 0));
        }
        public function wasLastCall(_arg1:String):Boolean{
            if (callOrder.length > 0){
                return ((callOrder[(callOrder.length - 1)] == _arg1));
            };
            return (false);
        }
        public function getAllMessages():Array{
            var _local2:String;
            var _local1:Array = [];
            for (_local2 in calls) {
                _local1.push(calls[_local2]);
            };
            return (_local1);
        }
        public function addCall(_arg1:String, _arg2:AsyncToken):void{
            calls[_arg1] = _arg2;
            callOrder.push(_arg1);
        }

    }
}//package mx.rpc 
﻿package mx.rpc.mxml {

    public final class Concurrency {

        public static const MULTIPLE:String = "multiple";
        public static const LAST:String = "last";
        public static const SINGLE:String = "single";

    }
}//package mx.rpc.mxml 
﻿package mx.rpc.http {
    import mx.rpc.*;
    import mx.core.*;

    public class HTTPService extends AbstractInvoker {

        public static const RESULT_FORMAT_E4X:String = "e4x";
        public static const ERROR_URL_REQUIRED:String = "Client.URLRequired";
        public static const RESULT_FORMAT_XML:String = "xml";
        public static const CONTENT_TYPE_FORM:String = "application/x-www-form-urlencoded";
        public static const RESULT_FORMAT_TEXT:String = "text";
        public static const RESULT_FORMAT_FLASHVARS:String = "flashvars";
        public static const DEFAULT_DESTINATION_HTTP:String = "DefaultHTTP";
        public static const CONTENT_TYPE_XML:String = "application/xml";
        public static const ERROR_ENCODING:String = "Client.CouldNotEncode";
        public static const RESULT_FORMAT_ARRAY:String = "array";
        public static const DEFAULT_DESTINATION_HTTPS:String = "DefaultHTTPS";
        public static const RESULT_FORMAT_OBJECT:String = "object";
        public static const ERROR_DECODING:String = "Client.CouldNotDecode";

        mx_internal var operation:AbstractOperation;

        public function HTTPService(_arg1:String=null, _arg2:String=null){
            operation = new HTTPOperation(this);
            operation.makeObjectsBindable = true;
            operation._rootURL = _arg1;
            if (_arg2 == null){
                asyncRequest.destination = DEFAULT_DESTINATION_HTTP;
            } else {
                asyncRequest.destination = _arg2;
                useProxy = true;
            };
        }
        public function setCredentials(_arg1:String, _arg2:String, _arg3:String=null):void{
            asyncRequest.setCredentials(_arg1, _arg2, _arg3);
        }
        public function set method(_arg1:String):void{
            operation.method = _arg1;
        }
        public function get headers():Object{
            return (operation.headers);
        }
        public function get serializationFilter():SerializationFilter{
            return (operation.serializationFilter);
        }
        override public function cancel(_arg1:String=null):AsyncToken{
            return (operation.cancel(_arg1));
        }
        public function set xmlDecode(_arg1:Function):void{
            operation.xmlDecode = _arg1;
        }
        public function set headers(_arg1:Object):void{
            operation.headers = _arg1;
        }
        override public function addEventListener(_arg1:String, _arg2:Function, _arg3:Boolean=false, _arg4:int=0, _arg5:Boolean=false):void{
            operation.addEventListener(_arg1, _arg2, _arg3, _arg4, _arg5);
            super.addEventListener(_arg1, _arg2, _arg3, _arg4, _arg5);
        }
        public function get destination():String{
            return (asyncRequest.destination);
        }
        public function get request():Object{
            return (operation.request);
        }
        public function set serializationFilter(_arg1:SerializationFilter):void{
            operation.serializationFilter = _arg1;
        }
        override public function clearResult(_arg1:Boolean=true):void{
            operation.clearResult(_arg1);
        }
        public function get requestTimeout():int{
            return (asyncRequest.requestTimeout);
        }
        public function get concurrency():String{
            return (operation.concurrency);
        }
        public function send(_arg1:Object=null):AsyncToken{
            if (_arg1 == null){
                _arg1 = request;
            };
            return (operation.sendBody(_arg1));
        }
        public function set showBusyCursor(_arg1:Boolean):void{
            operation.showBusyCursor = _arg1;
        }
        public function logout():void{
            asyncRequest.logout();
        }
        public function set rootURL(_arg1:String):void{
            operation.rootURL = _arg1;
        }
        public function get showBusyCursor():Boolean{
            return (operation.showBusyCursor);
        }
        public function set destination(_arg1:String):void{
            useProxy = true;
            asyncRequest.destination = _arg1;
        }
        public function set useProxy(_arg1:Boolean):void{
            operation.useProxy = _arg1;
        }
        public function set request(_arg1:Object):void{
            operation.request = _arg1;
        }
        public function get method():String{
            return (operation.method);
        }
        public function get contentType():String{
            return (operation.contentType);
        }
        public function disconnect():void{
            asyncRequest.disconnect();
        }
        public function set requestTimeout(_arg1:int):void{
            if (asyncRequest.requestTimeout != _arg1){
                asyncRequest.requestTimeout = _arg1;
            };
        }
        public function set url(_arg1:String):void{
            operation.url = _arg1;
        }
        public function set contentType(_arg1:String):void{
            operation.contentType = _arg1;
        }
        public function set resultFormat(_arg1:String):void{
            operation.resultFormat = _arg1;
        }
        public function set xmlEncode(_arg1:Function):void{
            operation.xmlEncode = _arg1;
        }
        override public function get lastResult():Object{
            return (operation.lastResult);
        }
        public function get xmlDecode():Function{
            return (operation.xmlDecode);
        }
        public function get rootURL():String{
            return (operation.rootURL);
        }
        public function get useProxy():Boolean{
            return (operation.useProxy);
        }
        public function get url():String{
            return (operation.url);
        }
        public function get xmlEncode():Function{
            return (operation.xmlEncode);
        }
        override mx_internal function get asyncRequest():AsyncRequest{
            return (operation.asyncRequest);
        }
        public function get resultFormat():String{
            return (operation.resultFormat);
        }
        override mx_internal function set asyncRequest(_arg1:AsyncRequest):void{
            operation.asyncRequest = _arg1;
        }
        public function setRemoteCredentials(_arg1:String, _arg2:String, _arg3:String=null):void{
            asyncRequest.setRemoteCredentials(_arg1, _arg2, _arg3);
        }
        override public function set makeObjectsBindable(_arg1:Boolean):void{
            operation.makeObjectsBindable = _arg1;
        }
        override public function get makeObjectsBindable():Boolean{
            return (operation.makeObjectsBindable);
        }
        public function set concurrency(_arg1:String):void{
            operation.concurrency = _arg1;
        }

    }
}//package mx.rpc.http 

import mx.rpc.events.*;
import mx.core.*;

class HTTPOperation extends AbstractOperation {

    private var httpService:HTTPService;

    public function HTTPOperation(_arg1:HTTPService, _arg2:String=null){
        super(null, _arg2);
        this.httpService = _arg1;
    }
    override mx_internal function dispatchRpcEvent(_arg1:AbstractEvent):void{
        if (hasEventListener(_arg1.type)){
            _arg1.callTokenResponders();
            if (!_arg1.isDefaultPrevented()){
                dispatchEvent(_arg1);
            };
        } else {
            if (httpService != null){
                httpService.dispatchRpcEvent(_arg1);
            } else {
                _arg1.callTokenResponders();
            };
        };
    }

}
﻿package mx.rpc.http {
    import mx.core.*;

    public class SerializationFilter {

        mx_internal static var filterForResultFormatTable:Object = new Object();

        public static function registerFilterForResultFormat(_arg1:String, _arg2:SerializationFilter):SerializationFilter{
            var _local3:SerializationFilter = filterForResultFormatTable[_arg1];
            filterForResultFormatTable[_arg1] = _arg2;
            return (_local3);
        }

        public function getRequestContentType(_arg1:AbstractOperation, _arg2:Object, _arg3:String):String{
            return (_arg3);
        }
        public function serializeBody(_arg1:AbstractOperation, _arg2:Object):Object{
            return (_arg2);
        }
        public function serializeParameters(_arg1:AbstractOperation, _arg2:Array):Object{
            var _local3:Array = _arg1.argumentNames;
            if ((((_arg2 == null)) || ((_arg2.length == 0)))){
                return (_arg2);
            };
            if ((((_local3 == null)) || (!((_arg2.length == _local3.length))))){
                throw (new ArgumentError((((("HTTPMultiService operation called with " + (((_local3 == null)) ? 0 : _local3.length)) + " argumentNames and ") + _arg2.length) + " number of parameters.  When argumentNames is specified, it must match the number of arguments passed to the invocation")));
            };
            var _local4:Object = new Object();
            var _local5:int;
            while (_local5 < _local3.length) {
                _local4[_local3[_local5]] = _arg2[_local5];
                _local5++;
            };
            return (_local4);
        }
        public function deserializeResult(_arg1:AbstractOperation, _arg2:Object):Object{
            return (_arg2);
        }
        public function serializeURL(_arg1:AbstractOperation, _arg2:Object, _arg3:String):String{
            return (_arg3);
        }

    }
}//package mx.rpc.http 
﻿package mx.rpc.http {
    import mx.rpc.*;
    import flash.utils.*;
    import mx.collections.*;
    import mx.messaging.messages.*;
    import mx.rpc.events.*;
    import mx.messaging.events.*;
    import mx.messaging.*;
    import mx.resources.*;
    import mx.logging.*;
    import flash.xml.*;
    import mx.messaging.channels.*;
    import mx.utils.*;
    import mx.messaging.config.*;
    import mx.core.*;
    import mx.netmon.*;
    import mx.rpc.xml.*;
    import mx.rpc.mxml.*;

    public class AbstractOperation extends AbstractOperation {

        mx_internal static const RESULT_FORMAT_E4X:String = "e4x";
        private static const ERROR_DECODING:String = "Client.CouldNotDecode";
        mx_internal static const RESULT_FORMAT_OBJECT:String = "object";
        private static const ERROR_URL_REQUIRED:String = "Client.URLRequired";
        mx_internal static const RESULT_FORMAT_XML:String = "xml";
        mx_internal static const CONTENT_TYPE_FORM:String = "application/x-www-form-urlencoded";
        mx_internal static const RESULT_FORMAT_TEXT:String = "text";
        mx_internal static const RESULT_FORMAT_FLASHVARS:String = "flashvars";
        mx_internal static const CONTENT_TYPE_XML:String = "application/xml";
        private static const ERROR_ENCODING:String = "Client.CouldNotEncode";
        mx_internal static const RESULT_FORMAT_ARRAY:String = "array";

        private static var _directChannelSet:ChannelSet;

        private var _method:String = "GET";
        mx_internal var _log:ILogger;
        private var _useProxy:Boolean = false;
        public var serializationFilter:SerializationFilter;
        public var argumentNames:Array;
        public var xmlEncode:Function;
        public var request:Object;
        private var _contentType:String = "application/x-www-form-urlencoded";
        public var headers:Object;
        private var _url:String;
        private var _showBusyCursor:Boolean = false;
        mx_internal var resourceManager:IResourceManager;
        private var _resultFormat:String = "object";
        private var _concurrency:String;
        public var xmlDecode:Function;
        mx_internal var _rootURL:String;

        public function AbstractOperation(_arg1:AbstractService=null, _arg2:String=null){
            request = {};
            headers = {};
            resourceManager = ResourceManager.getInstance();
            super(_arg1, _arg2);
            _log = Log.getLogger("mx.rpc.http.HTTPService");
            concurrency = Concurrency.MULTIPLE;
        }
        private function decodeArray(_arg1:Object):Object{
            var _local2:Array;
            if ((_arg1 is Array)){
                _local2 = (_arg1 as Array);
            } else {
                if ((_arg1 is ArrayCollection)){
                    return (_arg1);
                };
                _local2 = [];
                _local2.push(_arg1);
            };
            if (makeObjectsBindable){
                return (new ArrayCollection(_local2));
            };
            return (_local2);
        }
        public function get concurrency():String{
            return (_concurrency);
        }
        public function set showBusyCursor(_arg1:Boolean):void{
            _showBusyCursor = _arg1;
        }
        public function get showBusyCursor():Boolean{
            return (_showBusyCursor);
        }
        private function getDirectChannelSet():ChannelSet{
            var _local1:ChannelSet;
            if (_directChannelSet == null){
                _local1 = new ChannelSet();
                _local1.addChannel(new DirectHTTPChannel("direct_http_channel"));
                _directChannelSet = _local1;
            };
            return (_directChannelSet);
        }
        public function set concurrency(_arg1:String):void{
            _concurrency = _arg1;
        }
        public function get useProxy():Boolean{
            return (_useProxy);
        }
        override mx_internal function preHandle(_arg1:MessageEvent):AsyncToken{
            if (showBusyCursor){
            };
            var _local2:Boolean = activeCalls.wasLastCall(AsyncMessage(_arg1.message).correlationId);
            var _local3:AsyncToken = super.preHandle(_arg1);
            if ((((Concurrency.LAST == concurrency)) && (!(_local2)))){
                return (null);
            };
            return (_local3);
        }
        public function get rootURL():String{
            if (_rootURL == null){
                _rootURL = LoaderConfig.url;
            };
            return (_rootURL);
        }
        public function set contentType(_arg1:String):void{
            _contentType = _arg1;
        }
        public function set method(_arg1:String):void{
            _method = _arg1;
        }
        private function decodeParameterString(_arg1:String):Object{
            var _local6:String;
            var _local7:int;
            var _local8:String;
            var _local9:String;
            var _local2:String = StringUtil.trim(_arg1);
            var _local3:Array = _local2.split("&");
            var _local4:Object = {};
            var _local5:int;
            while (_local5 < _local3.length) {
                _local6 = _local3[_local5];
                _local7 = _local6.indexOf("=");
                if (_local7 != -1){
                    _local8 = _local6.substr(0, _local7);
                    _local8 = _local8.split("+").join(" ");
                    _local8 = unescape(_local8);
                    _local9 = _local6.substr((_local7 + 1));
                    _local9 = _local9.split("+").join(" ");
                    _local9 = unescape(_local9);
                    _local4[_local8] = _local9;
                };
                _local5++;
            };
            return (_local4);
        }
        public function set useProxy(_arg1:Boolean):void{
            var _local2:ChannelSet;
            if (_arg1 != _useProxy){
                _useProxy = _arg1;
                _local2 = getDirectChannelSet();
                if (!useProxy){
                    if (_local2 != asyncRequest.channelSet){
                        asyncRequest.channelSet = _local2;
                    };
                } else {
                    if (asyncRequest.channelSet == _local2){
                        asyncRequest.channelSet = null;
                    };
                };
            };
        }
        protected function getHeaders():Object{
            return (headers);
        }
        public function sendBody(_arg1:Object):AsyncToken{
            var _local3:Object;
            var _local4:AsyncToken;
            var _local5:Fault;
            var _local6:FaultEvent;
            var _local7:String;
            var _local11:String;
            var _local12:Object;
            var _local13:SimpleXMLEncoder;
            var _local14:XMLDocument;
            var _local15:Array;
            var _local16:int;
            var _local17:Object;
            var _local18:Object;
            var _local19:*;
            var _local20:ChannelSet;
            var _local2:SerializationFilter = getSerializationFilter();
            if ((((Concurrency.SINGLE == concurrency)) && (activeCalls.hasActiveCalls()))){
                _local4 = new AsyncToken(null);
                _local11 = resourceManager.getString("rpc", "pendingCallExists");
                _local5 = new Fault("ConcurrencyError", _local11);
                _local6 = FaultEvent.createEvent(_local5, _local4);
                new AsyncDispatcher(dispatchRpcEvent, [_local6], 10);
                return (_local4);
            };
            var _local8:String = contentType;
            var _local9:String = url;
            if (_local2 != null){
                _local8 = _local2.getRequestContentType(this, _arg1, _local8);
                _local9 = _local2.serializeURL(this, _arg1, _local9);
                _arg1 = _local2.serializeBody(this, _arg1);
            };
            if (_local8 == CONTENT_TYPE_XML){
                if ((((_arg1 is String)) && ((xmlEncode == null)))){
                    _local3 = (_arg1 as String);
                } else {
                    if (((!((_arg1 is XMLNode))) && (!((_arg1 is XML))))){
                        if (xmlEncode != null){
                            _local12 = xmlEncode(_arg1);
                            if (null == _local12){
                                _local4 = new AsyncToken(null);
                                _local7 = resourceManager.getString("rpc", "xmlEncodeReturnNull");
                                _local5 = new Fault(ERROR_ENCODING, _local7);
                                _local6 = FaultEvent.createEvent(_local5, _local4);
                                new AsyncDispatcher(dispatchRpcEvent, [_local6], 10);
                                return (_local4);
                            };
                            if (!(_local12 is XMLNode)){
                                _local4 = new AsyncToken(null);
                                _local7 = resourceManager.getString("rpc", "xmlEncodeReturnNoXMLNode");
                                _local5 = new Fault(ERROR_ENCODING, _local7);
                                _local6 = FaultEvent.createEvent(_local5, _local4);
                                new AsyncDispatcher(dispatchRpcEvent, [_local6], 10);
                                return (_local4);
                            };
                            _local3 = XMLNode(_local12).toString();
                        } else {
                            _local13 = new SimpleXMLEncoder(null);
                            _local14 = new XMLDocument();
                            _local15 = _local13.encodeValue(_arg1, new QName(null, "encoded"), new XMLNode(1, "top")).childNodes.concat();
                            _local16 = 0;
                            while (_local16 < _local15.length) {
                                _local14.appendChild(_local15[_local16]);
                                _local16++;
                            };
                            _local3 = _local14.toString();
                        };
                    } else {
                        _local3 = XML(_arg1).toXMLString();
                    };
                };
            } else {
                if (_local8 == CONTENT_TYPE_FORM){
                    _local3 = {};
                    if (typeof(_arg1) == "object"){
                        _local18 = ObjectUtil.getClassInfo(_arg1);
                        for each (_local19 in _local18.properties) {
                            _local17 = _arg1[_local19];
                            if (_local17 != null){
                                if ((_local17 is Array)){
                                    _local3[_local19] = _local17;
                                } else {
                                    _local3[_local19] = _local17.toString();
                                };
                            };
                        };
                    } else {
                        _local3 = _arg1;
                    };
                } else {
                    _local3 = _arg1;
                };
            };
            var _local10:HTTPRequestMessage = new HTTPRequestMessage();
            if (useProxy){
                if (((_local9) && (!((_local9 == ""))))){
                    _local10.url = URLUtil.getFullURL(rootURL, _local9);
                };
                if (NetworkMonitor.isMonitoring()){
                    _local10.recordHeaders = true;
                };
            } else {
                if (!_local9){
                    _local4 = new AsyncToken(null);
                    _local7 = resourceManager.getString("rpc", "urlNotSpecified");
                    _local5 = new Fault(ERROR_URL_REQUIRED, _local7);
                    _local6 = FaultEvent.createEvent(_local5, _local4);
                    new AsyncDispatcher(dispatchRpcEvent, [_local6], 10);
                    return (_local4);
                };
                if (!useProxy){
                    _local20 = getDirectChannelSet();
                    if (_local20 != asyncRequest.channelSet){
                        asyncRequest.channelSet = _local20;
                    };
                };
                if (NetworkMonitor.isMonitoring()){
                    _local10.recordHeaders = true;
                };
                _local10.url = URLUtil.getFullURL(rootURL, _local9);
            };
            _local10.contentType = _local8;
            _local10.method = method.toUpperCase();
            if ((((_local8 == CONTENT_TYPE_XML)) && ((_local10.method == HTTPRequestMessage.GET_METHOD)))){
                _local10.method = HTTPRequestMessage.POST_METHOD;
            };
            _local10.body = _local3;
            _local10.httpHeaders = getHeaders();
            return (invoke(_local10));
        }
        protected function getSerializationFilter():SerializationFilter{
            return (serializationFilter);
        }
        public function get contentType():String{
            return (_contentType);
        }
        public function set url(_arg1:String):void{
            _url = _arg1;
        }
        public function get method():String{
            return (_method);
        }
        public function set resultFormat(_arg1:String):void{
            var _local2:SerializationFilter;
            var _local3:String;
            switch (_arg1){
                case RESULT_FORMAT_OBJECT:
                case RESULT_FORMAT_ARRAY:
                case RESULT_FORMAT_XML:
                case RESULT_FORMAT_E4X:
                case RESULT_FORMAT_TEXT:
                case RESULT_FORMAT_FLASHVARS:
                    break;
                default:
                    if (((!((_arg1 == null))) && (((_local2 = SerializationFilter.filterForResultFormatTable[_arg1]) == null)))){
                        _local3 = resourceManager.getString("rpc", "invalidResultFormat", [_arg1, RESULT_FORMAT_OBJECT, RESULT_FORMAT_ARRAY, RESULT_FORMAT_XML, RESULT_FORMAT_E4X, RESULT_FORMAT_TEXT, RESULT_FORMAT_FLASHVARS]);
                        throw (new ArgumentError(_local3));
                    };
                    serializationFilter = _local2;
            };
            _resultFormat = _arg1;
        }
        public function set rootURL(_arg1:String):void{
            _rootURL = _arg1;
        }
        override mx_internal function processResult(_arg1:IMessage, _arg2:AsyncToken):Boolean{
            var tmp:* = null;
            var fault:* = null;
            var decoded:* = null;
            var msg:* = null;
            var fault1:* = null;
            var decoder:* = null;
            var fault2:* = null;
            var fault3:* = null;
            var message:* = _arg1;
            var token:* = _arg2;
            var body:* = message.body;
            _log.info("Decoding HTTPService response");
            _log.debug("Processing HTTPService response message:\n{0}", message);
            var filter:* = getSerializationFilter();
            if (filter != null){
                body = filter.deserializeResult(this, body);
            };
            if ((((body == null)) || (((((!((body == null))) && ((body is String)))) && ((StringUtil.trim(String(body)) == "")))))){
                _result = body;
                return (true);
            };
            if ((body is String)){
                if ((((((resultFormat == RESULT_FORMAT_XML)) || ((resultFormat == RESULT_FORMAT_OBJECT)))) || ((resultFormat == RESULT_FORMAT_ARRAY)))){
                    tmp = new XMLDocument();
                    XMLDocument(tmp).ignoreWhite = true;
                    try {
                        XMLDocument(tmp).parseXML(String(body));
                    } catch(parseError:Error) {
                        fault = new Fault(ERROR_DECODING, parseError.message);
                        dispatchRpcEvent(FaultEvent.createEvent(fault, token, message));
                        return (false);
                    };
                    if ((((resultFormat == RESULT_FORMAT_OBJECT)) || ((resultFormat == RESULT_FORMAT_ARRAY)))){
                        if (xmlDecode != null){
                            decoded = xmlDecode(tmp);
                            if (decoded == null){
                                msg = resourceManager.getString("rpc", "xmlDecodeReturnNull");
                                fault1 = new Fault(ERROR_DECODING, msg);
                                dispatchRpcEvent(FaultEvent.createEvent(fault1, token, message));
                            };
                        } else {
                            decoder = new SimpleXMLDecoder(makeObjectsBindable);
                            decoded = decoder.decodeXML(XMLNode(tmp));
                            if (decoded == null){
                                msg = resourceManager.getString("rpc", "defaultDecoderFailed");
                                fault2 = new Fault(ERROR_DECODING, msg);
                                dispatchRpcEvent(FaultEvent.createEvent(fault2, token, message));
                            };
                        };
                        if (decoded == null){
                            return (false);
                        };
                        if (((makeObjectsBindable) && ((getQualifiedClassName(decoded) == "Object")))){
                            decoded = new ObjectProxy(decoded);
                        } else {
                            decoded = decoded;
                        };
                        if (resultFormat == RESULT_FORMAT_ARRAY){
                            decoded = decodeArray(decoded);
                        };
                        _result = decoded;
                    } else {
                        if (tmp.childNodes.length == 1){
                            tmp = tmp.firstChild;
                        };
                        _result = tmp;
                    };
                } else {
                    if (resultFormat == RESULT_FORMAT_E4X){
                        try {
                            _result = new XML(String(body));
                        } catch(error:Error) {
                            fault3 = new Fault(ERROR_DECODING, error.message);
                            dispatchRpcEvent(FaultEvent.createEvent(fault3, token, message));
                            return (false);
                        };
                    } else {
                        if (resultFormat == RESULT_FORMAT_FLASHVARS){
                            _result = decodeParameterString(String(body));
                        } else {
                            _result = body;
                        };
                    };
                };
            } else {
                if (resultFormat == RESULT_FORMAT_ARRAY){
                    body = decodeArray(body);
                };
                _result = body;
            };
            return (true);
        }
        public function get url():String{
            return (_url);
        }
        public function get resultFormat():String{
            return (_resultFormat);
        }
        override mx_internal function invoke(_arg1:IMessage, _arg2:AsyncToken=null):AsyncToken{
            if (showBusyCursor){
            };
            return (super.invoke(_arg1, _arg2));
        }
        override public function cancel(_arg1:String=null):AsyncToken{
            if (showBusyCursor){
            };
            return (super.cancel(_arg1));
        }

    }
}//package mx.rpc.http 
﻿package mx.rpc {
    import flash.events.*;
    import mx.events.*;
    import mx.messaging.messages.*;
    import mx.rpc.events.*;
    import mx.core.*;

    public dynamic class AsyncToken extends EventDispatcher {

        private var _message:IMessage;
        private var _responders:Array;
        private var _result:Object;

        public function AsyncToken(_arg1:IMessage=null){
            _message = _arg1;
        }
        public function addResponder(_arg1:IResponder):void{
            if (_responders == null){
                _responders = [];
            };
            _responders.push(_arg1);
        }
        mx_internal function setMessage(_arg1:IMessage):void{
            _message = _arg1;
        }
        public function get message():IMessage{
            return (_message);
        }
        mx_internal function applyResult(_arg1:ResultEvent):void{
            var _local2:uint;
            var _local3:IResponder;
            setResult(_arg1.result);
            if (_responders != null){
                _local2 = 0;
                while (_local2 < _responders.length) {
                    _local3 = _responders[_local2];
                    if (_local3 != null){
                        _local3.result(_arg1);
                    };
                    _local2++;
                };
            };
        }
        public function hasResponder():Boolean{
            return (((!((_responders == null))) && ((_responders.length > 0))));
        }
        public function get responders():Array{
            return (_responders);
        }
        mx_internal function applyFault(_arg1:FaultEvent):void{
            var _local2:uint;
            var _local3:IResponder;
            if (_responders != null){
                _local2 = 0;
                while (_local2 < _responders.length) {
                    _local3 = _responders[_local2];
                    if (_local3 != null){
                        _local3.fault(_arg1);
                    };
                    _local2++;
                };
            };
        }
        public function get result():Object{
            return (_result);
        }
        mx_internal function setResult(_arg1:Object):void{
            var _local2:PropertyChangeEvent;
            if (_result !== _arg1){
                _local2 = PropertyChangeEvent.createUpdateEvent(this, "result", _result, _arg1);
                _result = _arg1;
                dispatchEvent(_local2);
            };
        }

    }
}//package mx.rpc 
﻿package mx.rpc {

    public class Fault extends Error {

        public var rootCause:Object;
        protected var _faultCode:String;
        protected var _faultString:String;
        public var content:Object;
        protected var _faultDetail:String;

        public function Fault(_arg1:String, _arg2:String, _arg3:String=null){
            super((((((("faultCode:" + _arg1) + " faultString:'") + _arg2) + "' faultDetail:'") + _arg3) + "'"));
            this._faultCode = _arg1;
            this._faultString = ((_arg2) ? _arg2 : "");
            this._faultDetail = _arg3;
        }
        public function get faultString():String{
            return (_faultString);
        }
        public function toString():String{
            var _local1 = "[RPC Fault";
            _local1 = (_local1 + ((" faultString=\"" + faultString) + "\""));
            _local1 = (_local1 + ((" faultCode=\"" + faultCode) + "\""));
            _local1 = (_local1 + ((" faultDetail=\"" + faultDetail) + "\"]"));
            return (_local1);
        }
        public function get faultCode():String{
            return (_faultCode);
        }
        public function get faultDetail():String{
            return (_faultDetail);
        }

    }
}//package mx.rpc 
﻿package mx.rpc {

    public class Responder implements IResponder {

        private var _faultHandler:Function;
        private var _resultHandler:Function;

        public function Responder(_arg1:Function, _arg2:Function){
            _resultHandler = _arg1;
            _faultHandler = _arg2;
        }
        public function result(_arg1:Object):void{
            _resultHandler(_arg1);
        }
        public function fault(_arg1:Object):void{
            _faultHandler(_arg1);
        }

    }
}//package mx.rpc 
﻿package mx.rpc.events {
    import flash.events.*;
    import mx.rpc.*;
    import mx.messaging.messages.*;
    import mx.core.*;

    public class ResultEvent extends AbstractEvent {

        public static const RESULT:String = "result";

        private var _headers:Object;
        private var _result:Object;
        private var _statusCode:int;

        public function ResultEvent(_arg1:String, _arg2:Boolean=false, _arg3:Boolean=true, _arg4:Object=null, _arg5:AsyncToken=null, _arg6:IMessage=null){
            super(_arg1, _arg2, _arg3, _arg5, _arg6);
            if (((!((_arg6 == null))) && (!((_arg6.headers == null))))){
                _statusCode = (_arg6.headers[AbstractMessage.STATUS_CODE_HEADER] as int);
            };
            _result = _arg4;
        }
        public static function createEvent(_arg1:Object=null, _arg2:AsyncToken=null, _arg3:IMessage=null):ResultEvent{
            return (new ResultEvent(ResultEvent.RESULT, false, true, _arg1, _arg2, _arg3));
        }

        override public function clone():Event{
            return (new ResultEvent(type, bubbles, cancelable, result, token, message));
        }
        public function get headers():Object{
            return (_headers);
        }
        override public function toString():String{
            return (formatToString("ResultEvent", "messageId", "type", "bubbles", "cancelable", "eventPhase"));
        }
        override mx_internal function callTokenResponders():void{
            if (token != null){
                token.applyResult(this);
            };
        }
        public function get statusCode():int{
            return (_statusCode);
        }
        public function set headers(_arg1:Object):void{
            _headers = _arg1;
        }
        public function get result():Object{
            return (_result);
        }
        mx_internal function setResult(_arg1:Object):void{
            _result = _arg1;
        }

    }
}//package mx.rpc.events 
﻿package mx.rpc.events {
    import flash.events.*;
    import mx.rpc.*;
    import mx.messaging.messages.*;
    import mx.messaging.events.*;
    import mx.core.*;

    public class FaultEvent extends AbstractEvent {

        public static const FAULT:String = "fault";

        private var _fault:Fault;
        private var _headers:Object;
        private var _statusCode:int;

        public function FaultEvent(_arg1:String, _arg2:Boolean=false, _arg3:Boolean=true, _arg4:Fault=null, _arg5:AsyncToken=null, _arg6:IMessage=null){
            super(_arg1, _arg2, _arg3, _arg5, _arg6);
            if (((!((_arg6 == null))) && (!((_arg6.headers == null))))){
                _statusCode = (_arg6.headers[AbstractMessage.STATUS_CODE_HEADER] as int);
            };
            _fault = _arg4;
        }
        public static function createEventFromMessageFault(_arg1:MessageFaultEvent, _arg2:AsyncToken=null):FaultEvent{
            var _local3:Fault = new Fault(_arg1.faultCode, _arg1.faultString, _arg1.faultDetail);
            _local3.rootCause = _arg1.rootCause;
            return (new FaultEvent(FaultEvent.FAULT, false, true, _local3, _arg2, _arg1.message));
        }
        public static function createEvent(_arg1:Fault, _arg2:AsyncToken=null, _arg3:IMessage=null):FaultEvent{
            return (new FaultEvent(FaultEvent.FAULT, false, true, _arg1, _arg2, _arg3));
        }

        public function get fault():Fault{
            return (_fault);
        }
        public function set headers(_arg1:Object):void{
            _headers = _arg1;
        }
        override mx_internal function callTokenResponders():void{
            if (token != null){
                token.applyFault(this);
            };
        }
        public function get headers():Object{
            return (_headers);
        }
        override public function toString():String{
            return (formatToString("FaultEvent", "fault", "messageId", "type", "bubbles", "cancelable", "eventPhase"));
        }
        override public function clone():Event{
            return (new FaultEvent(type, bubbles, cancelable, fault, token, message));
        }
        public function get statusCode():int{
            return (_statusCode);
        }

    }
}//package mx.rpc.events 
﻿package mx.rpc.events {
    import mx.rpc.*;
    import mx.messaging.messages.*;
    import mx.messaging.events.*;
    import mx.core.*;

    public class AbstractEvent extends MessageEvent {

        private var _token:AsyncToken;

        public function AbstractEvent(_arg1:String, _arg2:Boolean=false, _arg3:Boolean=true, _arg4:AsyncToken=null, _arg5:IMessage=null){
            super(_arg1, _arg2, _arg3, _arg5);
            _token = _arg4;
        }
        public function get token():AsyncToken{
            return (_token);
        }
        mx_internal function callTokenResponders():void{
        }
        mx_internal function setToken(_arg1:AsyncToken):void{
            _token = _arg1;
        }

    }
}//package mx.rpc.events 
﻿package mx.rpc.events {
    import flash.events.*;
    import mx.rpc.*;
    import mx.messaging.messages.*;

    public class InvokeEvent extends AbstractEvent {

        public static const INVOKE:String = "invoke";

        public function InvokeEvent(_arg1:String, _arg2:Boolean=false, _arg3:Boolean=false, _arg4:AsyncToken=null, _arg5:IMessage=null){
            super(_arg1, _arg2, _arg3, _arg4, _arg5);
        }
        public static function createEvent(_arg1:AsyncToken=null, _arg2:IMessage=null):InvokeEvent{
            return (new InvokeEvent(InvokeEvent.INVOKE, false, false, _arg1, _arg2));
        }

        override public function toString():String{
            return (formatToString("InvokeEvent", "messageId", "type", "bubbles", "cancelable", "eventPhase"));
        }
        override public function clone():Event{
            return (new InvokeEvent(type, bubbles, cancelable, token, message));
        }

    }
}//package mx.rpc.events 
﻿package mx.rpc {
    import flash.events.*;
    import flash.utils.*;

    public class AsyncDispatcher {

        private var _method:Function;
        private var _timer:Timer;
        private var _args:Array;

        public function AsyncDispatcher(_arg1:Function, _arg2:Array, _arg3:Number){
            _method = _arg1;
            _args = _arg2;
            _timer = new Timer(_arg3);
            _timer.addEventListener(TimerEvent.TIMER, timerEventHandler);
            _timer.start();
        }
        private function timerEventHandler(_arg1:TimerEvent):void{
            _timer.stop();
            _timer.removeEventListener(TimerEvent.TIMER, timerEventHandler);
            _method.apply(null, _args);
        }

    }
}//package mx.rpc 
﻿package mx.rpc {

    public interface IResponder {

        function fault(_arg1:Object):void;
        function result(_arg1:Object):void;

    }
}//package mx.rpc 
﻿package mx.rpc {
    import mx.rpc.events.*;
    import mx.resources.*;
    import mx.core.*;

    public class AbstractOperation extends AbstractInvoker {

        mx_internal var _service:AbstractService;
        private var _name:String;
        public var properties:Object;
        public var arguments:Object;
        private var resourceManager:IResourceManager;

        public function AbstractOperation(_arg1:AbstractService=null, _arg2:String=null){
            resourceManager = ResourceManager.getInstance();
            super();
            _service = _arg1;
            _name = _arg2;
            this.arguments = {};
        }
        public function send(... _args):AsyncToken{
            return (null);
        }
        public function get name():String{
            return (_name);
        }
        override mx_internal function dispatchRpcEvent(_arg1:AbstractEvent):void{
            _arg1.callTokenResponders();
            if (!_arg1.isDefaultPrevented()){
                if (hasEventListener(_arg1.type)){
                    dispatchEvent(_arg1);
                } else {
                    if (_service != null){
                        _service.dispatchEvent(_arg1);
                    };
                };
            };
        }
        mx_internal function setService(_arg1:AbstractService):void{
            var _local2:String;
            if (!_service){
                _service = _arg1;
            } else {
                _local2 = resourceManager.getString("rpc", "cannotResetService");
                throw (new Error(_local2));
            };
        }
        public function get service():AbstractService{
            return (_service);
        }
        public function set name(_arg1:String):void{
            var _local2:String;
            if (!_name){
                _name = _arg1;
            } else {
                _local2 = resourceManager.getString("rpc", "cannotResetOperationName");
                throw (new Error(_local2));
            };
        }

    }
}//package mx.rpc 
﻿package mx.rpc.xml {
    import flash.xml.*;
    import mx.utils.*;

    public class SimpleXMLEncoder {

        private static const ARRAY_TYPE:uint = 6;
        private static const DOC_TYPE:uint = 13;
        private static const XML_TYPE:uint = 5;
        private static const HEX_BINARY_TYPE:uint = 18;
        private static const FUNCTION_TYPE:uint = 15;
        private static const OBJECT_TYPE:uint = 2;
        private static const CLASS_INFO_OPTIONS:Object = {
            includeReadOnly:false,
            includeTransient:false
        };
        private static const ANY_TYPE:uint = 8;
        private static const BASE64_BINARY_TYPE:uint = 17;
        private static const BOOLEAN_TYPE:uint = 4;
        private static const ROWSET_TYPE:uint = 11;
        private static const MAP_TYPE:uint = 7;
        private static const SCHEMA_TYPE:uint = 14;
        private static const STRING_TYPE:uint = 1;
        private static const DATE_TYPE:uint = 3;
        private static const NUMBER_TYPE:uint = 0;
        private static const QBEAN_TYPE:uint = 12;
        private static const ELEMENT_TYPE:uint = 16;

        private var myXMLDoc:XMLDocument;

        public function SimpleXMLEncoder(_arg1:XMLDocument){
            this.myXMLDoc = ((_arg1) ? _arg1 : new XMLDocument());
        }
        static function encodeDate(_arg1:Date, _arg2:String):String{
            var _local4:Number;
            var _local3:String = new String();
            if ((((_arg2 == "dateTime")) || ((_arg2 == "date")))){
                _local3 = _local3.concat(_arg1.getUTCFullYear(), "-");
                _local4 = (_arg1.getUTCMonth() + 1);
                if (_local4 < 10){
                    _local3 = _local3.concat("0");
                };
                _local3 = _local3.concat(_local4, "-");
                _local4 = _arg1.getUTCDate();
                if (_local4 < 10){
                    _local3 = _local3.concat("0");
                };
                _local3 = _local3.concat(_local4);
            };
            if (_arg2 == "dateTime"){
                _local3 = _local3.concat("T");
            };
            if ((((_arg2 == "dateTime")) || ((_arg2 == "time")))){
                _local4 = _arg1.getUTCHours();
                if (_local4 < 10){
                    _local3 = _local3.concat("0");
                };
                _local3 = _local3.concat(_local4, ":");
                _local4 = _arg1.getUTCMinutes();
                if (_local4 < 10){
                    _local3 = _local3.concat("0");
                };
                _local3 = _local3.concat(_local4, ":");
                _local4 = _arg1.getUTCSeconds();
                if (_local4 < 10){
                    _local3 = _local3.concat("0");
                };
                _local3 = _local3.concat(_local4, ".");
                _local4 = _arg1.getUTCMilliseconds();
                if (_local4 < 10){
                    _local3 = _local3.concat("00");
                } else {
                    if (_local4 < 100){
                        _local3 = _local3.concat("0");
                    };
                };
                _local3 = _local3.concat(_local4);
            };
            _local3 = _local3.concat("Z");
            return (_local3);
        }

        public function encodeValue(_arg1:Object, _arg2:QName, _arg3:XMLNode):XMLNode{
            var _local4:XMLNode;
            var _local6:Object;
            var _local7:Array;
            var _local8:uint;
            var _local9:uint;
            var _local10:String;
            var _local11:QName;
            var _local12:uint;
            var _local13:QName;
            var _local14:uint;
            var _local15:String;
            var _local16:XMLNode;
            var _local17:String;
            var _local18:String;
            if (_arg1 == null){
                return (null);
            };
            var _local5:uint = getDataTypeFromObject(_arg1);
            if (_local5 == SimpleXMLEncoder.FUNCTION_TYPE){
                return (null);
            };
            if (_local5 == SimpleXMLEncoder.XML_TYPE){
                _local4 = _arg1.cloneNode(true);
                _arg3.appendChild(_local4);
                return (_local4);
            };
            _local4 = myXMLDoc.createElement("foo");
            _local4.nodeName = _arg2.localName;
            _arg3.appendChild(_local4);
            if (_local5 == SimpleXMLEncoder.OBJECT_TYPE){
                _local6 = ObjectUtil.getClassInfo(_arg1, null, CLASS_INFO_OPTIONS);
                _local7 = _local6.properties;
                _local8 = _local7.length;
                _local9 = 0;
                while (_local9 < _local8) {
                    _local10 = _local7[_local9];
                    _local11 = new QName("", _local10);
                    encodeValue(_arg1[_local10], _local11, _local4);
                    _local9++;
                };
            } else {
                if (_local5 == SimpleXMLEncoder.ARRAY_TYPE){
                    _local12 = _arg1.length;
                    _local13 = new QName("", "item");
                    _local14 = 0;
                    while (_local14 < _local12) {
                        encodeValue(_arg1[_local14], _local13, _local4);
                        _local14++;
                    };
                } else {
                    if (_local5 == SimpleXMLEncoder.DATE_TYPE){
                        _local15 = encodeDate((_arg1 as Date), "dateTime");
                    } else {
                        if (_local5 == SimpleXMLEncoder.NUMBER_TYPE){
                            if (_arg1 == Number.POSITIVE_INFINITY){
                                _local15 = "INF";
                            } else {
                                if (_arg1 == Number.NEGATIVE_INFINITY){
                                    _local15 = "-INF";
                                } else {
                                    _local17 = _arg1.toString();
                                    _local18 = _local17.substr(0, 2);
                                    if ((((_local18 == "0X")) || ((_local18 == "0x")))){
                                        _local15 = parseInt(_local17).toString();
                                    } else {
                                        _local15 = _local17;
                                    };
                                };
                            };
                        } else {
                            _local15 = _arg1.toString();
                        };
                    };
                    _local16 = myXMLDoc.createTextNode(_local15);
                    _local4.appendChild(_local16);
                };
            };
            return (_local4);
        }
        private function getDataTypeFromObject(_arg1:Object):uint{
            if ((_arg1 is Number)){
                return (SimpleXMLEncoder.NUMBER_TYPE);
            };
            if ((_arg1 is Boolean)){
                return (SimpleXMLEncoder.BOOLEAN_TYPE);
            };
            if ((_arg1 is String)){
                return (SimpleXMLEncoder.STRING_TYPE);
            };
            if ((_arg1 is XMLDocument)){
                return (SimpleXMLEncoder.XML_TYPE);
            };
            if ((_arg1 is Date)){
                return (SimpleXMLEncoder.DATE_TYPE);
            };
            if ((_arg1 is Array)){
                return (SimpleXMLEncoder.ARRAY_TYPE);
            };
            if ((_arg1 is Function)){
                return (SimpleXMLEncoder.FUNCTION_TYPE);
            };
            if ((_arg1 is Object)){
                return (SimpleXMLEncoder.OBJECT_TYPE);
            };
            return (SimpleXMLEncoder.STRING_TYPE);
        }

    }
}//package mx.rpc.xml 
﻿package mx.rpc.xml {
    import mx.rpc.xml.*;

    dynamic class ComplexString {

        public var value:String;

        public function ComplexString(_arg1:String){
            value = _arg1;
        }
        public function valueOf():Object{
            return (SimpleXMLDecoder.simpleType(value));
        }
        public function toString():String{
            return (value);
        }

    }
}//package mx.rpc.xml 
﻿package mx.rpc.xml {
    import mx.collections.*;
    import flash.xml.*;
    import mx.utils.*;

    public class SimpleXMLDecoder {

        private var makeObjectsBindable:Boolean;

        public function SimpleXMLDecoder(_arg1:Boolean=false){
            this.makeObjectsBindable = _arg1;
        }
        public static function getLocalName(_arg1:XMLNode):String{
            var _local2:String = _arg1.nodeName;
            var _local3:int = _local2.indexOf(":");
            if (_local3 != -1){
                _local2 = _local2.substring((_local3 + 1));
            };
            return (_local2);
        }
        public static function simpleType(_arg1:Object):Object{
            var _local3:String;
            var _local4:String;
            var _local2:Object = _arg1;
            if (_arg1 != null){
                if ((((_arg1 is String)) && ((String(_arg1) == "")))){
                    _local2 = _arg1.toString();
                } else {
                    if (((((((isNaN(Number(_arg1))) || ((_arg1.charAt(0) == "0")))) || ((((_arg1.charAt(0) == "-")) && ((_arg1.charAt(1) == "0")))))) || ((_arg1.charAt((_arg1.length - 1)) == "E")))){
                        _local3 = _arg1.toString();
                        _local4 = _local3.toLowerCase();
                        if (_local4 == "true"){
                            _local2 = true;
                        } else {
                            if (_local4 == "false"){
                                _local2 = false;
                            } else {
                                _local2 = _local3;
                            };
                        };
                    } else {
                        _local2 = Number(_arg1);
                    };
                };
            };
            return (_local2);
        }

        public function decodeXML(_arg1:XMLNode):Object{
            var _local2:Object;
            var _local6:String;
            var _local7:uint;
            var _local8:XMLNode;
            var _local9:String;
            var _local10:Object;
            var _local11:Object;
            var _local3:Boolean;
            if (_arg1 == null){
                return (null);
            };
            var _local4:Array = _arg1.childNodes;
            if ((((_local4.length == 1)) && ((_local4[0].nodeType == XMLNodeType.TEXT_NODE)))){
                _local3 = true;
                _local2 = SimpleXMLDecoder.simpleType(_local4[0].nodeValue);
            } else {
                if (_local4.length > 0){
                    _local2 = {};
                    if (makeObjectsBindable){
                        _local2 = new ObjectProxy(_local2);
                    };
                    _local7 = 0;
                    while (_local7 < _local4.length) {
                        _local8 = _local4[_local7];
                        if (_local8.nodeType != XMLNodeType.ELEMENT_NODE){
                        } else {
                            _local9 = getLocalName(_local8);
                            _local10 = decodeXML(_local8);
                            _local11 = _local2[_local9];
                            if (_local11 != null){
                                if ((_local11 is Array)){
                                    _local11.push(_local10);
                                } else {
                                    if ((_local11 is ArrayCollection)){
                                        _local11.source.push(_local10);
                                    } else {
                                        _local11 = [_local11];
                                        _local11.push(_local10);
                                        if (makeObjectsBindable){
                                            _local11 = new ArrayCollection((_local11 as Array));
                                        };
                                        _local2[_local9] = _local11;
                                    };
                                };
                            } else {
                                _local2[_local9] = _local10;
                            };
                        };
                        _local7++;
                    };
                };
            };
            var _local5:Object = _arg1.attributes;
            for (_local6 in _local5) {
                if ((((_local6 == "xmlns")) || (!((_local6.indexOf("xmlns:") == -1))))){
                } else {
                    if (_local2 == null){
                        _local2 = {};
                        if (makeObjectsBindable){
                            _local2 = new ObjectProxy(_local2);
                        };
                    };
                    if (((_local3) && (!((_local2 is ComplexString))))){
                        _local2 = new ComplexString(_local2.toString());
                        _local3 = false;
                    };
                    _local2[_local6] = SimpleXMLDecoder.simpleType(_local5[_local6]);
                };
            };
            return (_local2);
        }

    }
}//package mx.rpc.xml 
﻿package mx.rpc {
    import flash.events.*;
    import flash.utils.*;
    import mx.rpc.events.*;
    import mx.messaging.*;
    import mx.resources.*;
    import mx.core.*;

    public dynamic class AbstractService extends Proxy implements IEventDispatcher {

        mx_internal var _operations:Object;
        private var _initialized:Boolean = false;
        mx_internal var _availableChannelIds:Array;
        private var resourceManager:IResourceManager;
        private var _managers:Array;
        private var nextNameArray:Array;
        private var eventDispatcher:EventDispatcher;
        mx_internal var asyncRequest:AsyncRequest;

        public function AbstractService(_arg1:String=null){
            resourceManager = ResourceManager.getInstance();
            super();
            eventDispatcher = new EventDispatcher(this);
            asyncRequest = new AsyncRequest();
            if (_arg1){
                this.destination = _arg1;
                asyncRequest.destination = _arg1;
            };
            _operations = {};
        }
        public function willTrigger(_arg1:String):Boolean{
            return (eventDispatcher.willTrigger(_arg1));
        }
        public function get destination():String{
            return (asyncRequest.destination);
        }
        public function initialize():void{
            var _local1:int;
            var _local2:Object;
            if (((!(_initialized)) && (!((_managers == null))))){
                _local1 = 0;
                while (_local1 < _managers.length) {
                    _local2 = _managers[_local1];
                    if (_local2.hasOwnProperty("initialize")){
                        _local2.initialize();
                    };
                    _local1++;
                };
                _initialized = true;
            };
        }
        public function logout():void{
            asyncRequest.logout();
        }
        public function setRemoteCredentials(_arg1:String, _arg2:String, _arg3:String=null):void{
            asyncRequest.setRemoteCredentials(_arg1, _arg2, _arg3);
        }
        mx_internal function hasTokenResponders(_arg1:Event):Boolean{
            var _local2:AbstractEvent;
            if ((_arg1 is AbstractEvent)){
                _local2 = (_arg1 as AbstractEvent);
                if (((!((_local2.token == null))) && (_local2.token.hasResponder()))){
                    return (true);
                };
            };
            return (false);
        }
        public function disconnect():void{
            asyncRequest.disconnect();
        }
        override "http://www.adobe.com/2006/actionscript/flash/proxy"?? function nextName(_arg1:int):String{
            return (nextNameArray[(_arg1 - 1)]);
        }
        public function set destination(_arg1:String):void{
            asyncRequest.destination = _arg1;
        }
        public function set requestTimeout(_arg1:int):void{
            if (requestTimeout != _arg1){
                asyncRequest.requestTimeout = _arg1;
            };
        }
        public function valueOf():Object{
            return (this);
        }
        public function getOperation(_arg1:String):AbstractOperation{
            var _local2:Object = _operations[_arg1];
            var _local3:AbstractOperation = (((_local2 is AbstractOperation)) ? AbstractOperation(_local2) : null);
            return (_local3);
        }
        public function setCredentials(_arg1:String, _arg2:String, _arg3:String=null):void{
            asyncRequest.setCredentials(_arg1, _arg2, _arg3);
        }
        public function set channelSet(_arg1:ChannelSet):void{
            if (channelSet != _arg1){
                asyncRequest.channelSet = _arg1;
            };
        }
        public function dispatchEvent(_arg1:Event):Boolean{
            return (eventDispatcher.dispatchEvent(_arg1));
        }
        public function removeEventListener(_arg1:String, _arg2:Function, _arg3:Boolean=false):void{
            eventDispatcher.removeEventListener(_arg1, _arg2, _arg3);
        }
        override "http://www.adobe.com/2006/actionscript/flash/proxy"?? function getProperty(_arg1){
            return (getOperation(getLocalName(_arg1)));
        }
        public function set managers(_arg1:Array):void{
            var _local2:int;
            var _local3:Object;
            if (_managers != null){
                _local2 = 0;
                while (_local2 < _managers.length) {
                    _local3 = _managers[_local2];
                    if (_local3.hasOwnProperty("service")){
                        _local3.service = null;
                    };
                    _local2++;
                };
            };
            _managers = _arg1;
            _local2 = 0;
            while (_local2 < _arg1.length) {
                _local3 = _managers[_local2];
                if (_local3.hasOwnProperty("service")){
                    _local3.service = this;
                };
                if (((_initialized) && (_local3.hasOwnProperty("initialize")))){
                    _local3.initialize();
                };
                _local2++;
            };
        }
        public function get requestTimeout():int{
            return (asyncRequest.requestTimeout);
        }
        override "http://www.adobe.com/2006/actionscript/flash/proxy"?? function callProperty(_arg1, ... _args){
            return (getOperation(getLocalName(_arg1)).send.apply(null, _args));
        }
        public function addEventListener(_arg1:String, _arg2:Function, _arg3:Boolean=false, _arg4:int=0, _arg5:Boolean=false):void{
            eventDispatcher.addEventListener(_arg1, _arg2, _arg3, _arg4, _arg5);
        }
        override "http://www.adobe.com/2006/actionscript/flash/proxy"?? function nextValue(_arg1:int){
            return (_operations[nextNameArray[(_arg1 - 1)]]);
        }
        override "http://www.adobe.com/2006/actionscript/flash/proxy"?? function setProperty(_arg1, _arg2):void{
            var _local3:String = resourceManager.getString("rpc", "operationsNotAllowedInService", [getLocalName(_arg1)]);
            throw (new Error(_local3));
        }
        public function set operations(_arg1:Object):void{
            var _local2:AbstractOperation;
            var _local3:String;
            for (_local3 in _arg1) {
                _local2 = AbstractOperation(_arg1[_local3]);
                _local2.setService(this);
                if (!_local2.name){
                    _local2.name = _local3;
                };
                _local2.asyncRequest = asyncRequest;
            };
            _operations = _arg1;
            dispatchEvent(new Event("operationsChange"));
        }
        public function get channelSet():ChannelSet{
            return (asyncRequest.channelSet);
        }
        mx_internal function getLocalName(_arg1:Object):String{
            if ((_arg1 is QName)){
                return (QName(_arg1).localName);
            };
            return (String(_arg1));
        }
        override "http://www.adobe.com/2006/actionscript/flash/proxy"?? function nextNameIndex(_arg1:int):int{
            var _local2:String;
            if (_arg1 == 0){
                nextNameArray = [];
                for (_local2 in _operations) {
                    nextNameArray.push(_local2);
                };
            };
            return ((((_arg1 < nextNameArray.length)) ? (_arg1 + 1) : 0));
        }
        public function get managers():Array{
            return (_managers);
        }
        public function get operations():Object{
            return (_operations);
        }
        public function hasEventListener(_arg1:String):Boolean{
            return (eventDispatcher.hasEventListener(_arg1));
        }

    }
}//package mx.rpc 
﻿package mx.rpc {
    import flash.events.*;
    import flash.utils.*;
    import mx.messaging.messages.*;
    import mx.rpc.events.*;
    import mx.messaging.events.*;
    import mx.resources.*;
    import mx.logging.*;
    import mx.utils.*;
    import mx.core.*;
    import mx.messaging.errors.*;
    import mx.netmon.*;

    public class AbstractInvoker extends EventDispatcher {

        mx_internal static const BINDING_RESULT:String = "resultForBinding";

        mx_internal var _makeObjectsBindable:Boolean;
        public var operationManager:Function;
        mx_internal var _responseHeaders:Array;
        private var _asyncRequest:AsyncRequest;
        private var _log:ILogger;
        mx_internal var activeCalls:ActiveCalls;
        public var resultType:Class;
        public var resultElementType:Class;
        mx_internal var _result:Object;
        private var resourceManager:IResourceManager;

        public function AbstractInvoker(){
            resourceManager = ResourceManager.getInstance();
            super();
            _log = Log.getLogger("mx.rpc.AbstractInvoker");
            activeCalls = new ActiveCalls();
        }
        mx_internal function getNetmonId():String{
            return (null);
        }
        public function cancel(_arg1:String=null):AsyncToken{
            if (_arg1 != null){
                return (activeCalls.removeCall(_arg1));
            };
            return (activeCalls.cancelLast());
        }
        mx_internal function faultHandler(_arg1:MessageFaultEvent):void{
            var _local4:Fault;
            var _local5:FaultEvent;
            var _local2:MessageEvent = MessageEvent.createEvent(MessageEvent.MESSAGE, _arg1.message);
            var _local3:AsyncToken = preHandle(_local2);
            if ((((((((_local3 == null)) && (!((AsyncMessage(_arg1.message).correlationId == null))))) && (!((AsyncMessage(_arg1.message).correlationId == ""))))) && (!((_arg1.faultCode == "Client.Authentication"))))){
                return;
            };
            if (processFault(_arg1.message, _local3)){
                _local4 = new Fault(_arg1.faultCode, _arg1.faultString, _arg1.faultDetail);
                _local4.content = _arg1.message.body;
                _local4.rootCause = _arg1.rootCause;
                _local5 = FaultEvent.createEvent(_local4, _local3, _arg1.message);
                _local5.headers = _responseHeaders;
                dispatchRpcEvent(_local5);
            };
        }
        public function clearResult(_arg1:Boolean=true):void{
            if (_arg1){
                setResult(null);
            } else {
                _result = null;
            };
        }
        mx_internal function get asyncRequest():AsyncRequest{
            if (_asyncRequest == null){
                _asyncRequest = new AsyncRequest();
            };
            return (_asyncRequest);
        }
        mx_internal function dispatchRpcEvent(_arg1:AbstractEvent):void{
            _arg1.callTokenResponders();
            if (!_arg1.isDefaultPrevented()){
                dispatchEvent(_arg1);
            };
        }
        public function get lastResult():Object{
            return (_result);
        }
        public function setResult(_arg1:Object):void{
            _result = _arg1;
            dispatchEvent(new Event(BINDING_RESULT));
        }
        mx_internal function set asyncRequest(_arg1:AsyncRequest):void{
            _asyncRequest = _arg1;
        }
        mx_internal function preHandle(_arg1:MessageEvent):AsyncToken{
            return (activeCalls.removeCall(AsyncMessage(_arg1.message).correlationId));
        }
        mx_internal function processResult(_arg1:IMessage, _arg2:AsyncToken):Boolean{
            var _local3:Object = _arg1.body;
            if (((((makeObjectsBindable) && (!((_local3 == null))))) && ((getQualifiedClassName(_local3) == "Object")))){
                _result = new ObjectProxy(_local3);
            } else {
                _result = _local3;
            };
            return (true);
        }
        mx_internal function resultHandler(_arg1:MessageEvent):void{
            var _local3:ResultEvent;
            var _local2:AsyncToken = preHandle(_arg1);
            if (_local2 == null){
                return;
            };
            if (processResult(_arg1.message, _local2)){
                dispatchEvent(new Event(BINDING_RESULT));
                _local3 = ResultEvent.createEvent(_result, _local2, _arg1.message);
                _local3.headers = _responseHeaders;
                dispatchRpcEvent(_local3);
            };
        }
        mx_internal function monitorRpcEvent(_arg1:AbstractEvent):void{
            if (NetworkMonitor.isMonitoring()){
                if ((_arg1 is ResultEvent)){
                    NetworkMonitor.monitorResult(_arg1.message, ResultEvent(_arg1).result);
                } else {
                    if ((_arg1 is FaultEvent)){
                        NetworkMonitor.monitorFault(_arg1.message, FaultEvent(_arg1).fault);
                    };
                };
            };
        }
        mx_internal function processFault(_arg1:IMessage, _arg2:AsyncToken):Boolean{
            return (true);
        }
        mx_internal function invoke(_arg1:IMessage, _arg2:AsyncToken=null):AsyncToken{
            var fault:* = null;
            var errorText:* = null;
            var message:* = _arg1;
            var token = _arg2;
            if (token == null){
                token = new AsyncToken(message);
            } else {
                token.setMessage(message);
            };
            activeCalls.addCall(message.messageId, token);
            try {
                asyncRequest.invoke(message, new Responder(resultHandler, faultHandler));
                dispatchRpcEvent(InvokeEvent.createEvent(token, message));
            } catch(e:MessagingError) {
                _log.warn(e.toString());
                errorText = resourceManager.getString("rpc", "cannotConnectToDestination", [asyncRequest.destination]);
                fault = new Fault("InvokeFailed", e.toString(), errorText);
                new AsyncDispatcher(dispatchRpcEvent, [FaultEvent.createEvent(fault, token, message)], 10);
            } catch(e2:Error) {
                _log.warn(e2.toString());
                fault = new Fault("InvokeFailed", e2.message);
                new AsyncDispatcher(dispatchRpcEvent, [FaultEvent.createEvent(fault, token, message)], 10);
            };
            return (token);
        }
        public function set makeObjectsBindable(_arg1:Boolean):void{
            _makeObjectsBindable = _arg1;
        }
        public function get makeObjectsBindable():Boolean{
            return (_makeObjectsBindable);
        }

    }
}//package mx.rpc 
﻿package mx.logging {
    import flash.events.*;
    import mx.core.*;

    public class LogEvent extends Event {

        mx_internal static const VERSION:String = "3.5.0.12683";
        public static const LOG:String = "log";

        public var level:int;
        public var message:String;

        public function LogEvent(_arg1:String="", _arg2:int=0){
            super(LogEvent.LOG, false, false);
            this.message = _arg1;
            this.level = _arg2;
        }
        public static function getLevelString(_arg1:uint):String{
            switch (_arg1){
                case LogEventLevel.INFO:
                    return ("INFO");
                case LogEventLevel.DEBUG:
                    return ("DEBUG");
                case LogEventLevel.ERROR:
                    return ("ERROR");
                case LogEventLevel.WARN:
                    return ("WARN");
                case LogEventLevel.FATAL:
                    return ("FATAL");
                case LogEventLevel.ALL:
                    return ("ALL");
            };
            return ("UNKNOWN");
        }

        override public function clone():Event{
            return (new LogEvent(message, level));
        }

    }
}//package mx.logging 
﻿package mx.logging {

    public interface ILoggingTarget {

        function addLogger(_arg1:ILogger):void;
        function removeLogger(_arg1:ILogger):void;
        function get level():int;
        function set filters(_arg1:Array):void;
        function set level(_arg1:int):void;
        function get filters():Array;

    }
}//package mx.logging 
﻿package mx.logging {
    import mx.core.*;

    public final class LogEventLevel {

        public static const ALL:int = 0;
        public static const FATAL:int = 1000;
        public static const WARN:int = 6;
        public static const INFO:int = 4;
        public static const ERROR:int = 8;
        public static const DEBUG:int = 2;
        mx_internal static const VERSION:String = "3.5.0.12683";

    }
}//package mx.logging 
﻿package mx.logging.errors {
    import mx.core.*;

    public class InvalidCategoryError extends Error {

        mx_internal static const VERSION:String = "3.5.0.12683";

        public function InvalidCategoryError(_arg1:String){
            super(_arg1);
        }
        public function toString():String{
            return (String(message));
        }

    }
}//package mx.logging.errors 
﻿package mx.logging {
    import flash.events.*;
    import mx.resources.*;

    public class LogLogger extends EventDispatcher implements ILogger {

        private var _category:String;
        private var resourceManager:IResourceManager;

        public function LogLogger(_arg1:String){
            resourceManager = ResourceManager.getInstance();
            super();
            _category = _arg1;
        }
        public function log(_arg1:int, _arg2:String, ... _args):void{
            var _local4:String;
            var _local5:int;
            if (_arg1 < LogEventLevel.DEBUG){
                _local4 = resourceManager.getString("logging", "levelLimit");
                throw (new ArgumentError(_local4));
            };
            if (hasEventListener(LogEvent.LOG)){
                _local5 = 0;
                while (_local5 < _args.length) {
                    _arg2 = _arg2.replace(new RegExp((("\\{" + _local5) + "\\}"), "g"), _args[_local5]);
                    _local5++;
                };
                dispatchEvent(new LogEvent(_arg2, _arg1));
            };
        }
        public function error(_arg1:String, ... _args):void{
            var _local3:int;
            if (hasEventListener(LogEvent.LOG)){
                _local3 = 0;
                while (_local3 < _args.length) {
                    _arg1 = _arg1.replace(new RegExp((("\\{" + _local3) + "\\}"), "g"), _args[_local3]);
                    _local3++;
                };
                dispatchEvent(new LogEvent(_arg1, LogEventLevel.ERROR));
            };
        }
        public function warn(_arg1:String, ... _args):void{
            var _local3:int;
            if (hasEventListener(LogEvent.LOG)){
                _local3 = 0;
                while (_local3 < _args.length) {
                    _arg1 = _arg1.replace(new RegExp((("\\{" + _local3) + "\\}"), "g"), _args[_local3]);
                    _local3++;
                };
                dispatchEvent(new LogEvent(_arg1, LogEventLevel.WARN));
            };
        }
        public function get category():String{
            return (_category);
        }
        public function info(_arg1:String, ... _args):void{
            var _local3:int;
            if (hasEventListener(LogEvent.LOG)){
                _local3 = 0;
                while (_local3 < _args.length) {
                    _arg1 = _arg1.replace(new RegExp((("\\{" + _local3) + "\\}"), "g"), _args[_local3]);
                    _local3++;
                };
                dispatchEvent(new LogEvent(_arg1, LogEventLevel.INFO));
            };
        }
        public function debug(_arg1:String, ... _args):void{
            var _local3:int;
            if (hasEventListener(LogEvent.LOG)){
                _local3 = 0;
                while (_local3 < _args.length) {
                    _arg1 = _arg1.replace(new RegExp((("\\{" + _local3) + "\\}"), "g"), _args[_local3]);
                    _local3++;
                };
                dispatchEvent(new LogEvent(_arg1, LogEventLevel.DEBUG));
            };
        }
        public function fatal(_arg1:String, ... _args):void{
            var _local3:int;
            if (hasEventListener(LogEvent.LOG)){
                _local3 = 0;
                while (_local3 < _args.length) {
                    _arg1 = _arg1.replace(new RegExp((("\\{" + _local3) + "\\}"), "g"), _args[_local3]);
                    _local3++;
                };
                dispatchEvent(new LogEvent(_arg1, LogEventLevel.FATAL));
            };
        }

    }
}//package mx.logging 
﻿package mx.logging {
    import mx.resources.*;
    import mx.logging.errors.*;

    public class Log {

        private static var _targets:Array = [];
        private static var _loggers:Array;
        private static var _resourceManager:IResourceManager;
        private static var _targetLevel:int = NONE;
        private static var NONE:int = 2147483647;

        public static function isInfo():Boolean{
            return (((_targetLevel)<=LogEventLevel.INFO) ? true : false);
        }
        public static function isDebug():Boolean{
            return (((_targetLevel)<=LogEventLevel.DEBUG) ? true : false);
        }
        public static function flush():void{
            _loggers = [];
            _targets = [];
            _targetLevel = NONE;
        }
        private static function checkCategory(_arg1:String):void{
            var _local2:String;
            if ((((_arg1 == null)) || ((_arg1.length == 0)))){
                _local2 = resourceManager.getString("logging", "invalidLen");
                throw (new InvalidCategoryError(_local2));
            };
            if (((hasIllegalCharacters(_arg1)) || (!((_arg1.indexOf("*") == -1))))){
                _local2 = resourceManager.getString("logging", "invalidChars");
                throw (new InvalidCategoryError(_local2));
            };
        }
        public static function getLogger(_arg1:String):ILogger{
            var _local3:ILoggingTarget;
            checkCategory(_arg1);
            if (!_loggers){
                _loggers = [];
            };
            var _local2:ILogger = _loggers[_arg1];
            if (_local2 == null){
                _local2 = new LogLogger(_arg1);
                _loggers[_arg1] = _local2;
            };
            var _local4:int;
            while (_local4 < _targets.length) {
                _local3 = ILoggingTarget(_targets[_local4]);
                if (categoryMatchInFilterList(_arg1, _local3.filters)){
                    _local3.addLogger(_local2);
                };
                _local4++;
            };
            return (_local2);
        }
        private static function categoryMatchInFilterList(_arg1:String, _arg2:Array):Boolean{
            var _local4:String;
            var _local3:Boolean;
            var _local5 = -1;
            var _local6:uint;
            while (_local6 < _arg2.length) {
                _local4 = _arg2[_local6];
                _local5 = _local4.indexOf("*");
                if (_local5 == 0){
                    return (true);
                };
                _local5 = (((_local5 < 0)) ? _local5 = _arg1.length;
_local5 : (_local5 - 1));
                if (_arg1.substring(0, _local5) == _local4.substring(0, _local5)){
                    return (true);
                };
                _local6++;
            };
            return (false);
        }
        public static function addTarget(_arg1:ILoggingTarget):void{
            var _local2:Array;
            var _local3:ILogger;
            var _local4:String;
            var _local5:String;
            if (_arg1){
                _local2 = _arg1.filters;
                for (_local4 in _loggers) {
                    if (categoryMatchInFilterList(_local4, _local2)){
                        _arg1.addLogger(ILogger(_loggers[_local4]));
                    };
                };
                _targets.push(_arg1);
                if (_targetLevel == NONE){
                    _targetLevel = _arg1.level;
                } else {
                    if (_arg1.level < _targetLevel){
                        _targetLevel = _arg1.level;
                    };
                };
            } else {
                _local5 = resourceManager.getString("logging", "invalidTarget");
                throw (new ArgumentError(_local5));
            };
        }
        public static function hasIllegalCharacters(_arg1:String):Boolean{
            return (!((_arg1.search(/[\[\]\~\$\^\&\\(\)\{\}\+\?\/=`!@#%,:;'"<>\s]/) == -1)));
        }
        public static function removeTarget(_arg1:ILoggingTarget):void{
            var _local2:Array;
            var _local3:ILogger;
            var _local4:String;
            var _local5:int;
            var _local6:String;
            if (_arg1){
                _local2 = _arg1.filters;
                for (_local4 in _loggers) {
                    if (categoryMatchInFilterList(_local4, _local2)){
                        _arg1.removeLogger(ILogger(_loggers[_local4]));
                    };
                };
                _local5 = 0;
                while (_local5 < _targets.length) {
                    if (_arg1 == _targets[_local5]){
                        _targets.splice(_local5, 1);
                        _local5--;
                    };
                    _local5++;
                };
                resetTargetLevel();
            } else {
                _local6 = resourceManager.getString("logging", "invalidTarget");
                throw (new ArgumentError(_local6));
            };
        }
        public static function isWarn():Boolean{
            return (((_targetLevel)<=LogEventLevel.WARN) ? true : false);
        }
        public static function isFatal():Boolean{
            return (((_targetLevel)<=LogEventLevel.FATAL) ? true : false);
        }
        private static function resetTargetLevel():void{
            var _local1:int = NONE;
            var _local2:int;
            while (_local2 < _targets.length) {
                if ((((_local1 == NONE)) || ((_targets[_local2].level < _local1)))){
                    _local1 = _targets[_local2].level;
                };
                _local2++;
            };
            _targetLevel = _local1;
        }
        public static function isError():Boolean{
            return (((_targetLevel)<=LogEventLevel.ERROR) ? true : false);
        }
        private static function get resourceManager():IResourceManager{
            if (!_resourceManager){
                _resourceManager = ResourceManager.getInstance();
            };
            return (_resourceManager);
        }

    }
}//package mx.logging 
﻿package mx.logging {
    import flash.events.*;

    public interface ILogger extends IEventDispatcher {

        function debug(_arg1:String, ... _args):void;
        function fatal(_arg1:String, ... _args):void;
        function get category():String;
        function warn(_arg1:String, ... _args):void;
        function error(_arg1:String, ... _args):void;
        function log(_arg1:int, _arg2:String, ... _args):void;
        function info(_arg1:String, ... _args):void;

    }
}//package mx.logging 
﻿package mx.binding {
    import mx.events.*;
    import mx.core.*;

    public class BindabilityInfo {

        public static const METHOD:String = "method";
        public static const ACCESSOR:String = "accessor";
        public static const CHANGE_EVENT:String = "ChangeEvent";
        public static const NON_COMMITTING_CHANGE_EVENT:String = "NonCommittingChangeEvent";
        public static const BINDABLE:String = "Bindable";
        mx_internal static const VERSION:String = "3.5.0.12683";
        public static const MANAGED:String = "Managed";

        private var classChangeEvents:Object;
        private var typeDescription:XML;
        private var childChangeEvents:Object;

        public function BindabilityInfo(_arg1:XML){
            childChangeEvents = {};
            super();
            this.typeDescription = _arg1;
        }
        private function addChangeEvents(_arg1:XMLList, _arg2:Object, _arg3:Boolean):void{
            var _local4:XML;
            var _local5:XMLList;
            var _local6:String;
            for each (_local4 in _arg1) {
                _local5 = _local4.arg;
                if (_local5.length() > 0){
                    _local6 = _local5[0].@value;
                    _arg2[_local6] = _arg3;
                } else {
                    trace((("warning: unconverted Bindable metadata in class '" + typeDescription.@name) + "'"));
                };
            };
        }
        private function getClassChangeEvents():Object{
            if (!classChangeEvents){
                classChangeEvents = {};
                addBindabilityEvents(typeDescription.metadata, classChangeEvents);
                if (typeDescription.metadata.(@name == MANAGED).length() > 0){
                    classChangeEvents[PropertyChangeEvent.PROPERTY_CHANGE] = true;
                };
            };
            return (classChangeEvents);
        }
        private function addBindabilityEvents(_arg1:XMLList, _arg2:Object):void{
            var metadata:* = _arg1;
            var eventListObj:* = _arg2;
            addChangeEvents(metadata.(@name == BINDABLE), eventListObj, true);
            addChangeEvents(metadata.(@name == CHANGE_EVENT), eventListObj, true);
            addChangeEvents(metadata.(@name == NON_COMMITTING_CHANGE_EVENT), eventListObj, false);
        }
        private function copyProps(_arg1:Object, _arg2:Object):Object{
            var _local3:String;
            for (_local3 in _arg1) {
                _arg2[_local3] = _arg1[_local3];
            };
            return (_arg2);
        }
        public function getChangeEvents(_arg1:String):Object{
            var childDesc:* = null;
            var numChildren:* = 0;
            var childName:* = _arg1;
            var changeEvents:* = childChangeEvents[childName];
            if (!changeEvents){
                changeEvents = copyProps(getClassChangeEvents(), {});
                childDesc = (typeDescription.accessor.(@name == childName) + typeDescription.method.(@name == childName));
                numChildren = childDesc.length();
                if (numChildren == 0){
                    if (!typeDescription.@dynamic){
                        trace((((("warning: no describeType entry for '" + childName) + "' on non-dynamic type '") + typeDescription.@name) + "'"));
                    };
                } else {
                    if (numChildren > 1){
                        trace(((((("warning: multiple describeType entries for '" + childName) + "' on type '") + typeDescription.@name) + "':\n") + childDesc));
                    };
                    addBindabilityEvents(childDesc.metadata, changeEvents);
                };
                childChangeEvents[childName] = changeEvents;
            };
            return (changeEvents);
        }

    }
}//package mx.binding 
﻿package mx.validators {
    import mx.core.*;

    public class ValidationResult {

        mx_internal static const VERSION:String = "3.5.0.12683";

        public var subField:String;
        public var errorCode:String;
        public var isError:Boolean;
        public var errorMessage:String;

        public function ValidationResult(_arg1:Boolean, _arg2:String="", _arg3:String="", _arg4:String=""){
            this.isError = _arg1;
            this.subField = _arg2;
            this.errorMessage = _arg4;
            this.errorCode = _arg3;
        }
    }
}//package mx.validators 
﻿package mx.validators {
    import mx.events.*;

    public interface IValidatorListener {

        function set errorString(_arg1:String):void;
        function get validationSubField():String;
        function validationResultHandler(_arg1:ValidationResultEvent):void;
        function set validationSubField(_arg1:String):void;
        function get errorString():String;

    }
}//package mx.validators 
﻿package mx.validators {
    import flash.events.*;
    import mx.events.*;
    import mx.resources.*;
    import mx.core.*;

    public class Validator extends EventDispatcher implements IMXMLObject {

        protected static const DECIMAL_DIGITS:String = "0123456789";
        protected static const ROMAN_LETTERS:String = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

        private var _resourceManager:IResourceManager;
        private var _enabled:Boolean = true;
        private var _listener:Object;
        protected var subFields:Array;
        private var document:Object;
        public var required:Boolean = true;
        private var requiredFieldErrorOverride:String;
        private var _triggerEvent:String = "valueCommit";
        private var _source:Object;
        private var _property:String;
        private var _requiredFieldError:String;
        private var _trigger:IEventDispatcher;

        public function Validator(){
            _resourceManager = ResourceManager.getInstance();
            subFields = [];
            super();
            resourceManager.addEventListener(Event.CHANGE, resourceManager_changeHandler, false, 0, true);
            resourcesChanged();
        }
        private static function findObjectFromString(_arg1:Object, _arg2:String):Object{
            var resourceManager:* = null;
            var message:* = null;
            var doc:* = _arg1;
            var value:* = _arg2;
            var obj:* = doc;
            var parts:* = value.split(".");
            var n:* = parts.length;
            var i:* = 0;
            while (i < n) {
                try {
                    obj = obj[parts[i]];
                    if (obj == null){
                    };
                } catch(error:Error) {
                    if ((((error is TypeError)) && (!((error.message.indexOf("null has no properties") == -1))))){
                        resourceManager = ResourceManager.getInstance();
                        message = resourceManager.getString("validators", "fieldNotFound", [value]);
                        throw (new Error(message));
                    };
                    throw (error);
                };
                i = (i + 1);
            };
            return (obj);
        }
        private static function trimString(_arg1:String):String{
            var _local2:int;
            while (_arg1.indexOf(" ", _local2) == _local2) {
                _local2++;
            };
            var _local3:int = (_arg1.length - 1);
            while (_arg1.lastIndexOf(" ", _local3) == _local3) {
                _local3--;
            };
            return ((((_local3 >= _local2)) ? _arg1.slice(_local2, (_local3 + 1)) : ""));
        }
        public static function validateAll(_arg1:Array):Array{
            var _local5:Validator;
            var _local6:ValidationResultEvent;
            var _local2:Array = [];
            var _local3:int = _arg1.length;
            var _local4:int;
            while (_local4 < _local3) {
                _local5 = Validator(_arg1[_local4]);
                if (_local5.enabled){
                    _local6 = _local5.validate();
                    if (_local6.type != ValidationResultEvent.VALID){
                        _local2.push(_local6);
                    };
                };
                _local4++;
            };
            return (_local2);
        }

        private function triggerHandler(_arg1:Event):void{
            validate();
        }
        public function set enabled(_arg1:Boolean):void{
            _enabled = _arg1;
        }
        public function set triggerEvent(_arg1:String):void{
            if (_triggerEvent == _arg1){
                return;
            };
            removeTriggerHandler();
            _triggerEvent = _arg1;
            addTriggerHandler();
        }
        protected function getValueFromSource():Object{
            var _local1:String;
            if (((_source) && (_property))){
                return (_source[_property]);
            };
            if (((!(_source)) && (_property))){
                _local1 = resourceManager.getString("validators", "SAttributeMissing");
                throw (new Error(_local1));
            };
            if (((_source) && (!(_property)))){
                _local1 = resourceManager.getString("validators", "PAttributeMissing");
                throw (new Error(_local1));
            };
            return (null);
        }
        protected function addListenerHandler():void{
            var _local1:Object;
            var _local2:Array = actualListeners;
            var _local3:int = _local2.length;
            var _local4:int;
            while (_local4 < _local3) {
                _local1 = _local2[_local4];
                if ((_local1 is IValidatorListener)){
                    addEventListener(ValidationResultEvent.VALID, IValidatorListener(_local1).validationResultHandler);
                    addEventListener(ValidationResultEvent.INVALID, IValidatorListener(_local1).validationResultHandler);
                };
                _local4++;
            };
        }
        private function removeTriggerHandler():void{
            if (actualTrigger){
                actualTrigger.removeEventListener(_triggerEvent, triggerHandler);
            };
        }
        public function validate(_arg1:Object=null, _arg2:Boolean=false):ValidationResultEvent{
            if (_arg1 == null){
                _arg1 = getValueFromSource();
            };
            if (((isRealValue(_arg1)) || (required))){
                return (processValidation(_arg1, _arg2));
            };
            return (new ValidationResultEvent(ValidationResultEvent.VALID));
        }
        public function get source():Object{
            return (_source);
        }
        public function set property(_arg1:String):void{
            _property = _arg1;
        }
        public function get requiredFieldError():String{
            return (_requiredFieldError);
        }
        protected function handleResults(_arg1:Array):ValidationResultEvent{
            var _local2:ValidationResultEvent;
            var _local3:Object;
            var _local4:String;
            var _local5:int;
            var _local6:int;
            if (_arg1.length > 0){
                _local2 = new ValidationResultEvent(ValidationResultEvent.INVALID);
                _local2.results = _arg1;
                if (subFields.length > 0){
                    _local3 = {};
                    _local5 = _arg1.length;
                    _local6 = 0;
                    while (_local6 < _local5) {
                        _local4 = _arg1[_local6].subField;
                        if (_local4){
                            _local3[_local4] = true;
                        };
                        _local6++;
                    };
                    _local5 = subFields.length;
                    _local6 = 0;
                    while (_local6 < _local5) {
                        if (!_local3[subFields[_local6]]){
                            _arg1.push(new ValidationResult(false, subFields[_local6]));
                        };
                        _local6++;
                    };
                };
            } else {
                _local2 = new ValidationResultEvent(ValidationResultEvent.VALID);
            };
            return (_local2);
        }
        public function get listener():Object{
            return (_listener);
        }
        public function get trigger():IEventDispatcher{
            return (_trigger);
        }
        public function set source(_arg1:Object):void{
            var _local2:String;
            if (_source == _arg1){
                return;
            };
            if ((_arg1 is String)){
                _local2 = resourceManager.getString("validators", "SAttribute", [_arg1]);
                throw (new Error(_local2));
            };
            removeTriggerHandler();
            removeListenerHandler();
            _source = _arg1;
            addTriggerHandler();
            addListenerHandler();
        }
        protected function get resourceManager():IResourceManager{
            return (_resourceManager);
        }
        public function get enabled():Boolean{
            return (_enabled);
        }
        private function processValidation(_arg1:Object, _arg2:Boolean):ValidationResultEvent{
            var _local3:ValidationResultEvent;
            var _local4:Array;
            if (_enabled){
                _local4 = doValidation(_arg1);
                _local3 = handleResults(_local4);
            } else {
                _arg2 = true;
            };
            if (!_arg2){
                dispatchEvent(_local3);
            };
            return (_local3);
        }
        public function get triggerEvent():String{
            return (_triggerEvent);
        }
        protected function get actualTrigger():IEventDispatcher{
            if (_trigger){
                return (_trigger);
            };
            if (_source){
                return ((_source as IEventDispatcher));
            };
            return (null);
        }
        protected function resourcesChanged():void{
            requiredFieldError = requiredFieldErrorOverride;
        }
        protected function get actualListeners():Array{
            var _local1:Array = [];
            if (_listener){
                _local1.push(_listener);
            } else {
                if (_source){
                    _local1.push(_source);
                };
            };
            return (_local1);
        }
        protected function removeListenerHandler():void{
            var _local1:Object;
            var _local2:Array = actualListeners;
            var _local3:int = _local2.length;
            var _local4:int;
            while (_local4 < _local3) {
                _local1 = _local2[_local4];
                if ((_local1 is IValidatorListener)){
                    removeEventListener(ValidationResultEvent.VALID, IValidatorListener(_local1).validationResultHandler);
                    removeEventListener(ValidationResultEvent.INVALID, IValidatorListener(_local1).validationResultHandler);
                };
                _local4++;
            };
        }
        public function initialized(_arg1:Object, _arg2:String):void{
            this.document = _arg1;
        }
        public function get property():String{
            return (_property);
        }
        public function set requiredFieldError(_arg1:String):void{
            requiredFieldErrorOverride = _arg1;
            _requiredFieldError = ((_arg1)!=null) ? _arg1 : resourceManager.getString("validators", "requiredFieldError");
        }
        private function validateRequired(_arg1:Object):ValidationResult{
            var _local2:String;
            if (required){
                _local2 = ((_arg1)!=null) ? String(_arg1) : "";
                _local2 = trimString(_local2);
                if (_local2.length == 0){
                    return (new ValidationResult(true, "", "requiredField", requiredFieldError));
                };
            };
            return (null);
        }
        protected function doValidation(_arg1:Object):Array{
            var _local2:Array = [];
            var _local3:ValidationResult = validateRequired(_arg1);
            if (_local3){
                _local2.push(_local3);
            };
            return (_local2);
        }
        public function set listener(_arg1:Object):void{
            removeListenerHandler();
            _listener = _arg1;
            addListenerHandler();
        }
        protected function isRealValue(_arg1:Object):Boolean{
            return (!((_arg1 == null)));
        }
        public function set trigger(_arg1:IEventDispatcher):void{
            removeTriggerHandler();
            _trigger = _arg1;
            addTriggerHandler();
        }
        private function addTriggerHandler():void{
            if (actualTrigger){
                actualTrigger.addEventListener(_triggerEvent, triggerHandler);
            };
        }
        private function resourceManager_changeHandler(_arg1:Event):void{
            resourcesChanged();
        }

    }
}//package mx.validators 
﻿package mx.validators {
    import mx.core.*;

    public class EmailValidator extends Validator {

        private static const DISALLOWED_DOMAIN_CHARS:String = "()<>,;:\\\"[] `~!#$%^&*+={}|/?'";
        mx_internal static const VERSION:String = "3.5.0.12683";
        private static const DISALLOWED_LOCALNAME_CHARS:String = "()<>,;:\\\"[] `~!#$%^&*={}|/?'";

        private var _missingUsernameError:String;
        private var tooManyAtSignsErrorOverride:String;
        private var _invalidIPDomainError:String;
        private var invalidCharErrorOverride:String;
        private var invalidPeriodsInDomainErrorOverride:String;
        private var invalidIPDomainErrorOverride:String;
        private var _invalidDomainError:String;
        private var _missingPeriodInDomainError:String;
        private var invalidDomainErrorOverride:String;
        private var missingPeriodInDomainErrorOverride:String;
        private var _invalidPeriodsInDomainError:String;
        private var _tooManyAtSignsError:String;
        private var _missingAtSignError:String;
        private var _invalidCharError:String;
        private var missingAtSignErrorOverride:String;
        private var missingUsernameErrorOverride:String;

        public static function validateEmail(_arg1:EmailValidator, _arg2:Object, _arg3:String):Array{
            var _local8:int;
            var _local9:int;
            var _local13:int;
            var _local14:int;
            var _local15:String;
            var _local4:Array = [];
            var _local5:String = String(_arg2);
            var _local6 = "";
            var _local7 = "";
            var _local10:int = _local5.indexOf("@");
            if (_local10 == -1){
                _local4.push(new ValidationResult(true, _arg3, "missingAtSign", _arg1.missingAtSignError));
                return (_local4);
            };
            if (_local5.indexOf("@", (_local10 + 1)) != -1){
                _local4.push(new ValidationResult(true, _arg3, "tooManyAtSigns", _arg1.tooManyAtSignsError));
                return (_local4);
            };
            _local6 = _local5.substring(0, _local10);
            _local7 = _local5.substring((_local10 + 1));
            var _local11:int = _local6.length;
            if (_local11 == 0){
                _local4.push(new ValidationResult(true, _arg3, "missingUsername", _arg1.missingUsernameError));
                return (_local4);
            };
            _local9 = 0;
            while (_local9 < _local11) {
                if (DISALLOWED_LOCALNAME_CHARS.indexOf(_local6.charAt(_local9)) != -1){
                    _local4.push(new ValidationResult(true, _arg3, "invalidChar", _arg1.invalidCharError));
                    return (_local4);
                };
                _local9++;
            };
            var _local12:int = _local7.length;
            if ((((_local7.charAt(0) == "[")) && ((_local7.charAt((_local12 - 1)) == "]")))){
                if (!isValidIPAddress(_local7.substring(1, (_local12 - 1)))){
                    _local4.push(new ValidationResult(true, _arg3, "invalidIPDomain", _arg1.invalidIPDomainError));
                    return (_local4);
                };
            } else {
                _local13 = _local7.indexOf(".");
                _local14 = 0;
                _local15 = "";
                if (_local13 == -1){
                    _local4.push(new ValidationResult(true, _arg3, "missingPeriodInDomain", _arg1.missingPeriodInDomainError));
                    return (_local4);
                };
                while (true) {
                    _local14 = _local7.indexOf(".", (_local13 + 1));
                    if (_local14 == -1){
                        _local15 = _local7.substring((_local13 + 1));
                        if (((((((!((_local15.length == 3))) && (!((_local15.length == 2))))) && (!((_local15.length == 4))))) && (!((_local15.length == 6))))){
                            _local4.push(new ValidationResult(true, _arg3, "invalidDomain", _arg1.invalidDomainError));
                            return (_local4);
                        };
                        break;
                    };
                    if (_local14 == (_local13 + 1)){
                        _local4.push(new ValidationResult(true, _arg3, "invalidPeriodsInDomain", _arg1.invalidPeriodsInDomainError));
                        return (_local4);
                    };
                    _local13 = _local14;
                };
                _local9 = 0;
                while (_local9 < _local12) {
                    if (DISALLOWED_DOMAIN_CHARS.indexOf(_local7.charAt(_local9)) != -1){
                        _local4.push(new ValidationResult(true, _arg3, "invalidChar", _arg1.invalidCharError));
                        return (_local4);
                    };
                    _local9++;
                };
                if (_local7.charAt(0) == "."){
                    _local4.push(new ValidationResult(true, _arg3, "invalidDomain", _arg1.invalidDomainError));
                    return (_local4);
                };
            };
            return (_local4);
        }
        private static function isValidIPAddress(_arg1:String):Boolean{
            var _local5:Number;
            var _local6:int;
            var _local7:int;
            var _local8:Boolean;
            var _local9:Boolean;
            var _local2:Array = [];
            var _local3:int;
            var _local4:int;
            if (_arg1.indexOf(":") != -1){
                _local8 = !((_arg1.indexOf("::") == -1));
                if (_local8){
                    _arg1 = _arg1.replace(/^::/, "");
                    _arg1 = _arg1.replace(/::/g, ":");
                };
                while (true) {
                    _local4 = _arg1.indexOf(":", _local3);
                    if (_local4 != -1){
                        _local2.push(_arg1.substring(_local3, _local4));
                    } else {
                        _local2.push(_arg1.substring(_local3));
                        break;
                    };
                    _local3 = (_local4 + 1);
                };
                _local6 = _local2.length;
                _local9 = !((_local2[(_local6 - 1)].indexOf(".") == -1));
                if (_local9){
                    if (((((!((_local2.length == 7))) && (!(_local8)))) || ((_local2.length > 7)))){
                        return (false);
                    };
                    _local7 = 0;
                    while (_local7 < _local6) {
                        if (_local7 == (_local6 - 1)){
                            return (isValidIPAddress(_local2[_local7]));
                        };
                        _local5 = parseInt(_local2[_local7], 16);
                        if (_local5 != 0){
                            return (false);
                        };
                        _local7++;
                    };
                } else {
                    if (((((!((_local2.length == 8))) && (!(_local8)))) || ((_local2.length > 8)))){
                        return (false);
                    };
                    _local7 = 0;
                    while (_local7 < _local6) {
                        _local5 = parseInt(_local2[_local7], 16);
                        if (((((isNaN(_local5)) || ((_local5 < 0)))) || ((_local5 > 0xFFFF)))){
                            return (false);
                        };
                        _local7++;
                    };
                };
                return (true);
            };
            if (_arg1.indexOf(".") != -1){
                while (true) {
                    _local4 = _arg1.indexOf(".", _local3);
                    if (_local4 != -1){
                        _local2.push(_arg1.substring(_local3, _local4));
                    } else {
                        _local2.push(_arg1.substring(_local3));
                        break;
                    };
                    _local3 = (_local4 + 1);
                };
                if (_local2.length != 4){
                    return (false);
                };
                _local6 = _local2.length;
                _local7 = 0;
                while (_local7 < _local6) {
                    _local5 = Number(_local2[_local7]);
                    if (((((isNaN(_local5)) || ((_local5 < 0)))) || ((_local5 > 0xFF)))){
                        return (false);
                    };
                    _local7++;
                };
                return (true);
            };
            return (false);
        }

        public function set missingAtSignError(_arg1:String):void{
            missingAtSignErrorOverride = _arg1;
            _missingAtSignError = ((_arg1)!=null) ? _arg1 : resourceManager.getString("validators", "missingAtSignError");
        }
        public function set invalidPeriodsInDomainError(_arg1:String):void{
            invalidPeriodsInDomainErrorOverride = _arg1;
            _invalidPeriodsInDomainError = ((_arg1)!=null) ? _arg1 : resourceManager.getString("validators", "invalidPeriodsInDomainError");
        }
        public function set invalidIPDomainError(_arg1:String):void{
            invalidIPDomainErrorOverride = _arg1;
            _invalidIPDomainError = ((_arg1)!=null) ? _arg1 : resourceManager.getString("validators", "invalidIPDomainError");
        }
        override protected function doValidation(_arg1:Object):Array{
            var _local2:Array = super.doValidation(_arg1);
            var _local3:String = ((_arg1) ? String(_arg1) : "");
            if ((((_local2.length > 0)) || ((((_local3.length == 0)) && (!(required)))))){
                return (_local2);
            };
            return (EmailValidator.validateEmail(this, _arg1, null));
        }
        public function set invalidDomainError(_arg1:String):void{
            invalidDomainErrorOverride = _arg1;
            _invalidDomainError = ((_arg1)!=null) ? _arg1 : resourceManager.getString("validators", "invalidDomainErrorEV");
        }
        public function get invalidCharError():String{
            return (_invalidCharError);
        }
        override protected function resourcesChanged():void{
            super.resourcesChanged();
            invalidCharError = invalidCharErrorOverride;
            invalidDomainError = invalidDomainErrorOverride;
            invalidIPDomainError = invalidIPDomainErrorOverride;
            invalidPeriodsInDomainError = invalidPeriodsInDomainErrorOverride;
            missingAtSignError = missingAtSignErrorOverride;
            missingPeriodInDomainError = missingPeriodInDomainErrorOverride;
            missingUsernameError = missingUsernameErrorOverride;
            tooManyAtSignsError = tooManyAtSignsErrorOverride;
        }
        public function set missingUsernameError(_arg1:String):void{
            missingUsernameErrorOverride = _arg1;
            _missingUsernameError = ((_arg1)!=null) ? _arg1 : resourceManager.getString("validators", "missingUsernameError");
        }
        public function get missingAtSignError():String{
            return (_missingAtSignError);
        }
        public function get invalidIPDomainError():String{
            return (_invalidIPDomainError);
        }
        public function get tooManyAtSignsError():String{
            return (_tooManyAtSignsError);
        }
        public function set tooManyAtSignsError(_arg1:String):void{
            tooManyAtSignsErrorOverride = _arg1;
            _tooManyAtSignsError = ((_arg1)!=null) ? _arg1 : resourceManager.getString("validators", "tooManyAtSignsError");
        }
        public function get invalidPeriodsInDomainError():String{
            return (_invalidPeriodsInDomainError);
        }
        public function get invalidDomainError():String{
            return (_invalidDomainError);
        }
        public function set missingPeriodInDomainError(_arg1:String):void{
            missingPeriodInDomainErrorOverride = _arg1;
            _missingPeriodInDomainError = ((_arg1)!=null) ? _arg1 : resourceManager.getString("validators", "missingPeriodInDomainError");
        }
        public function set invalidCharError(_arg1:String):void{
            invalidCharErrorOverride = _arg1;
            _invalidCharError = ((_arg1)!=null) ? _arg1 : resourceManager.getString("validators", "invalidCharErrorEV");
        }
        public function get missingPeriodInDomainError():String{
            return (_missingPeriodInDomainError);
        }
        public function get missingUsernameError():String{
            return (_missingUsernameError);
        }

    }
}//package mx.validators 
﻿package mx.events {
    import mx.core.*;

    public final class PropertyChangeEventKind {

        mx_internal static const VERSION:String = "3.5.0.12683";
        public static const UPDATE:String = "update";
        public static const DELETE:String = "delete";

    }
}//package mx.events 
﻿package mx.events {
    import flash.events.*;
    import mx.core.*;

    public class CollectionEvent extends Event {

        mx_internal static const VERSION:String = "3.5.0.12683";
        public static const COLLECTION_CHANGE:String = "collectionChange";

        public var kind:String;
        public var location:int;
        public var items:Array;
        public var oldLocation:int;

        public function CollectionEvent(_arg1:String, _arg2:Boolean=false, _arg3:Boolean=false, _arg4:String=null, _arg5:int=-1, _arg6:int=-1, _arg7:Array=null){
            super(_arg1, _arg2, _arg3);
            this.kind = _arg4;
            this.location = _arg5;
            this.oldLocation = _arg6;
            this.items = ((_arg7) ? _arg7 : []);
        }
        override public function toString():String{
            return (formatToString("CollectionEvent", "kind", "location", "oldLocation", "type", "bubbles", "cancelable", "eventPhase"));
        }
        override public function clone():Event{
            return (new CollectionEvent(type, bubbles, cancelable, kind, location, oldLocation, items));
        }

    }
}//package mx.events 
﻿package mx.events {
    import flash.events.*;
    import mx.core.*;

    public class ResourceEvent extends ProgressEvent {

        mx_internal static const VERSION:String = "3.5.0.12683";
        public static const COMPLETE:String = "complete";
        public static const PROGRESS:String = "progress";
        public static const ERROR:String = "error";

        public var errorText:String;

        public function ResourceEvent(_arg1:String, _arg2:Boolean=false, _arg3:Boolean=false, _arg4:uint=0, _arg5:uint=0, _arg6:String=null){
            super(_arg1, _arg2, _arg3, _arg4, _arg5);
            this.errorText = _arg6;
        }
        override public function clone():Event{
            return (new ResourceEvent(type, bubbles, cancelable, bytesLoaded, bytesTotal, errorText));
        }

    }
}//package mx.events 
﻿package mx.events {
    import mx.core.*;

    public final class CollectionEventKind {

        public static const ADD:String = "add";
        public static const REMOVE:String = "remove";
        public static const UPDATE:String = "update";
        public static const MOVE:String = "move";
        mx_internal static const EXPAND:String = "expand";
        public static const REPLACE:String = "replace";
        mx_internal static const VERSION:String = "3.5.0.12683";
        public static const REFRESH:String = "refresh";
        public static const RESET:String = "reset";

    }
}//package mx.events 
﻿package mx.events {
    import flash.events.*;
    import mx.modules.*;
    import mx.core.*;

    public class ModuleEvent extends ProgressEvent {

        public static const READY:String = "ready";
        public static const ERROR:String = "error";
        public static const PROGRESS:String = "progress";
        mx_internal static const VERSION:String = "3.5.0.12683";
        public static const SETUP:String = "setup";
        public static const UNLOAD:String = "unload";

        public var errorText:String;
        private var _module:IModuleInfo;

        public function ModuleEvent(_arg1:String, _arg2:Boolean=false, _arg3:Boolean=false, _arg4:uint=0, _arg5:uint=0, _arg6:String=null, _arg7:IModuleInfo=null){
            super(_arg1, _arg2, _arg3, _arg4, _arg5);
            this.errorText = _arg6;
            this._module = _arg7;
        }
        public function get module():IModuleInfo{
            if (_module){
                return (_module);
            };
            return ((target as IModuleInfo));
        }
        override public function clone():Event{
            return (new ModuleEvent(type, bubbles, cancelable, bytesLoaded, bytesTotal, errorText, module));
        }

    }
}//package mx.events 
﻿package mx.events {
    import flash.events.*;
    import mx.core.*;

    public class ValidationResultEvent extends Event {

        public static const INVALID:String = "invalid";
        mx_internal static const VERSION:String = "3.5.0.12683";
        public static const VALID:String = "valid";

        public var results:Array;
        public var field:String;

        public function ValidationResultEvent(_arg1:String, _arg2:Boolean=false, _arg3:Boolean=false, _arg4:String=null, _arg5:Array=null){
            super(_arg1, _arg2, _arg3);
            this.field = _arg4;
            this.results = _arg5;
        }
        public function get message():String{
            var _local1 = "";
            var _local2:int = results.length;
            var _local3:int;
            while (_local3 < _local2) {
                if (results[_local3].isError){
                    _local1 = (_local1 + (((_local1 == "")) ? "" : "\n"));
                    _local1 = (_local1 + results[_local3].errorMessage);
                };
                _local3++;
            };
            return (_local1);
        }
        override public function clone():Event{
            return (new ValidationResultEvent(type, bubbles, cancelable, field, results));
        }

    }
}//package mx.events 
﻿package mx.events {
    import flash.events.*;
    import mx.core.*;

    public class PropertyChangeEvent extends Event {

        mx_internal static const VERSION:String = "3.5.0.12683";
        public static const PROPERTY_CHANGE:String = "propertyChange";

        public var newValue:Object;
        public var kind:String;
        public var property:Object;
        public var oldValue:Object;
        public var source:Object;

        public function PropertyChangeEvent(_arg1:String, _arg2:Boolean=false, _arg3:Boolean=false, _arg4:String=null, _arg5:Object=null, _arg6:Object=null, _arg7:Object=null, _arg8:Object=null){
            super(_arg1, _arg2, _arg3);
            this.kind = _arg4;
            this.property = _arg5;
            this.oldValue = _arg6;
            this.newValue = _arg7;
            this.source = _arg8;
        }
        public static function createUpdateEvent(_arg1:Object, _arg2:Object, _arg3:Object, _arg4:Object):PropertyChangeEvent{
            var _local5:PropertyChangeEvent = new PropertyChangeEvent(PROPERTY_CHANGE);
            _local5.kind = PropertyChangeEventKind.UPDATE;
            _local5.oldValue = _arg3;
            _local5.newValue = _arg4;
            _local5.source = _arg1;
            _local5.property = _arg2;
            return (_local5);
        }

        override public function clone():Event{
            return (new PropertyChangeEvent(type, bubbles, cancelable, kind, property, oldValue, newValue, source));
        }

    }
}//package mx.events 
﻿package mx.events {
    import flash.events.*;
    import mx.core.*;

    public class FlexEvent extends Event {

        public static const ADD:String = "add";
        public static const TRANSFORM_CHANGE:String = "transformChange";
        public static const ENTER_FRAME:String = "flexEventEnterFrame";
        public static const INIT_COMPLETE:String = "initComplete";
        public static const REMOVE:String = "remove";
        public static const BUTTON_DOWN:String = "buttonDown";
        public static const EXIT_STATE:String = "exitState";
        public static const CREATION_COMPLETE:String = "creationComplete";
        public static const REPEAT:String = "repeat";
        public static const LOADING:String = "loading";
        public static const RENDER:String = "flexEventRender";
        public static const REPEAT_START:String = "repeatStart";
        public static const INITIALIZE:String = "initialize";
        public static const ENTER_STATE:String = "enterState";
        public static const URL_CHANGED:String = "urlChanged";
        public static const REPEAT_END:String = "repeatEnd";
        mx_internal static const VERSION:String = "3.5.0.12683";
        public static const HIDE:String = "hide";
        public static const ENTER:String = "enter";
        public static const PRELOADER_DONE:String = "preloaderDone";
        public static const CURSOR_UPDATE:String = "cursorUpdate";
        public static const PREINITIALIZE:String = "preinitialize";
        public static const INVALID:String = "invalid";
        public static const IDLE:String = "idle";
        public static const VALID:String = "valid";
        public static const DATA_CHANGE:String = "dataChange";
        public static const APPLICATION_COMPLETE:String = "applicationComplete";
        public static const VALUE_COMMIT:String = "valueCommit";
        public static const UPDATE_COMPLETE:String = "updateComplete";
        public static const INIT_PROGRESS:String = "initProgress";
        public static const SHOW:String = "show";

        public function FlexEvent(_arg1:String, _arg2:Boolean=false, _arg3:Boolean=false){
            super(_arg1, _arg2, _arg3);
        }
        override public function clone():Event{
            return (new FlexEvent(type, bubbles, cancelable));
        }

    }
}//package mx.events 
﻿package mx.utils {
    import flash.utils.*;
    import mx.core.*;

    public class UIDUtil {

        mx_internal static const VERSION:String = "3.5.0.12683";
        private static const ALPHA_CHAR_CODES:Array = [48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70];

        private static var uidDictionary:Dictionary = new Dictionary(true);

        public static function fromByteArray(_arg1:ByteArray):String{
            var _local2:Array;
            var _local3:uint;
            var _local4:uint;
            var _local5:int;
            if (((((!((_arg1 == null))) && ((_arg1.length >= 16)))) && ((_arg1.bytesAvailable >= 16)))){
                _local2 = new Array(36);
                _local3 = 0;
                _local4 = 0;
                while (_local4 < 16) {
                    if ((((((((_local4 == 4)) || ((_local4 == 6)))) || ((_local4 == 8)))) || ((_local4 == 10)))){
                        var _temp1 = _local3;
                        _local3 = (_local3 + 1);
                        var _local6 = _temp1;
                        _local2[_local6] = 45;
                    };
                    _local5 = _arg1.readByte();
                    var _temp2 = _local3;
                    _local3 = (_local3 + 1);
                    _local6 = _temp2;
                    _local2[_local6] = ALPHA_CHAR_CODES[((_local5 & 240) >>> 4)];
                    var _temp3 = _local3;
                    _local3 = (_local3 + 1);
                    var _local7 = _temp3;
                    _local2[_local7] = ALPHA_CHAR_CODES[(_local5 & 15)];
                    _local4++;
                };
                return (String.fromCharCode.apply(null, _local2));
            };
            return (null);
        }
        public static function isUID(_arg1:String):Boolean{
            var _local2:uint;
            var _local3:Number;
            if (((!((_arg1 == null))) && ((_arg1.length == 36)))){
                _local2 = 0;
                while (_local2 < 36) {
                    _local3 = _arg1.charCodeAt(_local2);
                    if ((((((((_local2 == 8)) || ((_local2 == 13)))) || ((_local2 == 18)))) || ((_local2 == 23)))){
                        if (_local3 != 45){
                            return (false);
                        };
                    } else {
                        if ((((((_local3 < 48)) || ((_local3 > 70)))) || ((((_local3 > 57)) && ((_local3 < 65)))))){
                            return (false);
                        };
                    };
                    _local2++;
                };
                return (true);
            };
            return (false);
        }
        public static function createUID():String{
            var _local3:int;
            var _local4:int;
            var _local1:Array = new Array(36);
            var _local2:int;
            _local3 = 0;
            while (_local3 < 8) {
                var _temp1 = _local2;
                _local2 = (_local2 + 1);
                var _local7 = _temp1;
                _local1[_local7] = ALPHA_CHAR_CODES[Math.floor((Math.random() * 16))];
                _local3++;
            };
            _local3 = 0;
            while (_local3 < 3) {
                var _temp2 = _local2;
                _local2 = (_local2 + 1);
                _local7 = _temp2;
                _local1[_local7] = 45;
                _local4 = 0;
                while (_local4 < 4) {
                    var _temp3 = _local2;
                    _local2 = (_local2 + 1);
                    var _local8 = _temp3;
                    _local1[_local8] = ALPHA_CHAR_CODES[Math.floor((Math.random() * 16))];
                    _local4++;
                };
                _local3++;
            };
            var _temp4 = _local2;
            _local2 = (_local2 + 1);
            _local7 = _temp4;
            _local1[_local7] = 45;
            var _local5:Number = new Date().getTime();
            var _local6:String = ("0000000" + _local5.toString(16).toUpperCase()).substr(-8);
            _local3 = 0;
            while (_local3 < 8) {
                var _temp5 = _local2;
                _local2 = (_local2 + 1);
                _local8 = _temp5;
                _local1[_local8] = _local6.charCodeAt(_local3);
                _local3++;
            };
            _local3 = 0;
            while (_local3 < 4) {
                var _temp6 = _local2;
                _local2 = (_local2 + 1);
                _local8 = _temp6;
                _local1[_local8] = ALPHA_CHAR_CODES[Math.floor((Math.random() * 16))];
                _local3++;
            };
            return (String.fromCharCode.apply(null, _local1));
        }
        public static function toByteArray(_arg1:String):ByteArray{
            var _local2:ByteArray;
            var _local3:uint;
            var _local4:String;
            var _local5:uint;
            var _local6:uint;
            if (isUID(_arg1)){
                _local2 = new ByteArray();
                _local3 = 0;
                while (_local3 < _arg1.length) {
                    _local4 = _arg1.charAt(_local3);
                    if (_local4 == "-"){
                    } else {
                        _local5 = getDigit(_local4);
                        _local3++;
                        _local6 = getDigit(_arg1.charAt(_local3));
                        _local2.writeByte((((_local5 << 4) | _local6) & 0xFF));
                    };
                    _local3++;
                };
                _local2.position = 0;
                return (_local2);
            };
            return (null);
        }
        private static function getDigit(_arg1:String):uint{
            switch (_arg1){
                case "A":
                case "a":
                    return (10);
                case "B":
                case "b":
                    return (11);
                case "C":
                case "c":
                    return (12);
                case "D":
                case "d":
                    return (13);
                case "E":
                case "e":
                    return (14);
                case "F":
                case "f":
                    return (15);
                default:
                    return (new uint(_arg1));
            };
        }
        public static function getUID(_arg1:Object):String{
            var result:* = null;
            var xitem:* = null;
            var nodeKind:* = null;
            var notificationFunction:* = null;
            var item:* = _arg1;
            result = null;
            if (item == null){
                return (result);
            };
            if ((item is IUID)){
                result = IUID(item).uid;
                if ((((result == null)) || ((result.length == 0)))){
                    result = createUID();
                    IUID(item).uid = result;
                };
            } else {
                if ((((item is IPropertyChangeNotifier)) && (!((item is IUIComponent))))){
                    result = IPropertyChangeNotifier(item).uid;
                    if ((((result == null)) || ((result.length == 0)))){
                        result = createUID();
                        IPropertyChangeNotifier(item).uid = result;
                    };
                } else {
                    if ((item is String)){
                        return ((item as String));
                    };
                    try {
                        if ((((item is XMLList)) && ((item.length == 1)))){
                            item = item[0];
                        };
                        if ((item is XML)){
                            xitem = XML(item);
                            nodeKind = xitem.nodeKind();
                            if ((((nodeKind == "text")) || ((nodeKind == "attribute")))){
                                return (xitem.toString());
                            };
                            notificationFunction = xitem.notification();
                            if (!(notificationFunction is Function)){
                                notificationFunction = XMLNotifier.initializeXMLForNotification();
                                xitem.setNotification(notificationFunction);
                            };
                            if (notificationFunction["uid"] == undefined){
                                result = (notificationFunction["uid"] = createUID());
                            };
                            result = notificationFunction["uid"];
                        } else {
                            if (("mx_internal_uid" in item)){
                                return (item.mx_internal_uid);
                            };
                            if (("uid" in item)){
                                return (item.uid);
                            };
                            result = uidDictionary[item];
                            if (!result){
                                result = createUID();
                                try {
                                    item.mx_internal_uid = result;
                                } catch(e:Error) {
                                    uidDictionary[item] = result;
                                };
                            };
                        };
                    } catch(e:Error) {
                        result = item.toString();
                    };
                };
            };
            return (result);
        }

    }
}//package mx.utils 
﻿package mx.utils {
    import flash.utils.*;
    import mx.collections.*;
    import flash.xml.*;
    import mx.core.*;

    public class ObjectUtil {

        mx_internal static const VERSION:String = "3.5.0.12683";

        private static var defaultToStringExcludes:Array = ["password", "credentials"];
        private static var CLASS_INFO_CACHE:Object = {};
        private static var refCount:int = 0;

        public static function isSimple(_arg1:Object):Boolean{
            var _local2 = typeof(_arg1);
            switch (_local2){
                case "number":
                case "string":
                case "boolean":
                    return (true);
                case "object":
                    return ((((_arg1 is Date)) || ((_arg1 is Array))));
            };
            return (false);
        }
        private static function internalToString(_arg1:Object, _arg2:int=0, _arg3:Dictionary=null, _arg4:Array=null, _arg5:Array=null):String{
            var str:* = null;
            var classInfo:* = null;
            var properties:* = null;
            var isArray:* = false;
            var isDict:* = false;
            var prop:* = undefined;
            var j:* = 0;
            var id:* = null;
            var value:* = _arg1;
            var indent:int = _arg2;
            var refs = _arg3;
            var namespaceURIs = _arg4;
            var exclude = _arg5;
            var type:* = (((value == null)) ? "null" : typeof(value));
            switch (type){
                case "boolean":
                case "number":
                    return (value.toString());
                case "string":
                    return ((("\"" + value.toString()) + "\""));
                case "object":
                    if ((value is Date)){
                        return (value.toString());
                    };
                    if ((value is XMLNode)){
                        return (value.toString());
                    };
                    if ((value is Class)){
                        return ((("(" + getQualifiedClassName(value)) + ")"));
                    };
                    classInfo = getClassInfo(value, exclude, {
                        includeReadOnly:true,
                        uris:namespaceURIs
                    });
                    properties = classInfo.properties;
                    str = (("(" + classInfo.name) + ")");
                    if (refs == null){
                        refs = new Dictionary(true);
                    };
                    try {
                        id = refs[value];
                        if (id != null){
                            str = (str + ("#" + int(id)));
                            return (str);
                        };
                    } catch(e:Error) {
                        return (String(value));
                    };
                    if (value != null){
                        str = (str + ("#" + refCount.toString()));
                        refs[value] = refCount;
                        refCount++;
                    };
                    isArray = (value is Array);
                    isDict = (value is Dictionary);
                    indent = (indent + 2);
                    j = 0;
                    while (j < properties.length) {
                        str = newline(str, indent);
                        prop = properties[j];
                        if (isArray){
                            str = (str + "[");
                        } else {
                            if (isDict){
                                str = (str + "{");
                            };
                        };
                        if (isDict){
                            str = (str + internalToString(prop, indent, refs, namespaceURIs, exclude));
                        } else {
                            str = (str + prop.toString());
                        };
                        if (isArray){
                            str = (str + "] ");
                        } else {
                            if (isDict){
                                str = (str + "} = ");
                            } else {
                                str = (str + " = ");
                            };
                        };
                        try {
                            str = (str + internalToString(value[prop], indent, refs, namespaceURIs, exclude));
                        } catch(e:Error) {
                            str = (str + "?");
                        };
                        j = (j + 1);
                    };
                    indent = (indent - 2);
                    return (str);
                case "xml":
                    return (value.toXMLString());
                default:
                    return ((("(" + type) + ")"));
            };
        }
        public static function getClassInfo(_arg1:Object, _arg2:Array=null, _arg3:Object=null):Object{
            var n:* = 0;
            var i:* = 0;
            var result:* = null;
            var cacheKey:* = null;
            var className:* = null;
            var classAlias:* = null;
            var properties:* = null;
            var prop:* = null;
            var metadataInfo:* = null;
            var classInfo:* = null;
            var numericIndex:* = false;
            var key:* = undefined;
            var p:* = null;
            var pi:* = NaN;
            var uris:* = null;
            var uri:* = null;
            var qName:* = null;
            var j:* = 0;
            var obj:* = _arg1;
            var excludes = _arg2;
            var options = _arg3;
            if ((obj is ObjectProxy)){
                obj = ObjectProxy(obj).object_proxy::object;
            };
            if (options == null){
                options = {
                    includeReadOnly:true,
                    uris:null,
                    includeTransient:true
                };
            };
            var propertyNames:* = [];
            var dynamic:* = false;
            if (typeof(obj) == "xml"){
                className = "XML";
                properties = obj.text();
                if (properties.length()){
                    propertyNames.push("*");
                };
                properties = obj.attributes();
            } else {
                classInfo = DescribeTypeCache.describeType(obj).typeDescription;
                className = classInfo.@name.toString();
                classAlias = classInfo.@alias.toString();
                dynamic = (classInfo.@isDynamic.toString() == "true");
                if (options.includeReadOnly){
                    properties = (classInfo..accessor.(@access != "writeonly") + classInfo..variable);
                } else {
                    properties = (classInfo..accessor.(@access == "readwrite") + classInfo..variable);
                };
                numericIndex = false;
            };
            if (!dynamic){
                cacheKey = getCacheKey(obj, excludes, options);
                result = CLASS_INFO_CACHE[cacheKey];
                if (result != null){
                    return (result);
                };
            };
            result = {};
            result["name"] = className;
            result["alias"] = classAlias;
            result["properties"] = propertyNames;
            result["dynamic"] = dynamic;
            var _local5 = recordMetadata(properties);
            metadataInfo = _local5;
            result["metadata"] = _local5;
            var excludeObject:* = {};
            if (excludes){
                n = excludes.length;
                i = 0;
                while (i < n) {
                    excludeObject[excludes[i]] = 1;
                    i = (i + 1);
                };
            };
            var isArray:* = (className == "Array");
            var isDict:* = (className == "flash.utils::Dictionary");
            if (isDict){
                for (key in obj) {
                    propertyNames.push(key);
                };
            } else {
                if (dynamic){
                    for (p in obj) {
                        if (excludeObject[p] != 1){
                            if (isArray){
                                pi = parseInt(p);
                                if (isNaN(pi)){
                                    propertyNames.push(new QName("", p));
                                } else {
                                    propertyNames.push(pi);
                                };
                            } else {
                                propertyNames.push(new QName("", p));
                            };
                        };
                    };
                    numericIndex = ((isArray) && (!(isNaN(Number(p)))));
                };
            };
            if (((((isArray) || (isDict))) || ((className == "Object")))){
            } else {
                if (className == "XML"){
                    n = properties.length();
                    i = 0;
                    while (i < n) {
                        p = properties[i].name();
                        if (excludeObject[p] != 1){
                            propertyNames.push(new QName("", ("@" + p)));
                        };
                        i = (i + 1);
                    };
                } else {
                    n = properties.length();
                    uris = options.uris;
                    i = 0;
                    while (i < n) {
                        prop = properties[i];
                        p = prop.@name.toString();
                        uri = prop.@uri.toString();
                        if (excludeObject[p] == 1){
                        } else {
                            if (((!(options.includeTransient)) && (internalHasMetadata(metadataInfo, p, "Transient")))){
                            } else {
                                if (uris != null){
                                    if ((((uris.length == 1)) && ((uris[0] == "*")))){
                                        qName = new QName(uri, p);
                                        try {
                                            obj[qName];
                                            propertyNames.push();
                                        } catch(e:Error) {
                                        };
                                    } else {
                                        j = 0;
                                        while (j < uris.length) {
                                            uri = uris[j];
                                            if (prop.@uri.toString() == uri){
                                                qName = new QName(uri, p);
                                                try {
                                                    obj[qName];
                                                    propertyNames.push(qName);
                                                } catch(e:Error) {
                                                };
                                            };
                                            j = (j + 1);
                                        };
                                    };
                                } else {
                                    if (uri.length == 0){
                                        qName = new QName(uri, p);
                                        try {
                                            obj[qName];
                                            propertyNames.push(qName);
                                        } catch(e:Error) {
                                        };
                                    };
                                };
                            };
                        };
                        i = (i + 1);
                    };
                };
            };
            propertyNames.sort((Array.CASEINSENSITIVE | ((numericIndex) ? Array.NUMERIC : 0)));
            if (!isDict){
                i = 0;
                while (i < (propertyNames.length - 1)) {
                    if (propertyNames[i].toString() == propertyNames[(i + 1)].toString()){
                        propertyNames.splice(i, 1);
                        i = (i - 1);
                    };
                    i = (i + 1);
                };
            };
            if (!dynamic){
                cacheKey = getCacheKey(obj, excludes, options);
                CLASS_INFO_CACHE[cacheKey] = result;
            };
            return (result);
        }
        private static function arrayCompare(_arg1:Array, _arg2:Array, _arg3:int, _arg4:int, _arg5:Dictionary):int{
            var _local7:Object;
            var _local6:int;
            if (_arg1.length != _arg2.length){
                if (_arg1.length < _arg2.length){
                    _local6 = -1;
                } else {
                    _local6 = 1;
                };
            } else {
                for (_local7 in _arg1) {
                    if (_arg2.hasOwnProperty(_local7)){
                        _local6 = internalCompare(_arg1[_local7], _arg2[_local7], _arg3, _arg4, _arg5);
                        if (_local6 != 0){
                            return (_local6);
                        };
                    } else {
                        return (-1);
                    };
                };
                for (_local7 in _arg2) {
                    if (!_arg1.hasOwnProperty(_local7)){
                        return (1);
                    };
                };
            };
            return (_local6);
        }
        public static function stringCompare(_arg1:String, _arg2:String, _arg3:Boolean=false):int{
            if ((((_arg1 == null)) && ((_arg2 == null)))){
                return (0);
            };
            if (_arg1 == null){
                return (1);
            };
            if (_arg2 == null){
                return (-1);
            };
            if (_arg3){
                _arg1 = _arg1.toLocaleLowerCase();
                _arg2 = _arg2.toLocaleLowerCase();
            };
            var _local4:int = _arg1.localeCompare(_arg2);
            if (_local4 < -1){
                _local4 = -1;
            } else {
                if (_local4 > 1){
                    _local4 = 1;
                };
            };
            return (_local4);
        }
        public static function dateCompare(_arg1:Date, _arg2:Date):int{
            if ((((_arg1 == null)) && ((_arg2 == null)))){
                return (0);
            };
            if (_arg1 == null){
                return (1);
            };
            if (_arg2 == null){
                return (-1);
            };
            var _local3:Number = _arg1.getTime();
            var _local4:Number = _arg2.getTime();
            if (_local3 < _local4){
                return (-1);
            };
            if (_local3 > _local4){
                return (1);
            };
            return (0);
        }
        public static function numericCompare(_arg1:Number, _arg2:Number):int{
            if (((isNaN(_arg1)) && (isNaN(_arg2)))){
                return (0);
            };
            if (isNaN(_arg1)){
                return (1);
            };
            if (isNaN(_arg2)){
                return (-1);
            };
            if (_arg1 < _arg2){
                return (-1);
            };
            if (_arg1 > _arg2){
                return (1);
            };
            return (0);
        }
        private static function newline(_arg1:String, _arg2:int=0):String{
            var _local3:String = _arg1;
            _local3 = (_local3 + "\n");
            var _local4:int;
            while (_local4 < _arg2) {
                _local3 = (_local3 + " ");
                _local4++;
            };
            return (_local3);
        }
        private static function getRef(_arg1:Object, _arg2:Dictionary):Object{
            var _local3:Object = _arg2[_arg1];
            while (((_local3) && (!((_local3 == _arg2[_local3]))))) {
                _local3 = _arg2[_local3];
            };
            if (!_local3){
                _local3 = _arg1;
            };
            if (_local3 != _arg2[_arg1]){
                _arg2[_arg1] = _local3;
            };
            return (_local3);
        }
        private static function recordMetadata(_arg1:XMLList):Object{
            var prop:* = null;
            var propName:* = null;
            var metadataList:* = null;
            var metadata:* = null;
            var md:* = null;
            var mdName:* = null;
            var argsList:* = null;
            var value:* = null;
            var arg:* = null;
            var existing:* = null;
            var argKey:* = null;
            var argValue:* = null;
            var existingArray:* = null;
            var properties:* = _arg1;
            var result:* = null;
            try {
                for each (prop in properties) {
                    propName = prop.attribute("name").toString();
                    metadataList = prop.metadata;
                    if (metadataList.length() > 0){
                        if (result == null){
                            result = {};
                        };
                        metadata = {};
                        result[propName] = metadata;
                        for each (md in metadataList) {
                            mdName = md.attribute("name").toString();
                            argsList = md.arg;
                            value = {};
                            for each (arg in argsList) {
                                argKey = arg.attribute("key").toString();
                                if (argKey != null){
                                    argValue = arg.attribute("value").toString();
                                    value[argKey] = argValue;
                                };
                            };
                            existing = metadata[mdName];
                            if (existing != null){
                                if ((existing is Array)){
                                    existingArray = (existing as Array);
                                } else {
                                    existingArray = [existing];
                                    delete metadata[mdName];
                                };
                                existingArray.push(value);
                                existing = existingArray;
                            } else {
                                existing = value;
                            };
                            metadata[mdName] = existing;
                        };
                    };
                };
            } catch(e:Error) {
            };
            return (result);
        }
        public static function compare(_arg1:Object, _arg2:Object, _arg3:int=-1):int{
            return (internalCompare(_arg1, _arg2, 0, _arg3, new Dictionary(true)));
        }
        private static function listCompare(_arg1:IList, _arg2:IList, _arg3:int, _arg4:int, _arg5:Dictionary):int{
            var _local7:int;
            var _local6:int;
            if (_arg1.length != _arg2.length){
                if (_arg1.length < _arg2.length){
                    _local6 = -1;
                } else {
                    _local6 = 1;
                };
            } else {
                _local7 = 0;
                while (_local7 < _arg1.length) {
                    _local6 = internalCompare(_arg1.getItemAt(_local7), _arg2.getItemAt(_local7), (_arg3 + 1), _arg4, _arg5);
                    if (_local6 != 0){
                        _local7 = _arg1.length;
                    };
                    _local7++;
                };
            };
            return (_local6);
        }
        private static function internalCompare(_arg1:Object, _arg2:Object, _arg3:int, _arg4:int, _arg5:Dictionary):int{
            var newDepth:* = 0;
            var aRef:* = null;
            var bRef:* = null;
            var aProps:* = null;
            var bProps:* = null;
            var isDynamicObject:* = false;
            var propName:* = null;
            var aProp:* = null;
            var bProp:* = null;
            var i:* = 0;
            var a:* = _arg1;
            var b:* = _arg2;
            var currentDepth:* = _arg3;
            var desiredDepth:* = _arg4;
            var refs:* = _arg5;
            if ((((a == null)) && ((b == null)))){
                return (0);
            };
            if (a == null){
                return (1);
            };
            if (b == null){
                return (-1);
            };
            if ((a is ObjectProxy)){
                a = ObjectProxy(a).object_proxy::object;
            };
            if ((b is ObjectProxy)){
                b = ObjectProxy(b).object_proxy::object;
            };
            var typeOfA:* = typeof(a);
            var typeOfB:* = typeof(b);
            var result:* = 0;
            if (typeOfA == typeOfB){
                switch (typeOfA){
                    case "boolean":
                        result = numericCompare(Number(a), Number(b));
                        break;
                    case "number":
                        result = numericCompare((a as Number), (b as Number));
                        break;
                    case "string":
                        result = stringCompare((a as String), (b as String));
                        break;
                    case "object":
                        newDepth = (((desiredDepth > 0)) ? (desiredDepth - 1) : desiredDepth);
                        aRef = getRef(a, refs);
                        bRef = getRef(b, refs);
                        if (aRef == bRef){
                            return (0);
                        };
                        refs[bRef] = aRef;
                        if (((!((desiredDepth == -1))) && ((currentDepth > desiredDepth)))){
                            result = stringCompare(a.toString(), b.toString());
                        } else {
                            if ((((a is Array)) && ((b is Array)))){
                                result = arrayCompare((a as Array), (b as Array), currentDepth, desiredDepth, refs);
                            } else {
                                if ((((a is Date)) && ((b is Date)))){
                                    result = dateCompare((a as Date), (b as Date));
                                } else {
                                    if ((((a is IList)) && ((b is IList)))){
                                        result = listCompare((a as IList), (b as IList), currentDepth, desiredDepth, refs);
                                    } else {
                                        if ((((a is ByteArray)) && ((b is ByteArray)))){
                                            result = byteArrayCompare((a as ByteArray), (b as ByteArray));
                                        } else {
                                            if (getQualifiedClassName(a) == getQualifiedClassName(b)){
                                                aProps = getClassInfo(a).properties;
                                                isDynamicObject = true;
                                                try {
                                                    a["wootHackwoot"];
                                                } catch(e:Error) {
                                                    isDynamicObject = false;
                                                };
                                                if (isDynamicObject){
                                                    bProps = getClassInfo(b).properties;
                                                    result = arrayCompare(aProps, bProps, currentDepth, newDepth, refs);
                                                    if (result != 0){
                                                        return (result);
                                                    };
                                                };
                                                i = 0;
                                                while (i < aProps.length) {
                                                    propName = aProps[i];
                                                    aProp = a[propName];
                                                    bProp = b[propName];
                                                    result = internalCompare(aProp, bProp, (currentDepth + 1), newDepth, refs);
                                                    if (result != 0){
                                                        return (result);
                                                    };
                                                    i = (i + 1);
                                                };
                                            } else {
                                                return (1);
                                            };
                                        };
                                    };
                                };
                            };
                        };
                        break;
                };
            } else {
                return (stringCompare(typeOfA, typeOfB));
            };
            return (result);
        }
        public static function hasMetadata(_arg1:Object, _arg2:String, _arg3:String, _arg4:Array=null, _arg5:Object=null):Boolean{
            var _local6:Object = getClassInfo(_arg1, _arg4, _arg5);
            var _local7:Object = _local6["metadata"];
            return (internalHasMetadata(_local7, _arg2, _arg3));
        }
        private static function internalHasMetadata(_arg1:Object, _arg2:String, _arg3:String):Boolean{
            var _local4:Object;
            if (_arg1 != null){
                _local4 = _arg1[_arg2];
                if (_local4 != null){
                    if (_local4[_arg3] != null){
                        return (true);
                    };
                };
            };
            return (false);
        }
        public static function toString(_arg1:Object, _arg2:Array=null, _arg3:Array=null):String{
            if (_arg3 == null){
                _arg3 = defaultToStringExcludes;
            };
            refCount = 0;
            return (internalToString(_arg1, 0, null, _arg2, _arg3));
        }
        private static function byteArrayCompare(_arg1:ByteArray, _arg2:ByteArray):int{
            var _local4:int;
            var _local3:int;
            if (_arg1 == _arg2){
                return (_local3);
            };
            if (_arg1.length != _arg2.length){
                if (_arg1.length < _arg2.length){
                    _local3 = -1;
                } else {
                    _local3 = 1;
                };
            } else {
                _local4 = 0;
                while (_local4 < _arg1.length) {
                    _local3 = numericCompare(_arg1[_local4], _arg2[_local4]);
                    if (_local3 != 0){
                        _local4 = _arg1.length;
                    };
                    _local4++;
                };
            };
            return (_local3);
        }
        public static function copy(_arg1:Object):Object{
            var _local2:ByteArray = new ByteArray();
            _local2.writeObject(_arg1);
            _local2.position = 0;
            var _local3:Object = _local2.readObject();
            return (_local3);
        }
        private static function getCacheKey(_arg1:Object, _arg2:Array=null, _arg3:Object=null):String{
            var _local5:uint;
            var _local6:String;
            var _local7:String;
            var _local8:String;
            var _local4:String = getQualifiedClassName(_arg1);
            if (_arg2 != null){
                _local5 = 0;
                while (_local5 < _arg2.length) {
                    _local6 = (_arg2[_local5] as String);
                    if (_local6 != null){
                        _local4 = (_local4 + _local6);
                    };
                    _local5++;
                };
            };
            if (_arg3 != null){
                for (_local7 in _arg3) {
                    _local4 = (_local4 + _local7);
                    _local8 = (_arg3[_local7] as String);
                    if (_local8 != null){
                        _local4 = (_local4 + _local8);
                    };
                };
            };
            return (_local4);
        }

    }
}//package mx.utils 
﻿package mx.utils {
    import mx.messaging.config.*;

    public class URLUtil {

        public static const SERVER_NAME_TOKEN:String = "{server.name}";
        private static const SERVER_PORT_REGEX:RegExp = new RegExp("\\{server.port\\}", "g");
        private static const SERVER_NAME_REGEX:RegExp = new RegExp("\\{server.name\\}", "g");
        public static const SERVER_PORT_TOKEN:String = "{server.port}";

        public static function hasUnresolvableTokens():Boolean{
            return (!((LoaderConfig.url == null)));
        }
        public static function getServerName(_arg1:String):String{
            var _local2:String = getServerNameWithPort(_arg1);
            var _local3:int = _local2.indexOf("]");
            _local3 = ((_local3)>-1) ? _local2.indexOf(":", _local3) : _local2.indexOf(":");
            if (_local3 > 0){
                _local2 = _local2.substring(0, _local3);
            };
            return (_local2);
        }
        public static function isHttpsURL(_arg1:String):Boolean{
            return (((!((_arg1 == null))) && ((_arg1.indexOf("https://") == 0))));
        }
        private static function internalObjectToString(_arg1:Object, _arg2:String, _arg3:String, _arg4:Boolean):String{
            var _local7:String;
            var _local8:Object;
            var _local9:String;
            var _local5 = "";
            var _local6:Boolean;
            for (_local7 in _arg1) {
                if (_local6){
                    _local6 = false;
                } else {
                    _local5 = (_local5 + _arg2);
                };
                _local8 = _arg1[_local7];
                _local9 = ((_arg3) ? ((_arg3 + ".") + _local7) : _local7);
                if (_arg4){
                    _local9 = encodeURIComponent(_local9);
                };
                if ((_local8 is String)){
                    _local5 = (_local5 + ((_local9 + "=") + ((_arg4) ? encodeURIComponent((_local8 as String)) : _local8)));
                } else {
                    if ((_local8 is Number)){
                        _local8 = _local8.toString();
                        if (_arg4){
                            _local8 = encodeURIComponent((_local8 as String));
                        };
                        _local5 = (_local5 + ((_local9 + "=") + _local8));
                    } else {
                        if ((_local8 is Boolean)){
                            _local5 = (_local5 + ((_local9 + "=") + ((_local8) ? "true" : "false")));
                        } else {
                            if ((_local8 is Array)){
                                _local5 = (_local5 + internalArrayToString((_local8 as Array), _arg2, _local9, _arg4));
                            } else {
                                _local5 = (_local5 + internalObjectToString(_local8, _arg2, _local9, _arg4));
                            };
                        };
                    };
                };
            };
            return (_local5);
        }
        public static function getFullURL(_arg1:String, _arg2:String):String{
            var _local3:Number;
            if (((!((_arg2 == null))) && (!(URLUtil.isHttpURL(_arg2))))){
                if (_arg2.indexOf("./") == 0){
                    _arg2 = _arg2.substring(2);
                };
                if (URLUtil.isHttpURL(_arg1)){
                    if (_arg2.charAt(0) == "/"){
                        _local3 = _arg1.indexOf("/", 8);
                        if (_local3 == -1){
                            _local3 = _arg1.length;
                        };
                    } else {
                        _local3 = (_arg1.lastIndexOf("/") + 1);
                        if (_local3 <= 8){
                            _arg1 = (_arg1 + "/");
                            _local3 = _arg1.length;
                        };
                    };
                    if (_local3 > 0){
                        _arg2 = (_arg1.substring(0, _local3) + _arg2);
                    };
                };
            };
            return (_arg2);
        }
        public static function getServerNameWithPort(_arg1:String):String{
            var _local2:int = (_arg1.indexOf("/") + 2);
            var _local3:int = _arg1.indexOf("/", _local2);
            return ((((_local3 == -1)) ? _arg1.substring(_local2) : _arg1.substring(_local2, _local3)));
        }
        public static function replaceProtocol(_arg1:String, _arg2:String):String{
            return (_arg1.replace(getProtocol(_arg1), _arg2));
        }
        public static function urisEqual(_arg1:String, _arg2:String):Boolean{
            if (((!((_arg1 == null))) && (!((_arg2 == null))))){
                _arg1 = StringUtil.trim(_arg1).toLowerCase();
                _arg2 = StringUtil.trim(_arg2).toLowerCase();
                if (_arg1.charAt((_arg1.length - 1)) != "/"){
                    _arg1 = (_arg1 + "/");
                };
                if (_arg2.charAt((_arg2.length - 1)) != "/"){
                    _arg2 = (_arg2 + "/");
                };
            };
            return ((_arg1 == _arg2));
        }
        public static function getProtocol(_arg1:String):String{
            var _local2:int = _arg1.indexOf("/");
            var _local3:int = _arg1.indexOf(":/");
            if ((((_local3 > -1)) && ((_local3 < _local2)))){
                return (_arg1.substring(0, _local3));
            };
            _local3 = _arg1.indexOf("::");
            if ((((_local3 > -1)) && ((_local3 < _local2)))){
                return (_arg1.substring(0, _local3));
            };
            return ("");
        }
        private static function internalArrayToString(_arg1:Array, _arg2:String, _arg3:String, _arg4:Boolean):String{
            var _local9:Object;
            var _local10:String;
            var _local5 = "";
            var _local6:Boolean;
            var _local7:int = _arg1.length;
            var _local8:int;
            while (_local8 < _local7) {
                if (_local6){
                    _local6 = false;
                } else {
                    _local5 = (_local5 + _arg2);
                };
                _local9 = _arg1[_local8];
                _local10 = ((_arg3 + ".") + _local8);
                if (_arg4){
                    _local10 = encodeURIComponent(_local10);
                };
                if ((_local9 is String)){
                    _local5 = (_local5 + ((_local10 + "=") + ((_arg4) ? encodeURIComponent((_local9 as String)) : _local9)));
                } else {
                    if ((_local9 is Number)){
                        _local9 = _local9.toString();
                        if (_arg4){
                            _local9 = encodeURIComponent((_local9 as String));
                        };
                        _local5 = (_local5 + ((_local10 + "=") + _local9));
                    } else {
                        if ((_local9 is Boolean)){
                            _local5 = (_local5 + ((_local10 + "=") + ((_local9) ? "true" : "false")));
                        } else {
                            if ((_local9 is Array)){
                                _local5 = (_local5 + internalArrayToString((_local9 as Array), _arg2, _local10, _arg4));
                            } else {
                                _local5 = (_local5 + internalObjectToString(_local9, _arg2, _local10, _arg4));
                            };
                        };
                    };
                };
                _local8++;
            };
            return (_local5);
        }
        public static function objectToString(_arg1:Object, _arg2:String=";", _arg3:Boolean=true):String{
            var _local4:String = internalObjectToString(_arg1, _arg2, null, _arg3);
            return (_local4);
        }
        public static function replaceTokens(_arg1:String):String{
            var _local4:String;
            var _local5:String;
            var _local6:uint;
            var _local2:String = (((LoaderConfig.url == null)) ? "" : LoaderConfig.url);
            if (_arg1.indexOf(SERVER_NAME_TOKEN) > 0){
                _local4 = URLUtil.getProtocol(_local2);
                _local5 = "localhost";
                if (_local4.toLowerCase() != "file"){
                    _local5 = URLUtil.getServerName(_local2);
                };
                _arg1 = _arg1.replace(SERVER_NAME_REGEX, _local5);
            };
            var _local3:int = _arg1.indexOf(SERVER_PORT_TOKEN);
            if (_local3 > 0){
                _local6 = URLUtil.getPort(_local2);
                if (_local6 > 0){
                    _arg1 = _arg1.replace(SERVER_PORT_REGEX, _local6);
                } else {
                    if (_arg1.charAt((_local3 - 1)) == ":"){
                        _arg1 = (_arg1.substring(0, (_local3 - 1)) + _arg1.substring(_local3));
                    };
                    _arg1 = _arg1.replace(SERVER_PORT_REGEX, "");
                };
            };
            return (_arg1);
        }
        public static function getPort(_arg1:String):uint{
            var _local5:Number;
            var _local2:String = getServerNameWithPort(_arg1);
            var _local3:int = _local2.indexOf("]");
            _local3 = ((_local3)>-1) ? _local2.indexOf(":", _local3) : _local2.indexOf(":");
            var _local4:uint;
            if (_local3 > 0){
                _local5 = Number(_local2.substring((_local3 + 1)));
                if (!isNaN(_local5)){
                    _local4 = int(_local5);
                };
            };
            return (_local4);
        }
        public static function stringToObject(_arg1:String, _arg2:String=";", _arg3:Boolean=true):Object{
            var _local8:Array;
            var _local9:String;
            var _local10:Object;
            var _local11:Object;
            var _local12:int;
            var _local13:int;
            var _local14:Object;
            var _local15:String;
            var _local16:String;
            var _local17:Object;
            var _local4:Object = {};
            var _local5:Array = _arg1.split(_arg2);
            var _local6:int = _local5.length;
            var _local7:int;
            while (_local7 < _local6) {
                _local8 = _local5[_local7].split("=");
                _local9 = _local8[0];
                if (_arg3){
                    _local9 = decodeURIComponent(_local9);
                };
                _local10 = _local8[1];
                if (_arg3){
                    _local10 = decodeURIComponent((_local10 as String));
                };
                if (_local10 == "true"){
                    _local10 = true;
                } else {
                    if (_local10 == "false"){
                        _local10 = false;
                    } else {
                        _local14 = int(_local10);
                        if (_local14.toString() == _local10){
                            _local10 = _local14;
                        } else {
                            _local14 = Number(_local10);
                            if (_local14.toString() == _local10){
                                _local10 = _local14;
                            };
                        };
                    };
                };
                _local11 = _local4;
                _local8 = _local9.split(".");
                _local12 = _local8.length;
                _local13 = 0;
                while (_local13 < (_local12 - 1)) {
                    _local15 = _local8[_local13];
                    if ((((_local11[_local15] == null)) && ((_local13 < (_local12 - 1))))){
                        _local16 = _local8[(_local13 + 1)];
                        _local17 = int(_local16);
                        if (_local17.toString() == _local16){
                            _local11[_local15] = [];
                        } else {
                            _local11[_local15] = {};
                        };
                    };
                    _local11 = _local11[_local15];
                    _local13++;
                };
                _local11[_local8[_local13]] = _local10;
                _local7++;
            };
            return (_local4);
        }
        public static function replacePort(_arg1:String, _arg2:uint):String{
            var _local6:int;
            var _local3 = "";
            var _local4:int = _arg1.indexOf("]");
            if (_local4 == -1){
                _local4 = _arg1.indexOf(":");
            };
            var _local5:int = _arg1.indexOf(":", (_local4 + 1));
            if (_local5 > -1){
                _local5++;
                _local6 = _arg1.indexOf("/", _local5);
                _local3 = ((_arg1.substring(0, _local5) + _arg2.toString()) + _arg1.substring(_local6, _arg1.length));
            } else {
                _local6 = _arg1.indexOf("/", _local4);
                if (_local6 > -1){
                    if (_arg1.charAt((_local6 + 1)) == "/"){
                        _local6 = _arg1.indexOf("/", (_local6 + 2));
                    };
                    if (_local6 > 0){
                        _local3 = (((_arg1.substring(0, _local6) + ":") + _arg2.toString()) + _arg1.substring(_local6, _arg1.length));
                    } else {
                        _local3 = ((_arg1 + ":") + _arg2.toString());
                    };
                } else {
                    _local3 = ((_arg1 + ":") + _arg2.toString());
                };
            };
            return (_local3);
        }
        public static function isHttpURL(_arg1:String):Boolean{
            return (((!((_arg1 == null))) && ((((_arg1.indexOf("http://") == 0)) || ((_arg1.indexOf("https://") == 0))))));
        }

    }
}//package mx.utils 
﻿package mx.utils {
    import flash.utils.*;
    import mx.core.*;
    import mx.binding.*;

    public class DescribeTypeCache {

        mx_internal static const VERSION:String = "3.5.0.12683";

        private static var cacheHandlers:Object = {};
        private static var typeCache:Object = {};

        public static function describeType(_arg1):DescribeTypeCacheRecord{
            var _local2:String;
            var _local3:XML;
            var _local4:DescribeTypeCacheRecord;
            if ((_arg1 is String)){
                _local2 = _arg1;
            } else {
                _local2 = getQualifiedClassName(_arg1);
            };
            if ((_local2 in typeCache)){
                return (typeCache[_local2]);
            };
            if ((_arg1 is String)){
                _arg1 = getDefinitionByName(_arg1);
            };
            _local3 = describeType(_arg1);
            _local4 = new DescribeTypeCacheRecord();
            _local4.typeDescription = _local3;
            _local4.typeName = _local2;
            typeCache[_local2] = _local4;
            return (_local4);
        }
        public static function registerCacheHandler(_arg1:String, _arg2:Function):void{
            cacheHandlers[_arg1] = _arg2;
        }
        static function extractValue(_arg1:String, _arg2:DescribeTypeCacheRecord){
            if ((_arg1 in cacheHandlers)){
                return (cacheHandlers[_arg1](_arg2));
            };
            return (undefined);
        }
        private static function bindabilityInfoHandler(_arg1:DescribeTypeCacheRecord){
            return (new BindabilityInfo(_arg1.typeDescription));
        }

        registerCacheHandler("bindabilityInfo", bindabilityInfoHandler);
    }
}//package mx.utils 
﻿package mx.utils {
    import flash.events.*;
    import mx.events.*;
    import flash.utils.*;
    import mx.core.*;

    public dynamic class ObjectProxy extends Proxy implements IExternalizable, IPropertyChangeNotifier {

        private var _id:String;
        protected var notifiers:Object;
        protected var propertyList:Array;
        private var _proxyLevel:int;
        private var _type:QName;
        protected var dispatcher:EventDispatcher;
        protected var proxyClass:Class;
        private var _item:Object;

        public function ObjectProxy(_arg1:Object=null, _arg2:String=null, _arg3:int=-1){
            proxyClass = ObjectProxy;
            super();
            if (!_arg1){
                _arg1 = {};
            };
            _item = _arg1;
            _proxyLevel = _arg3;
            notifiers = {};
            dispatcher = new EventDispatcher(this);
            if (_arg2){
                _id = _arg2;
            };
        }
        public function dispatchEvent(_arg1:Event):Boolean{
            return (dispatcher.dispatchEvent(_arg1));
        }
        public function hasEventListener(_arg1:String):Boolean{
            return (dispatcher.hasEventListener(_arg1));
        }
        override "http://www.adobe.com/2006/actionscript/flash/proxy"?? function setProperty(_arg1, _arg2):void{
            var _local4:IPropertyChangeNotifier;
            var _local5:PropertyChangeEvent;
            var _local3:* = _item[_arg1];
            if (_local3 !== _arg2){
                _item[_arg1] = _arg2;
                _local4 = IPropertyChangeNotifier(notifiers[_arg1]);
                if (_local4){
                    _local4.removeEventListener(PropertyChangeEvent.PROPERTY_CHANGE, propertyChangeHandler);
                    delete notifiers[_arg1];
                };
                if (dispatcher.hasEventListener(PropertyChangeEvent.PROPERTY_CHANGE)){
                    if ((_arg1 is QName)){
                        _arg1 = QName(_arg1).localName;
                    };
                    _local5 = PropertyChangeEvent.createUpdateEvent(this, _arg1.toString(), _local3, _arg2);
                    dispatcher.dispatchEvent(_local5);
                };
            };
        }
        public function willTrigger(_arg1:String):Boolean{
            return (dispatcher.willTrigger(_arg1));
        }
        public function readExternal(_arg1:IDataInput):void{
            var _local2:Object = _arg1.readObject();
            _item = _local2;
        }
        public function writeExternal(_arg1:IDataOutput):void{
            _arg1.writeObject(_item);
        }
        override "http://www.adobe.com/2006/actionscript/flash/proxy"?? function getProperty(_arg1){
            var _local2:*;
            if (notifiers[_arg1.toString()]){
                return (notifiers[_arg1]);
            };
            _local2 = _item[_arg1];
            if (_local2){
                if ((((_proxyLevel == 0)) || (ObjectUtil.isSimple(_local2)))){
                    return (_local2);
                };
                _local2 = getComplexProperty(_arg1, _local2);
            };
            return (_local2);
        }
        override "http://www.adobe.com/2006/actionscript/flash/proxy"?? function hasProperty(_arg1):Boolean{
            return ((_arg1 in _item));
        }
        public function get uid():String{
            if (_id === null){
                _id = UIDUtil.createUID();
            };
            return (_id);
        }
        override "http://www.adobe.com/2006/actionscript/flash/proxy"?? function nextNameIndex(_arg1:int):int{
            if (_arg1 == 0){
                setupPropertyList();
            };
            if (_arg1 < propertyList.length){
                return ((_arg1 + 1));
            };
            return (0);
        }
        public function addEventListener(_arg1:String, _arg2:Function, _arg3:Boolean=false, _arg4:int=0, _arg5:Boolean=false):void{
            dispatcher.addEventListener(_arg1, _arg2, _arg3, _arg4, _arg5);
        }
        override "http://www.adobe.com/2006/actionscript/flash/proxy"?? function nextName(_arg1:int):String{
            return (propertyList[(_arg1 - 1)]);
        }
        public function set uid(_arg1:String):void{
            _id = _arg1;
        }
        override "http://www.adobe.com/2006/actionscript/flash/proxy"?? function callProperty(_arg1, ... _args){
            return (_item[_arg1].apply(_item, _args));
        }
        public function removeEventListener(_arg1:String, _arg2:Function, _arg3:Boolean=false):void{
            dispatcher.removeEventListener(_arg1, _arg2, _arg3);
        }
        protected function setupPropertyList():void{
            var _local1:String;
            if (getQualifiedClassName(_item) == "Object"){
                propertyList = [];
                for (_local1 in _item) {
                    propertyList.push(_local1);
                };
            } else {
                propertyList = ObjectUtil.getClassInfo(_item, null, {
                    includeReadOnly:true,
                    uris:["*"]
                }).properties;
            };
        }
        object_proxy function getComplexProperty(_arg1, _arg2){
            if ((_arg2 is IPropertyChangeNotifier)){
                _arg2.addEventListener(PropertyChangeEvent.PROPERTY_CHANGE, propertyChangeHandler);
                notifiers[_arg1] = _arg2;
                return (_arg2);
            };
            if (getQualifiedClassName(_arg2) == "Object"){
                _arg2 = new proxyClass(_item[_arg1], null, (((_proxyLevel > 0)) ? (_proxyLevel - 1) : _proxyLevel));
                _arg2.addEventListener(PropertyChangeEvent.PROPERTY_CHANGE, propertyChangeHandler);
                notifiers[_arg1] = _arg2;
                return (_arg2);
            };
            return (_arg2);
        }
        override "http://www.adobe.com/2006/actionscript/flash/proxy"?? function deleteProperty(_arg1):Boolean{
            var _local5:PropertyChangeEvent;
            var _local2:IPropertyChangeNotifier = IPropertyChangeNotifier(notifiers[_arg1]);
            if (_local2){
                _local2.removeEventListener(PropertyChangeEvent.PROPERTY_CHANGE, propertyChangeHandler);
                delete notifiers[_arg1];
            };
            var _local3:* = _item[_arg1];
            var _local4 = delete _item[_arg1];
            if (dispatcher.hasEventListener(PropertyChangeEvent.PROPERTY_CHANGE)){
                _local5 = new PropertyChangeEvent(PropertyChangeEvent.PROPERTY_CHANGE);
                _local5.kind = PropertyChangeEventKind.DELETE;
                _local5.property = _arg1;
                _local5.oldValue = _local3;
                _local5.source = this;
                dispatcher.dispatchEvent(_local5);
            };
            return (_local4);
        }
        object_proxy function get type():QName{
            return (_type);
        }
        object_proxy function set type(_arg1:QName):void{
            _type = _arg1;
        }
        public function propertyChangeHandler(_arg1:PropertyChangeEvent):void{
            dispatcher.dispatchEvent(_arg1);
        }
        override "http://www.adobe.com/2006/actionscript/flash/proxy"?? function nextValue(_arg1:int){
            return (_item[propertyList[(_arg1 - 1)]]);
        }
        object_proxy function get object():Object{
            return (_item);
        }

    }
}//package mx.utils 
﻿package mx.utils {

    public namespace object_proxy = "http://www.adobe.com/2006/actionscript/flash/objectproxy";
}//package mx.utils 
﻿package mx.utils {
    import flash.utils.*;
    import mx.core.*;

    public class XMLNotifier {

        mx_internal static const VERSION:String = "3.5.0.12683";

        private static var instance:XMLNotifier;

        public function XMLNotifier(_arg1:XMLNotifierSingleton){
        }
        public static function getInstance():XMLNotifier{
            if (!instance){
                instance = new XMLNotifier(new XMLNotifierSingleton());
            };
            return (instance);
        }
        mx_internal static function initializeXMLForNotification():Function{
            var notificationFunction:* = function (_arg1:Object, _arg2:String, _arg3:Object, _arg4:Object, _arg5:Object):void{
                var _local8:Object;
                var _local7:Dictionary = arguments.callee.watched;
                if (_local7 != null){
                    for (_local8 in _local7) {
                        IXMLNotifiable(_local8).xmlNotification(_arg1, _arg2, _arg3, _arg4, _arg5);
                    };
                };
            };
            return (notificationFunction);
        }

        public function watchXML(_arg1:Object, _arg2:IXMLNotifiable, _arg3:String=null):void{
            var _local6:Dictionary;
            var _local4:XML = XML(_arg1);
            var _local5:Object = _local4.notification();
            if (!(_local5 is Function)){
                _local5 = initializeXMLForNotification();
                _local4.setNotification((_local5 as Function));
                if (((_arg3) && ((_local5["uid"] == null)))){
                    _local5["uid"] = _arg3;
                };
            };
            if (_local5["watched"] == undefined){
                _local6 = new Dictionary(true);
                _local5["watched"] = _local6;
            } else {
                _local6 = _local5["watched"];
            };
            _local6[_arg2] = true;
        }
        public function unwatchXML(_arg1:Object, _arg2:IXMLNotifiable):void{
            var _local5:Dictionary;
            var _local3:XML = XML(_arg1);
            var _local4:Object = _local3.notification();
            if (!(_local4 is Function)){
                return;
            };
            if (_local4["watched"] != undefined){
                _local5 = _local4["watched"];
                delete _local5[_arg2];
            };
        }

    }
}//package mx.utils 

class XMLNotifierSingleton {

    public function XMLNotifierSingleton(){
    }
}
﻿package mx.utils {
    import mx.core.*;

    public class StringUtil {

        mx_internal static const VERSION:String = "3.5.0.12683";

        public static function trim(_arg1:String):String{
            if (_arg1 == null){
                return ("");
            };
            var _local2:int;
            while (isWhitespace(_arg1.charAt(_local2))) {
                _local2++;
            };
            var _local3:int = (_arg1.length - 1);
            while (isWhitespace(_arg1.charAt(_local3))) {
                _local3--;
            };
            if (_local3 >= _local2){
                return (_arg1.slice(_local2, (_local3 + 1)));
            };
            return ("");
        }
        public static function isWhitespace(_arg1:String):Boolean{
            switch (_arg1){
                case " ":
                case "\t":
                case "\r":
                case "\n":
                case "\f":
                    return (true);
                default:
                    return (false);
            };
        }
        public static function substitute(_arg1:String, ... _args):String{
            var _local4:Array;
            if (_arg1 == null){
                return ("");
            };
            var _local3:uint = _args.length;
            if ((((_local3 == 1)) && ((_args[0] is Array)))){
                _local4 = (_args[0] as Array);
                _local3 = _local4.length;
            } else {
                _local4 = _args;
            };
            var _local5:int;
            while (_local5 < _local3) {
                _arg1 = _arg1.replace(new RegExp((("\\{" + _local5) + "\\}"), "g"), _local4[_local5]);
                _local5++;
            };
            return (_arg1);
        }
        public static function trimArrayElements(_arg1:String, _arg2:String):String{
            var _local3:Array;
            var _local4:int;
            var _local5:int;
            if (((!((_arg1 == ""))) && (!((_arg1 == null))))){
                _local3 = _arg1.split(_arg2);
                _local4 = _local3.length;
                _local5 = 0;
                while (_local5 < _local4) {
                    _local3[_local5] = StringUtil.trim(_local3[_local5]);
                    _local5++;
                };
                if (_local4 > 0){
                    _arg1 = _local3.join(_arg2);
                };
            };
            return (_arg1);
        }

    }
}//package mx.utils 
﻿package mx.utils {
    import mx.core.*;

    public class RPCStringUtil {

        mx_internal static const VERSION:String = "3.5.0.12683";

        public static function trim(_arg1:String):String{
            if (_arg1 == null){
                return ("");
            };
            var _local2:int;
            while (isWhitespace(_arg1.charAt(_local2))) {
                _local2++;
            };
            var _local3:int = (_arg1.length - 1);
            while (isWhitespace(_arg1.charAt(_local3))) {
                _local3--;
            };
            if (_local3 >= _local2){
                return (_arg1.slice(_local2, (_local3 + 1)));
            };
            return ("");
        }
        public static function isWhitespace(_arg1:String):Boolean{
            switch (_arg1){
                case " ":
                case "\t":
                case "\r":
                case "\n":
                case "\f":
                    return (true);
                default:
                    return (false);
            };
        }
        public static function substitute(_arg1:String, ... _args):String{
            var _local4:Array;
            if (_arg1 == null){
                return ("");
            };
            var _local3:uint = _args.length;
            if ((((_local3 == 1)) && ((_args[0] is Array)))){
                _local4 = (_args[0] as Array);
                _local3 = _local4.length;
            } else {
                _local4 = _args;
            };
            var _local5:int;
            while (_local5 < _local3) {
                _arg1 = _arg1.replace(new RegExp((("\\{" + _local5) + "\\}"), "g"), _local4[_local5]);
                _local5++;
            };
            return (_arg1);
        }
        public static function trimArrayElements(_arg1:String, _arg2:String):String{
            var _local3:Array;
            var _local4:int;
            var _local5:int;
            if (((!((_arg1 == ""))) && (!((_arg1 == null))))){
                _local3 = _arg1.split(_arg2);
                _local4 = _local3.length;
                _local5 = 0;
                while (_local5 < _local4) {
                    _local3[_local5] = trim(_local3[_local5]);
                    _local5++;
                };
                if (_local4 > 0){
                    _arg1 = _local3.join(_arg2);
                };
            };
            return (_arg1);
        }

    }
}//package mx.utils 
﻿package mx.utils {
    import mx.core.*;

    public class ArrayUtil {

        mx_internal static const VERSION:String = "3.5.0.12683";

        public static function getItemIndex(_arg1:Object, _arg2:Array):int{
            var _local3:int = _arg2.length;
            var _local4:int;
            while (_local4 < _local3) {
                if (_arg2[_local4] === _arg1){
                    return (_local4);
                };
                _local4++;
            };
            return (-1);
        }
        public static function toArray(_arg1:Object):Array{
            if (!_arg1){
                return ([]);
            };
            if ((_arg1 is Array)){
                return ((_arg1 as Array));
            };
            return ([_arg1]);
        }

    }
}//package mx.utils 
﻿package mx.utils {
    import flash.utils.*;
    import flash.xml.*;
    import mx.core.*;

    public class RPCObjectUtil {

        mx_internal static const VERSION:String = "3.5.0.12683";

        private static var defaultToStringExcludes:Array = ["password", "credentials"];
        private static var CLASS_INFO_CACHE:Object = {};
        private static var refCount:int = 0;

        private static function recordMetadata(_arg1:XMLList):Object{
            var prop:* = null;
            var propName:* = null;
            var metadataList:* = null;
            var metadata:* = null;
            var md:* = null;
            var mdName:* = null;
            var argsList:* = null;
            var value:* = null;
            var arg:* = null;
            var existing:* = null;
            var argKey:* = null;
            var argValue:* = null;
            var existingArray:* = null;
            var properties:* = _arg1;
            var result:* = null;
            try {
                for each (prop in properties) {
                    propName = prop.attribute("name").toString();
                    metadataList = prop.metadata;
                    if (metadataList.length() > 0){
                        if (result == null){
                            result = {};
                        };
                        metadata = {};
                        result[propName] = metadata;
                        for each (md in metadataList) {
                            mdName = md.attribute("name").toString();
                            argsList = md.arg;
                            value = {};
                            for each (arg in argsList) {
                                argKey = arg.attribute("key").toString();
                                if (argKey != null){
                                    argValue = arg.attribute("value").toString();
                                    value[argKey] = argValue;
                                };
                            };
                            existing = metadata[mdName];
                            if (existing != null){
                                if ((existing is Array)){
                                    existingArray = (existing as Array);
                                } else {
                                    existingArray = [];
                                };
                                existingArray.push(value);
                                existing = existingArray;
                            } else {
                                existing = value;
                            };
                            metadata[mdName] = existing;
                        };
                    };
                };
            } catch(e:Error) {
            };
            return (result);
        }
        public static function toString(_arg1:Object, _arg2:Array=null, _arg3:Array=null):String{
            if (_arg3 == null){
                _arg3 = defaultToStringExcludes;
            };
            refCount = 0;
            return (internalToString(_arg1, 0, null, _arg2, _arg3));
        }
        private static function internalToString(_arg1:Object, _arg2:int=0, _arg3:Dictionary=null, _arg4:Array=null, _arg5:Array=null):String{
            var str:* = null;
            var classInfo:* = null;
            var properties:* = null;
            var id:* = null;
            var isArray:* = false;
            var prop:* = undefined;
            var j:* = 0;
            var value:* = _arg1;
            var indent:int = _arg2;
            var refs = _arg3;
            var namespaceURIs = _arg4;
            var exclude = _arg5;
            var type:* = (((value == null)) ? "null" : typeof(value));
            switch (type){
                case "boolean":
                case "number":
                    return (value.toString());
                case "string":
                    return ((("\"" + value.toString()) + "\""));
                case "object":
                    if ((value is Date)){
                        return (value.toString());
                    };
                    if ((value is XMLNode)){
                        return (value.toString());
                    };
                    if ((value is Class)){
                        return ((("(" + getQualifiedClassName(value)) + ")"));
                    };
                    classInfo = getClassInfo(value, exclude, {
                        includeReadOnly:true,
                        uris:namespaceURIs
                    });
                    properties = classInfo.properties;
                    str = (("(" + classInfo.name) + ")");
                    if (refs == null){
                        refs = new Dictionary(true);
                    };
                    id = refs[value];
                    if (id != null){
                        str = (str + ("#" + int(id)));
                        return (str);
                    };
                    if (value != null){
                        str = (str + ("#" + refCount.toString()));
                        refs[value] = refCount;
                        refCount++;
                    };
                    isArray = (value is Array);
                    indent = (indent + 2);
                    j = 0;
                    while (j < properties.length) {
                        str = newline(str, indent);
                        prop = properties[j];
                        if (isArray){
                            str = (str + "[");
                        };
                        str = (str + prop.toString());
                        if (isArray){
                            str = (str + "] ");
                        } else {
                            str = (str + " = ");
                        };
                        try {
                            str = (str + internalToString(value[prop], indent, refs, namespaceURIs, exclude));
                        } catch(e:Error) {
                            str = (str + "?");
                        };
                        j = (j + 1);
                    };
                    indent = (indent - 2);
                    return (str);
                case "xml":
                    return (value.toString());
                default:
                    return ((("(" + type) + ")"));
            };
        }
        private static function getCacheKey(_arg1:Object, _arg2:Array=null, _arg3:Object=null):String{
            var _local5:uint;
            var _local6:String;
            var _local7:String;
            var _local8:String;
            var _local4:String = getQualifiedClassName(_arg1);
            if (_arg2 != null){
                _local5 = 0;
                while (_local5 < _arg2.length) {
                    _local6 = (_arg2[_local5] as String);
                    if (_local6 != null){
                        _local4 = (_local4 + _local6);
                    };
                    _local5++;
                };
            };
            if (_arg3 != null){
                for (_local7 in _arg3) {
                    _local4 = (_local4 + _local7);
                    _local8 = (_arg3[_local7] as String);
                    if (_local8 != null){
                        _local4 = (_local4 + _local8);
                    };
                };
            };
            return (_local4);
        }
        private static function newline(_arg1:String, _arg2:int=0):String{
            var _local3:String = _arg1;
            _local3 = (_local3 + "\n");
            var _local4:int;
            while (_local4 < _arg2) {
                _local3 = (_local3 + " ");
                _local4++;
            };
            return (_local3);
        }
        public static function getClassInfo(_arg1:Object, _arg2:Array=null, _arg3:Object=null):Object{
            var n:* = 0;
            var i:* = 0;
            var result:* = null;
            var cacheKey:* = null;
            var className:* = null;
            var classAlias:* = null;
            var properties:* = null;
            var prop:* = null;
            var metadataInfo:* = null;
            var classInfo:* = null;
            var numericIndex:* = false;
            var p:* = null;
            var pi:* = NaN;
            var uris:* = null;
            var uri:* = null;
            var qName:* = null;
            var j:* = 0;
            var obj:* = _arg1;
            var excludes = _arg2;
            var options = _arg3;
            if (options == null){
                options = {
                    includeReadOnly:true,
                    uris:null,
                    includeTransient:true
                };
            };
            var propertyNames:* = [];
            var dynamic:* = false;
            if (typeof(obj) == "xml"){
                className = "XML";
                properties = obj.text();
                if (properties.length()){
                    propertyNames.push("*");
                };
                properties = obj.attributes();
            } else {
                classInfo = describeType(obj);
                className = classInfo.@name.toString();
                classAlias = classInfo.@alias.toString();
                dynamic = (classInfo.@isDynamic.toString() == "true");
                if (options.includeReadOnly){
                    properties = (classInfo..accessor.(@access != "writeonly") + classInfo..variable);
                } else {
                    properties = (classInfo..accessor.(@access == "readwrite") + classInfo..variable);
                };
                numericIndex = false;
            };
            if (!dynamic){
                cacheKey = getCacheKey(obj, excludes, options);
                result = CLASS_INFO_CACHE[cacheKey];
                if (result != null){
                    return (result);
                };
            };
            result = {};
            result["name"] = className;
            result["alias"] = classAlias;
            result["properties"] = propertyNames;
            result["dynamic"] = dynamic;
            var _local5 = recordMetadata(properties);
            metadataInfo = _local5;
            result["metadata"] = _local5;
            var excludeObject:* = {};
            if (excludes){
                n = excludes.length;
                i = 0;
                while (i < n) {
                    excludeObject[excludes[i]] = 1;
                    i = (i + 1);
                };
            };
            var isArray:* = (className == "Array");
            if (dynamic){
                for (p in obj) {
                    if (excludeObject[p] != 1){
                        if (isArray){
                            pi = parseInt(p);
                            if (isNaN(pi)){
                                propertyNames.push(new QName("", p));
                            } else {
                                propertyNames.push(pi);
                            };
                        } else {
                            propertyNames.push(new QName("", p));
                        };
                    };
                };
                numericIndex = ((isArray) && (!(isNaN(Number(p)))));
            };
            if ((((className == "Object")) || (isArray))){
            } else {
                if (className == "XML"){
                    n = properties.length();
                    i = 0;
                    while (i < n) {
                        p = properties[i].name();
                        if (excludeObject[p] != 1){
                            propertyNames.push(new QName("", ("@" + p)));
                        };
                        i = (i + 1);
                    };
                } else {
                    n = properties.length();
                    uris = options.uris;
                    i = 0;
                    while (i < n) {
                        prop = properties[i];
                        p = prop.@name.toString();
                        uri = prop.@uri.toString();
                        if (excludeObject[p] == 1){
                        } else {
                            if (((!(options.includeTransient)) && (internalHasMetadata(metadataInfo, p, "Transient")))){
                            } else {
                                if (uris != null){
                                    if ((((uris.length == 1)) && ((uris[0] == "*")))){
                                        qName = new QName(uri, p);
                                        try {
                                            obj[qName];
                                            propertyNames.push();
                                        } catch(e:Error) {
                                        };
                                    } else {
                                        j = 0;
                                        while (j < uris.length) {
                                            uri = uris[j];
                                            if (prop.@uri.toString() == uri){
                                                qName = new QName(uri, p);
                                                try {
                                                    obj[qName];
                                                    propertyNames.push(qName);
                                                } catch(e:Error) {
                                                };
                                            };
                                            j = (j + 1);
                                        };
                                    };
                                } else {
                                    if (uri.length == 0){
                                        qName = new QName(uri, p);
                                        try {
                                            obj[qName];
                                            propertyNames.push(qName);
                                        } catch(e:Error) {
                                        };
                                    };
                                };
                            };
                        };
                        i = (i + 1);
                    };
                };
            };
            propertyNames.sort((Array.CASEINSENSITIVE | ((numericIndex) ? Array.NUMERIC : 0)));
            i = 0;
            while (i < (propertyNames.length - 1)) {
                if (propertyNames[i].toString() == propertyNames[(i + 1)].toString()){
                    propertyNames.splice(i, 1);
                    i = (i - 1);
                };
                i = (i + 1);
            };
            if (!dynamic){
                cacheKey = getCacheKey(obj, excludes, options);
                CLASS_INFO_CACHE[cacheKey] = result;
            };
            return (result);
        }
        private static function internalHasMetadata(_arg1:Object, _arg2:String, _arg3:String):Boolean{
            var _local4:Object;
            if (_arg1 != null){
                _local4 = _arg1[_arg2];
                if (_local4 != null){
                    if (_local4[_arg3] != null){
                        return (true);
                    };
                };
            };
            return (false);
        }

    }
}//package mx.utils 
﻿package mx.utils {
    import flash.utils.*;

    public dynamic class DescribeTypeCacheRecord extends Proxy {

        public var typeDescription:XML;
        public var typeName:String;
        private var cache:Object;

        public function DescribeTypeCacheRecord(){
            cache = {};
            super();
        }
        override "http://www.adobe.com/2006/actionscript/flash/proxy"?? function getProperty(_arg1){
            var _local2:* = cache[_arg1];
            if (_local2 === undefined){
                _local2 = DescribeTypeCache.extractValue(_arg1, this);
                cache[_arg1] = _local2;
            };
            return (_local2);
        }
        override "http://www.adobe.com/2006/actionscript/flash/proxy"?? function hasProperty(_arg1):Boolean{
            if ((_arg1 in cache)){
                return (true);
            };
            var _local2:* = DescribeTypeCache.extractValue(_arg1, this);
            if (_local2 === undefined){
                return (false);
            };
            cache[_arg1] = _local2;
            return (true);
        }

    }
}//package mx.utils 
﻿package mx.utils {
    import flash.utils.*;
    import mx.core.*;

    public class RPCUIDUtil {

        mx_internal static const VERSION:String = "3.5.0.12683";
        private static const ALPHA_CHAR_CODES:Array = [48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70];

        public static function createUID():String{
            var _local3:int;
            var _local4:int;
            var _local1:Array = new Array(36);
            var _local2:int;
            _local3 = 0;
            while (_local3 < 8) {
                var _temp1 = _local2;
                _local2 = (_local2 + 1);
                var _local7 = _temp1;
                _local1[_local7] = ALPHA_CHAR_CODES[Math.floor((Math.random() * 16))];
                _local3++;
            };
            _local3 = 0;
            while (_local3 < 3) {
                var _temp2 = _local2;
                _local2 = (_local2 + 1);
                _local7 = _temp2;
                _local1[_local7] = 45;
                _local4 = 0;
                while (_local4 < 4) {
                    var _temp3 = _local2;
                    _local2 = (_local2 + 1);
                    var _local8 = _temp3;
                    _local1[_local8] = ALPHA_CHAR_CODES[Math.floor((Math.random() * 16))];
                    _local4++;
                };
                _local3++;
            };
            var _temp4 = _local2;
            _local2 = (_local2 + 1);
            _local7 = _temp4;
            _local1[_local7] = 45;
            var _local5:Number = new Date().getTime();
            var _local6:String = ("0000000" + _local5.toString(16).toUpperCase()).substr(-8);
            _local3 = 0;
            while (_local3 < 8) {
                var _temp5 = _local2;
                _local2 = (_local2 + 1);
                _local8 = _temp5;
                _local1[_local8] = _local6.charCodeAt(_local3);
                _local3++;
            };
            _local3 = 0;
            while (_local3 < 4) {
                var _temp6 = _local2;
                _local2 = (_local2 + 1);
                _local8 = _temp6;
                _local1[_local8] = ALPHA_CHAR_CODES[Math.floor((Math.random() * 16))];
                _local3++;
            };
            return (String.fromCharCode.apply(null, _local1));
        }
        public static function isUID(_arg1:String):Boolean{
            var _local2:uint;
            var _local3:Number;
            if (((!((_arg1 == null))) && ((_arg1.length == 36)))){
                _local2 = 0;
                while (_local2 < 36) {
                    _local3 = _arg1.charCodeAt(_local2);
                    if ((((((((_local2 == 8)) || ((_local2 == 13)))) || ((_local2 == 18)))) || ((_local2 == 23)))){
                        if (_local3 != 45){
                            return (false);
                        };
                    } else {
                        if ((((((_local3 < 48)) || ((_local3 > 70)))) || ((((_local3 > 57)) && ((_local3 < 65)))))){
                            return (false);
                        };
                    };
                    _local2++;
                };
                return (true);
            };
            return (false);
        }
        public static function fromByteArray(_arg1:ByteArray):String{
            var _local2:Array;
            var _local3:uint;
            var _local4:uint;
            var _local5:int;
            if (((((!((_arg1 == null))) && ((_arg1.length >= 16)))) && ((_arg1.bytesAvailable >= 16)))){
                _local2 = new Array(36);
                _local3 = 0;
                _local4 = 0;
                while (_local4 < 16) {
                    if ((((((((_local4 == 4)) || ((_local4 == 6)))) || ((_local4 == 8)))) || ((_local4 == 10)))){
                        var _temp1 = _local3;
                        _local3 = (_local3 + 1);
                        var _local6 = _temp1;
                        _local2[_local6] = 45;
                    };
                    _local5 = _arg1.readByte();
                    var _temp2 = _local3;
                    _local3 = (_local3 + 1);
                    _local6 = _temp2;
                    _local2[_local6] = ALPHA_CHAR_CODES[((_local5 & 240) >>> 4)];
                    var _temp3 = _local3;
                    _local3 = (_local3 + 1);
                    var _local7 = _temp3;
                    _local2[_local7] = ALPHA_CHAR_CODES[(_local5 & 15)];
                    _local4++;
                };
                return (String.fromCharCode.apply(null, _local2));
            };
            return (null);
        }
        public static function toByteArray(_arg1:String):ByteArray{
            var _local2:ByteArray;
            var _local3:uint;
            var _local4:String;
            var _local5:uint;
            var _local6:uint;
            if (isUID(_arg1)){
                _local2 = new ByteArray();
                _local3 = 0;
                while (_local3 < _arg1.length) {
                    _local4 = _arg1.charAt(_local3);
                    if (_local4 == "-"){
                    } else {
                        _local5 = getDigit(_local4);
                        _local3++;
                        _local6 = getDigit(_arg1.charAt(_local3));
                        _local2.writeByte((((_local5 << 4) | _local6) & 0xFF));
                    };
                    _local3++;
                };
                _local2.position = 0;
                return (_local2);
            };
            return (null);
        }
        private static function getDigit(_arg1:String):uint{
            switch (_arg1){
                case "A":
                case "a":
                    return (10);
                case "B":
                case "b":
                    return (11);
                case "C":
                case "c":
                    return (12);
                case "D":
                case "d":
                    return (13);
                case "E":
                case "e":
                    return (14);
                case "F":
                case "f":
                    return (15);
                default:
                    return (new uint(_arg1));
            };
        }

    }
}//package mx.utils 
﻿package mx.utils {

    public interface IXMLNotifiable {

        function xmlNotification(_arg1:Object, _arg2:String, _arg3:Object, _arg4:Object, _arg5:Object):void;

    }
}//package mx.utils 
﻿package mx.utils {
    import flash.utils.*;

    public class Base64Encoder {

        public static const MAX_BUFFER_SIZE:uint = 32767;
        private static const ALPHABET_CHAR_CODES:Array = [65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47];
        public static const CHARSET_UTF_8:String = "UTF-8";
        private static const ESCAPE_CHAR_CODE:Number = 61;

        public static var newLine:int = 10;

        private var _line:uint;
        private var _count:uint;
        private var _buffers:Array;
        public var insertNewLines:Boolean = true;
        private var _work:Array;

        public function Base64Encoder(){
            _work = [0, 0, 0];
            super();
            reset();
        }
        public function flush():String{
            if (_count > 0){
                encodeBlock();
            };
            var _local1:String = drain();
            reset();
            return (_local1);
        }
        public function toString():String{
            return (flush());
        }
        public function reset():void{
            _buffers = [];
            _buffers.push([]);
            _count = 0;
            _line = 0;
            _work[0] = 0;
            _work[1] = 0;
            _work[2] = 0;
        }
        public function encodeBytes(_arg1:ByteArray, _arg2:uint=0, _arg3:uint=0):void{
            if (_arg3 == 0){
                _arg3 = _arg1.length;
            };
            var _local4:uint = _arg1.position;
            _arg1.position = _arg2;
            var _local5:uint = _arg2;
            var _local6:uint = (_arg2 + _arg3);
            if (_local6 > _arg1.length){
                _local6 = _arg1.length;
            };
            while (_local5 < _local6) {
                _work[_count] = _arg1[_local5];
                _count++;
                if ((((_count == _work.length)) || (((_local6 - _local5) == 1)))){
                    encodeBlock();
                    _count = 0;
                    _work[0] = 0;
                    _work[1] = 0;
                    _work[2] = 0;
                };
                _local5++;
            };
            _arg1.position = _local4;
        }
        public function encode(_arg1:String, _arg2:uint=0, _arg3:uint=0):void{
            if (_arg3 == 0){
                _arg3 = _arg1.length;
            };
            var _local4:uint = _arg2;
            var _local5:uint = (_arg2 + _arg3);
            if (_local5 > _arg1.length){
                _local5 = _arg1.length;
            };
            while (_local4 < _local5) {
                _work[_count] = _arg1.charCodeAt(_local4);
                _count++;
                if ((((_count == _work.length)) || (((_local5 - _local4) == 1)))){
                    encodeBlock();
                    _count = 0;
                    _work[0] = 0;
                    _work[1] = 0;
                    _work[2] = 0;
                };
                _local4++;
            };
        }
        private function encodeBlock():void{
            var _local1:Array = (_buffers[(_buffers.length - 1)] as Array);
            if (_local1.length >= MAX_BUFFER_SIZE){
                _local1 = [];
                _buffers.push(_local1);
            };
            _local1.push(ALPHABET_CHAR_CODES[((_work[0] & 0xFF) >> 2)]);
            _local1.push(ALPHABET_CHAR_CODES[(((_work[0] & 3) << 4) | ((_work[1] & 240) >> 4))]);
            if (_count > 1){
                _local1.push(ALPHABET_CHAR_CODES[(((_work[1] & 15) << 2) | ((_work[2] & 192) >> 6))]);
            } else {
                _local1.push(ESCAPE_CHAR_CODE);
            };
            if (_count > 2){
                _local1.push(ALPHABET_CHAR_CODES[(_work[2] & 63)]);
            } else {
                _local1.push(ESCAPE_CHAR_CODE);
            };
            if (insertNewLines){
                if ((_line = (_line + 4)) == 76){
                    _local1.push(newLine);
                    _line = 0;
                };
            };
        }
        public function encodeUTFBytes(_arg1:String):void{
            var _local2:ByteArray = new ByteArray();
            _local2.writeUTFBytes(_arg1);
            _local2.position = 0;
            encodeBytes(_local2);
        }
        public function drain():String{
            var _local3:Array;
            var _local1 = "";
            var _local2:uint;
            while (_local2 < _buffers.length) {
                _local3 = (_buffers[_local2] as Array);
                _local1 = (_local1 + String.fromCharCode.apply(null, _local3));
                _local2++;
            };
            _buffers = [];
            _buffers.push([]);
            return (_local1);
        }

    }
}//package mx.utils 
﻿package mx.messaging.channels {
    import flash.events.*;
    import mx.messaging.messages.*;
    import mx.messaging.events.*;
    import mx.messaging.*;
    import flash.net.*;
    import mx.logging.*;
    import mx.messaging.config.*;
    import mx.core.*;
    import mx.netmon.*;

    public class NetConnectionChannel extends PollingChannel {

        mx_internal var _appendToURL:String;
        protected var _nc:NetConnection;

        public function NetConnectionChannel(_arg1:String=null, _arg2:String=null){
            super(_arg1, _arg2);
            _nc = new NetConnection();
            _nc.objectEncoding = ObjectEncoding.AMF3;
            _nc.client = this;
        }
        public function AppendToGatewayUrl(_arg1:String):void{
            if (((((!((_arg1 == null))) && (!((_arg1 == ""))))) && (!((_arg1 == _appendToURL))))){
                if (Log.isDebug()){
                    _log.debug("'{0}' channel will disconnect and reconnect with with its session identifier '{1}' appended to its endpoint url \n", id, _arg1);
                };
                _appendToURL = _arg1;
            };
        }
        public function receive(_arg1:IMessage, ... _args):void{
            var mpiutil:* = null;
            var msg:* = _arg1;
            var rest:* = _args;
            if (Log.isDebug()){
                _log.debug("'{0}' channel got message\n{1}\n", id, msg.toString());
                if (this.mpiEnabled){
                    try {
                        mpiutil = new MessagePerformanceUtils(msg);
                        _log.debug(mpiutil.prettyPrint());
                    } catch(e:Error) {
                        _log.debug(("Could not get message performance information for: " + msg.toString()));
                    };
                };
            };
            dispatchEvent(MessageEvent.createEvent(MessageEvent.MESSAGE, msg));
        }
        override protected function internalSend(_arg1:MessageResponder):void{
            var _local3:MessagePerformanceInfo;
            var _local4:IMessage;
            setFlexClientIdOnMessage(_arg1.message);
            if (mpiEnabled){
                _local3 = new MessagePerformanceInfo();
                if (recordMessageTimes){
                    _local3.sendTime = new Date().getTime();
                };
                _arg1.message.headers[MessagePerformanceUtils.MPI_HEADER_IN] = _local3;
            };
            var _local2:IMessage = _arg1.message;
            if (((useSmallMessages) && ((_local2 is ISmallMessage)))){
                _local4 = ISmallMessage(_local2).getSmallMessage();
                if (_local4 != null){
                    _local2 = _local4;
                };
            };
            _nc.call(null, _arg1, _local2);
        }
        override protected function getDefaultMessageResponder(_arg1:MessageAgent, _arg2:IMessage):MessageResponder{
            return (new NetConnectionMessageResponder(_arg1, _arg2, this));
        }
        protected function securityErrorHandler(_arg1:SecurityErrorEvent):void{
            defaultErrorHandler("Channel.Security.Error", _arg1);
        }
        private function defaultErrorHandler(_arg1:String, _arg2:ErrorEvent):void{
            var _local3:ChannelFaultEvent = ChannelFaultEvent.createEvent(this, false, _arg1, "error", (((_arg2.text + " url: '") + endpoint) + "'"));
            _local3.rootCause = _arg2;
            if (_connecting){
                connectFailed(_local3);
            } else {
                dispatchEvent(_local3);
            };
        }
        override public function get useSmallMessages():Boolean{
            return (((((super.useSmallMessages) && (!((_nc == null))))) && ((_nc.objectEncoding >= ObjectEncoding.AMF3))));
        }
        override protected function internalConnect():void{
            var url:* = null;
            var i:* = 0;
            var temp:* = null;
            var j:* = 0;
            var redirectedUrl:* = null;
            super.internalConnect();
            url = endpoint;
            if (_appendToURL != null){
                i = url.indexOf("wsrp-url=");
                if (i != -1){
                    temp = url.substr((i + 9), url.length);
                    j = temp.indexOf("&");
                    if (j != -1){
                        temp = temp.substr(0, j);
                    };
                    url = url.replace(temp, (temp + _appendToURL));
                } else {
                    url = (url + _appendToURL);
                };
            };
            if (((((!((_nc.uri == null))) && ((_nc.uri.length > 0)))) && (_nc.connected))){
                _nc.removeEventListener(NetStatusEvent.NET_STATUS, statusHandler);
                _nc.close();
            };
            _nc.addEventListener(NetStatusEvent.NET_STATUS, statusHandler);
            _nc.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            _nc.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            _nc.addEventListener(AsyncErrorEvent.ASYNC_ERROR, asyncErrorHandler);
            try {
                if (NetworkMonitor.isMonitoring()){
                    redirectedUrl = NetworkMonitor.adjustNetConnectionURL(LoaderConfig.url, url);
                    if (redirectedUrl != null){
                        url = redirectedUrl;
                    };
                };
                _nc.connect(url);
            } catch(e:Error) {
                e.message = (e.message + (("  url: '" + url) + "'"));
                throw (e);
            };
        }
        protected function ioErrorHandler(_arg1:IOErrorEvent):void{
            defaultErrorHandler("Channel.IO.Error", _arg1);
        }
        protected function statusHandler(_arg1:NetStatusEvent):void{
        }
        override protected function internalDisconnect(_arg1:Boolean=false):void{
            super.internalDisconnect(_arg1);
            shutdownNetConnection();
            disconnectSuccess(_arg1);
        }
        override protected function connectTimeoutHandler(_arg1:TimerEvent):void{
            shutdownNetConnection();
            super.connectTimeoutHandler(_arg1);
        }
        public function get netConnection():NetConnection{
            return (_nc);
        }
        protected function shutdownNetConnection():void{
            _nc.removeEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            _nc.removeEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            _nc.removeEventListener(NetStatusEvent.NET_STATUS, statusHandler);
            _nc.removeEventListener(AsyncErrorEvent.ASYNC_ERROR, asyncErrorHandler);
            _nc.close();
        }
        protected function asyncErrorHandler(_arg1:AsyncErrorEvent):void{
            defaultErrorHandler("Channel.Async.Error", _arg1);
        }

    }
}//package mx.messaging.channels 

import mx.messaging.messages.*;
import mx.messaging.events.*;
import mx.messaging.*;
import mx.resources.*;

class NetConnectionMessageResponder extends MessageResponder {

    private var handled:Boolean;
    private var resourceManager:IResourceManager;

    public function NetConnectionMessageResponder(_arg1:MessageAgent, _arg2:IMessage, _arg3:NetConnectionChannel){
        resourceManager = ResourceManager.getInstance();
        super(_arg1, _arg2, _arg3);
        _arg3.addEventListener(ChannelEvent.DISCONNECT, channelDisconnectHandler);
        _arg3.addEventListener(ChannelFaultEvent.FAULT, channelFaultHandler);
    }
    protected function channelFaultHandler(_arg1:ChannelFaultEvent):void{
        if (handled){
            return;
        };
        disconnect();
        var _local2:ErrorMessage = _arg1.createErrorMessage();
        _local2.correlationId = message.messageId;
        if (!_arg1.channel.connected){
            _local2.faultCode = ErrorMessage.MESSAGE_DELIVERY_IN_DOUBT;
        };
        _local2.rootCause = _arg1;
        agent.fault(_local2, message);
    }
    private function disconnect():void{
        handled = true;
        channel.removeEventListener(ChannelEvent.DISCONNECT, channelDisconnectHandler);
        channel.removeEventListener(ChannelFaultEvent.FAULT, channelFaultHandler);
    }
    override protected function requestTimedOut():void{
        statusHandler(createRequestTimeoutErrorMessage());
    }
    override protected function statusHandler(_arg1:IMessage):void{
        var _local2:AcknowledgeMessage;
        var _local3:ErrorMessage;
        if (handled){
            return;
        };
        disconnect();
        if ((_arg1 is AsyncMessage)){
            if (AsyncMessage(_arg1).correlationId == message.messageId){
                _local2 = new AcknowledgeMessage();
                _local2.correlationId = AsyncMessage(_arg1).correlationId;
                _local2.headers[AcknowledgeMessage.ERROR_HINT_HEADER] = true;
                agent.acknowledge(_local2, message);
                agent.fault((_arg1 as ErrorMessage), message);
            } else {
                if ((_arg1 is ErrorMessage)){
                    agent.fault((_arg1 as ErrorMessage), message);
                } else {
                    _local3 = new ErrorMessage();
                    _local3.faultCode = "Server.Acknowledge.Failed";
                    _local3.faultString = resourceManager.getString("messaging", "noErrorForMessage");
                    _local3.faultDetail = resourceManager.getString("messaging", "noErrorForMessage.details", [message.messageId, AsyncMessage(_arg1).correlationId]);
                    _local3.correlationId = message.messageId;
                    agent.fault(_local3, message);
                };
            };
        } else {
            _local3 = new ErrorMessage();
            _local3.faultCode = "Server.Acknowledge.Failed";
            _local3.faultString = resourceManager.getString("messaging", "noAckMessage");
            _local3.faultDetail = resourceManager.getString("messaging", "noAckMessage.details", [((_arg1) ? _arg1.toString() : "null")]);
            _local3.correlationId = message.messageId;
            agent.fault(_local3, message);
        };
    }
    protected function channelDisconnectHandler(_arg1:ChannelEvent):void{
        if (handled){
            return;
        };
        disconnect();
        var _local2:ErrorMessage = new ErrorMessage();
        _local2.correlationId = message.messageId;
        _local2.faultString = resourceManager.getString("messaging", "deliveryInDoubt");
        _local2.faultDetail = resourceManager.getString("messaging", "deliveryInDoubt.details");
        _local2.faultCode = ErrorMessage.MESSAGE_DELIVERY_IN_DOUBT;
        _local2.rootCause = _arg1;
        agent.fault(_local2, message);
    }
    override protected function resultHandler(_arg1:IMessage):void{
        var _local2:ErrorMessage;
        if (handled){
            return;
        };
        disconnect();
        if ((_arg1 is AsyncMessage)){
            if (AsyncMessage(_arg1).correlationId == message.messageId){
                agent.acknowledge((_arg1 as AcknowledgeMessage), message);
            } else {
                _local2 = new ErrorMessage();
                _local2.faultCode = "Server.Acknowledge.Failed";
                _local2.faultString = resourceManager.getString("messaging", "ackFailed");
                _local2.faultDetail = resourceManager.getString("messaging", "ackFailed.details", [message.messageId, AsyncMessage(_arg1).correlationId]);
                _local2.correlationId = message.messageId;
                agent.fault(_local2, message);
            };
        } else {
            _local2 = new ErrorMessage();
            _local2.faultCode = "Server.Acknowledge.Failed";
            _local2.faultString = resourceManager.getString("messaging", "noAckMessage");
            _local2.faultDetail = resourceManager.getString("messaging", "noAckMessage.details", [((_arg1) ? _arg1.toString() : "null")]);
            _local2.correlationId = message.messageId;
            agent.fault(_local2, message);
        };
    }

}
﻿package mx.messaging.channels {
    import flash.events.*;
    import flash.utils.*;
    import mx.messaging.messages.*;
    import mx.messaging.events.*;
    import mx.messaging.*;
    import mx.resources.*;
    import mx.logging.*;
    import mx.core.*;

    public class PollingChannel extends Channel {

        private static const DEFAULT_POLLING_INTERVAL:int = 3000;

        mx_internal var _timer:Timer;
        private var _pollingEnabled:Boolean;
        private var _piggybackingEnabled:Boolean;
        mx_internal var _pollingInterval:int;
        mx_internal var pollOutstanding:Boolean;
        private var _pollingRef:int = -1;
        mx_internal var _shouldPoll:Boolean;
        private var resourceManager:IResourceManager;

        public function PollingChannel(_arg1:String=null, _arg2:String=null){
            resourceManager = ResourceManager.getInstance();
            super(_arg1, _arg2);
            _pollingEnabled = true;
            _shouldPoll = false;
            if (timerRequired()){
                _pollingInterval = DEFAULT_POLLING_INTERVAL;
                _timer = new Timer(_pollingInterval, 1);
                _timer.addEventListener(TimerEvent.TIMER, internalPoll);
            };
        }
        public function enablePolling():void{
            _pollingRef++;
            if (_pollingRef == 0){
                startPolling();
            };
        }
        mx_internal function get timerRunning():Boolean{
            return (((!((_timer == null))) && (_timer.running)));
        }
        protected function timerRequired():Boolean{
            return (true);
        }
        override protected function setConnected(_arg1:Boolean):void{
            var _local2:ChannelSet;
            var _local3:MessageAgent;
            if (connected != _arg1){
                if (_arg1){
                    for each (_local2 in channelSets) {
                        for each (_local3 in _local2.messageAgents) {
                            if ((((_local3 is Consumer)) && ((_local3 as Consumer).subscribed))){
                                enablePolling();
                            };
                        };
                    };
                };
                super.setConnected(_arg1);
            };
        }
        override public function send(_arg1:MessageAgent, _arg2:IMessage):void{
            var consumerDispatcher:* = null;
            var msg:* = null;
            var agent:* = _arg1;
            var message:* = _arg2;
            var piggyback:* = false;
            if (((((!(pollOutstanding)) && (_piggybackingEnabled))) && (!((message is CommandMessage))))){
                if (_shouldPoll){
                    piggyback = true;
                } else {
                    consumerDispatcher = ConsumerMessageDispatcher.getInstance();
                    if (consumerDispatcher.isChannelUsedForSubscriptions(this)){
                        piggyback = true;
                    };
                };
            };
            if (piggyback){
                internalPoll();
            };
            super.send(agent, message);
            if (piggyback){
                msg = new CommandMessage();
                msg.operation = CommandMessage.POLL_OPERATION;
                if (Log.isDebug()){
                    _log.debug("'{0}' channel sending poll message\n{1}\n", id, msg.toString());
                };
                try {
                    internalSend(new PollCommandMessageResponder(null, msg, this, _log));
                } catch(e:Error) {
                    stopPolling();
                    throw (e);
                };
            };
        }
        protected function applyPollingSettings(_arg1:XML):void{
            var _local2:XML;
            if (_arg1.properties.length()){
                _local2 = _arg1.properties[0];
                if (_local2["polling-enabled"].length()){
                    internalPollingEnabled = (_local2["polling-enabled"].toString() == "true");
                };
                if (_local2["polling-interval-millis"].length()){
                    internalPollingInterval = parseInt(_local2["polling-interval-millis"].toString());
                } else {
                    if (_local2["polling-interval-seconds"].length()){
                        internalPollingInterval = (parseInt(_local2["polling-interval-seconds"].toString()) * 1000);
                    };
                };
                if (_local2["piggybacking-enabled"].length()){
                    internalPiggybackingEnabled = (_local2["piggybacking-enabled"].toString() == "true");
                };
                if (_local2["login-after-disconnect"].length()){
                    _loginAfterDisconnect = (_local2["login-after-disconnect"].toString() == "true");
                };
            };
        }
        mx_internal function set internalPollingInterval(_arg1:Number):void{
            var _local2:String;
            if (_arg1 == 0){
                _pollingInterval = _arg1;
                if (_timer != null){
                    _timer.stop();
                };
                if (_shouldPoll){
                    startPolling();
                };
            } else {
                if (_arg1 > 0){
                    if (_timer != null){
                        _timer.delay = (_pollingInterval = _arg1);
                        if (((!(timerRunning)) && (_shouldPoll))){
                            startPolling();
                        };
                    };
                } else {
                    _local2 = resourceManager.getString("messaging", "pollingIntervalNonPositive");
                    throw (new ArgumentError(_local2));
                };
            };
        }
        public function poll():void{
            internalPoll();
        }
        protected function set internalPiggybackingEnabled(_arg1:Boolean):void{
            _piggybackingEnabled = _arg1;
        }
        protected function get internalPollingEnabled():Boolean{
            return (_pollingEnabled);
        }
        mx_internal function pollFailed(_arg1:Boolean=false):void{
            internalDisconnect(_arg1);
        }
        override protected function connectFailed(_arg1:ChannelFaultEvent):void{
            stopPolling();
            super.connectFailed(_arg1);
        }
        mx_internal function stopPolling():void{
            if (Log.isInfo()){
                _log.info("'{0}' channel polling stopped.", id);
            };
            if (_timer != null){
                _timer.stop();
            };
            _pollingRef = -1;
            _shouldPoll = false;
            pollOutstanding = false;
        }
        protected function internalPoll(_arg1:Event=null):void{
            var poll:* = null;
            var event = _arg1;
            if (!pollOutstanding){
                if (Log.isInfo()){
                    _log.info("'{0}' channel requesting queued messages.", id);
                };
                if (timerRunning){
                    _timer.stop();
                };
                poll = new CommandMessage();
                poll.operation = CommandMessage.POLL_OPERATION;
                if (Log.isDebug()){
                    _log.debug("'{0}' channel sending poll message\n{1}\n", id, poll.toString());
                };
                try {
                    internalSend(new PollCommandMessageResponder(null, poll, this, _log));
                    pollOutstanding = true;
                } catch(e:Error) {
                    stopPolling();
                    throw (e);
                };
            } else {
                if (Log.isInfo()){
                    _log.info("'{0}' channel waiting for poll response.", id);
                };
            };
        }
        protected function getDefaultMessageResponder(_arg1:MessageAgent, _arg2:IMessage):MessageResponder{
            return (super.getMessageResponder(_arg1, _arg2));
        }
        mx_internal function get internalPollingInterval():Number{
            return (((_timer)==null) ? 0 : _pollingInterval);
        }
        protected function startPolling():void{
            if (_pollingEnabled){
                if (Log.isInfo()){
                    _log.info("'{0}' channel polling started.", id);
                };
                _shouldPoll = true;
                poll();
            };
        }
        protected function get internalPiggybackingEnabled():Boolean{
            return (_piggybackingEnabled);
        }
        override mx_internal function get realtime():Boolean{
            return (_pollingEnabled);
        }
        final override protected function getMessageResponder(_arg1:MessageAgent, _arg2:IMessage):MessageResponder{
            if ((((_arg2 is CommandMessage)) && (((_arg2 as CommandMessage).operation == CommandMessage.POLL_OPERATION)))){
                return (new PollCommandMessageResponder(_arg1, _arg2, this, _log));
            };
            return (getDefaultMessageResponder(_arg1, _arg2));
        }
        override protected function internalDisconnect(_arg1:Boolean=false):void{
            stopPolling();
            super.internalDisconnect(_arg1);
        }
        public function disablePolling():void{
            _pollingRef--;
            if (_pollingRef < 0){
                stopPolling();
            };
        }
        protected function set internalPollingEnabled(_arg1:Boolean):void{
            _pollingEnabled = _arg1;
            if (((!(_arg1)) && (((timerRunning) || (((!(timerRunning)) && ((_pollingInterval == 0)))))))){
                stopPolling();
            } else {
                if (((((_arg1) && (_shouldPoll))) && (!(timerRunning)))){
                    startPolling();
                };
            };
        }

    }
}//package mx.messaging.channels 

import mx.events.*;
import mx.messaging.messages.*;
import mx.messaging.events.*;
import mx.messaging.*;
import mx.resources.*;
import mx.logging.*;

class PollCommandMessageResponder extends MessageResponder {

    private var _log:ILogger;
    private var suppressHandlers:Boolean;
    private var resourceManager:IResourceManager;

    public function PollCommandMessageResponder(_arg1:MessageAgent, _arg2:IMessage, _arg3:PollingChannel, _arg4:ILogger){
        resourceManager = ResourceManager.getInstance();
        super(_arg1, _arg2, _arg3);
        _log = _arg4;
        _arg3.addEventListener(PropertyChangeEvent.PROPERTY_CHANGE, channelPropertyChangeHandler);
    }
    private function doPoll(_arg1:int=0):void{
        var _local2:PollingChannel = PollingChannel(channel);
        if (((_local2.connected) && (_local2._shouldPoll))){
            if (_arg1 == 0){
                if (_local2.internalPollingInterval == 0){
                    _local2.poll();
                } else {
                    if (!_local2.timerRunning){
                        _local2._timer.delay = _local2._pollingInterval;
                        _local2._timer.start();
                    };
                };
            } else {
                _local2._timer.delay = _arg1;
                _local2._timer.start();
            };
        };
    }
    private function channelPropertyChangeHandler(_arg1:PropertyChangeEvent):void{
        if ((((_arg1.property == "connected")) && (!(_arg1.newValue)))){
            suppressHandlers = true;
        };
    }
    override protected function resultHandler(_arg1:IMessage):void{
        var messageList:* = null;
        var message:* = null;
        var mpiutil:* = null;
        var errMsg:* = null;
        var msg:* = _arg1;
        var pollingChannel:* = (channel as PollingChannel);
        if (suppressHandlers){
            if (Log.isDebug()){
                _log.debug("'{0}' channel ignoring response for poll request preceeding most recent disconnect.\n", channel.id);
            };
            doPoll();
            return;
        };
        if ((msg is CommandMessage)){
            pollingChannel.pollOutstanding = false;
            if (msg.headers[CommandMessage.NO_OP_POLL_HEADER] == true){
                return;
            };
            if (msg.body != null){
                messageList = (msg.body as Array);
                for each (message in messageList) {
                    if (Log.isDebug()){
                        _log.debug("'{0}' channel got message\n{1}\n", channel.id, message.toString());
                        if (channel.mpiEnabled){
                            try {
                                mpiutil = new MessagePerformanceUtils(message);
                                _log.debug(mpiutil.prettyPrint());
                            } catch(e:Error) {
                                _log.debug(("Could not get message performance information for: " + msg.toString()));
                            };
                        };
                    };
                    channel.dispatchEvent(MessageEvent.createEvent(MessageEvent.MESSAGE, message));
                };
            };
        } else {
            if ((msg is AcknowledgeMessage)){
                pollingChannel.pollOutstanding = false;
            } else {
                errMsg = new ErrorMessage();
                errMsg.faultDetail = resourceManager.getString("messaging", "receivedNull");
                status(errMsg);
                return;
            };
        };
        if (msg.headers[CommandMessage.POLL_WAIT_HEADER] != null){
            doPoll(msg.headers[CommandMessage.POLL_WAIT_HEADER]);
        } else {
            doPoll();
        };
    }
    override protected function statusHandler(_arg1:IMessage):void{
        if (suppressHandlers){
            if (Log.isDebug()){
                _log.debug("'{0}' channel ignoring response for poll request preceeding most recent disconnect.\n", channel.id);
            };
            return;
        };
        var _local2:PollingChannel = PollingChannel(channel);
        _local2.stopPolling();
        var _local3:ErrorMessage = (_arg1 as ErrorMessage);
        var _local4:String = ((_local3)!=null) ? _local3.faultDetail : "";
        var _local5:ChannelFaultEvent = ChannelFaultEvent.createEvent(_local2, false, "Channel.Polling.Error", "error", _local4);
        _local5.rootCause = _arg1;
        _local2.dispatchEvent(_local5);
        if (((!((_local3 == null))) && ((_local3.faultCode == "Server.PollNotSupported")))){
            _local2.pollFailed(true);
        } else {
            _local2.pollFailed(false);
        };
    }

}
﻿package mx.messaging.channels {
    import flash.events.*;
    import mx.messaging.messages.*;
    import mx.messaging.*;
    import mx.resources.*;
    import flash.net.*;
    import mx.messaging.config.*;
    import mx.core.*;
    import mx.messaging.errors.*;
    import mx.netmon.*;

    public class DirectHTTPChannel extends Channel {

        private static var clientCounter:uint;

        mx_internal var clientId:String;
        private var resourceManager:IResourceManager;

        public function DirectHTTPChannel(_arg1:String, _arg2:String=""){
            var _local3:String;
            resourceManager = ResourceManager.getInstance();
            super(_arg1, _arg2);
            if (_arg2.length > 0){
                _local3 = resourceManager.getString("messaging", "noURIAllowed");
                throw (new InvalidChannelError(_local3));
            };
            clientId = ("DirectHTTPChannel" + clientCounter++);
        }
        override public function setCredentials(_arg1:String, _arg2:MessageAgent=null, _arg3:String=null):void{
            var _local4:String = resourceManager.getString("messaging", "authenticationNotSupported");
            throw (new ChannelError(_local4));
        }
        override protected function internalSend(_arg1:MessageResponder):void{
            var httpMsgResp:* = null;
            var urlRequest:* = null;
            var msgResp:* = _arg1;
            httpMsgResp = DirectHTTPMessageResponder(msgResp);
            try {
                urlRequest = createURLRequest(httpMsgResp.message);
            } catch(e:MessageSerializationError) {
                httpMsgResp.agent.fault(e.fault, httpMsgResp.message);
                return;
            };
            var urlLoader:* = httpMsgResp.urlLoader;
            urlLoader.addEventListener(ErrorEvent.ERROR, httpMsgResp.errorHandler);
            urlLoader.addEventListener(IOErrorEvent.IO_ERROR, httpMsgResp.errorHandler);
            urlLoader.addEventListener(SecurityErrorEvent.SECURITY_ERROR, httpMsgResp.securityErrorHandler);
            urlLoader.addEventListener(Event.COMPLETE, httpMsgResp.completeHandler);
            urlLoader.addEventListener(HTTPStatusEvent.HTTP_STATUS, httpMsgResp.httpStatusHandler);
            urlLoader.load(urlRequest);
        }
        override public function get connected():Boolean{
            return (true);
        }
        override mx_internal function get realtime():Boolean{
            return (false);
        }
        override protected function internalConnect():void{
            connectSuccess();
        }
        override protected function getMessageResponder(_arg1:MessageAgent, _arg2:IMessage):MessageResponder{
            return (new DirectHTTPMessageResponder(_arg1, _arg2, this, new URLLoader()));
        }
        override public function get protocol():String{
            return ("http");
        }
        override protected function connectTimeoutHandler(_arg1:TimerEvent):void{
        }
        mx_internal function createURLRequest(_arg1:IMessage):URLRequest{
            var _local8:Array;
            var _local9:URLRequestHeader;
            var _local10:String;
            var _local11:URLVariables;
            var _local12:Object;
            var _local13:String;
            var _local2:HTTPRequestMessage = HTTPRequestMessage(_arg1);
            var _local3:URLRequest = new URLRequest();
            var _local4:String = _local2.url;
            var _local5:String;
            _local3.contentType = _local2.contentType;
            var _local6:Boolean = (((_local3.contentType == HTTPRequestMessage.CONTENT_TYPE_XML)) || ((_local3.contentType == HTTPRequestMessage.CONTENT_TYPE_SOAP_XML)));
            var _local7:Object = _local2.httpHeaders;
            if (_local7){
                _local8 = [];
                for (_local10 in _local7) {
                    _local9 = new URLRequestHeader(_local10, _local7[_local10]);
                    _local8.push(_local9);
                };
                _local3.requestHeaders = _local8;
            };
            if (!_local6){
                _local11 = new URLVariables();
                _local12 = _local2.body;
                for (_local13 in _local12) {
                    _local11[_local13] = _local2.body[_local13];
                };
                _local5 = _local11.toString();
            };
            if ((((_local2.method == HTTPRequestMessage.POST_METHOD)) || (_local6))){
                _local3.method = "POST";
                if (_local3.contentType == HTTPRequestMessage.CONTENT_TYPE_FORM){
                    _local3.data = _local5;
                } else {
                    if (((!((_local2.body == null))) && ((_local2.body is XML)))){
                        _local3.data = XML(_local2.body).toXMLString();
                    } else {
                        _local3.data = _local2.body;
                    };
                };
            } else {
                if (((_local5) && (!((_local5 == ""))))){
                    _local4 = (_local4 + ((_local4.indexOf("?"))>-1) ? "&" : "?");
                    _local4 = (_local4 + _local5);
                };
            };
            _local3.url = _local4;
            if (NetworkMonitor.isMonitoring()){
                NetworkMonitor.adjustURLRequest(_local3, LoaderConfig.url, _arg1.messageId);
            };
            return (_local3);
        }

    }
}//package mx.messaging.channels 

import flash.events.*;
import mx.messaging.messages.*;
import mx.messaging.*;
import mx.resources.*;
import flash.net.*;

class DirectHTTPMessageResponder extends MessageResponder {

    private var clientId:String;
    private var lastStatus:int;
    public var urlLoader:URLLoader;
    private var resourceManager:IResourceManager;

    public function DirectHTTPMessageResponder(_arg1:MessageAgent, _arg2:IMessage, _arg3:DirectHTTPChannel, _arg4:URLLoader){
        resourceManager = ResourceManager.getInstance();
        super(_arg1, _arg2, _arg3);
        this.urlLoader = _arg4;
        clientId = _arg3.clientId;
    }
    public function securityErrorHandler(_arg1:Event):void{
        var _local2:AcknowledgeMessage;
        status(null);
        _local2 = new AcknowledgeMessage();
        _local2.clientId = clientId;
        _local2.correlationId = message.messageId;
        _local2.headers[AcknowledgeMessage.ERROR_HINT_HEADER] = true;
        agent.acknowledge(_local2, message);
        var _local3:ErrorMessage = new ErrorMessage();
        _local3.clientId = clientId;
        _local3.correlationId = message.messageId;
        _local3.faultCode = "Channel.Security.Error";
        _local3.faultString = resourceManager.getString("messaging", "securityError");
        _local3.faultDetail = resourceManager.getString("messaging", "securityError.details", [message.destination]);
        _local3.rootCause = _arg1;
        _local3.body = URLLoader(_arg1.target).data;
        _local3.headers[AbstractMessage.STATUS_CODE_HEADER] = lastStatus;
        agent.fault(_local3, message);
    }
    override protected function requestTimedOut():void{
        urlLoader.removeEventListener(ErrorEvent.ERROR, errorHandler);
        urlLoader.removeEventListener(IOErrorEvent.IO_ERROR, errorHandler);
        urlLoader.removeEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
        urlLoader.removeEventListener(Event.COMPLETE, completeHandler);
        urlLoader.removeEventListener(HTTPStatusEvent.HTTP_STATUS, httpStatusHandler);
        urlLoader.close();
        status(null);
        var _local1:AcknowledgeMessage = new AcknowledgeMessage();
        _local1.clientId = clientId;
        _local1.correlationId = message.messageId;
        _local1.headers[AcknowledgeMessage.ERROR_HINT_HEADER] = true;
        agent.acknowledge(_local1, message);
        agent.fault(createRequestTimeoutErrorMessage(), message);
    }
    public function errorHandler(_arg1:Event):void{
        status(null);
        var _local2:AcknowledgeMessage = new AcknowledgeMessage();
        _local2.clientId = clientId;
        _local2.correlationId = message.messageId;
        _local2.headers[AcknowledgeMessage.ERROR_HINT_HEADER] = true;
        agent.acknowledge(_local2, message);
        var _local3:ErrorMessage = new ErrorMessage();
        _local3.clientId = clientId;
        _local3.correlationId = message.messageId;
        _local3.faultCode = "Server.Error.Request";
        _local3.faultString = resourceManager.getString("messaging", "httpRequestError");
        var _local4:String = _arg1.toString();
        if ((message is HTTPRequestMessage)){
            _local4 = (_local4 + ". URL: ");
            _local4 = (_local4 + HTTPRequestMessage(message).url);
        };
        _local3.faultDetail = resourceManager.getString("messaging", "httpRequestError.details", [_local4]);
        _local3.rootCause = _arg1;
        _local3.body = URLLoader(_arg1.target).data;
        _local3.headers[AbstractMessage.STATUS_CODE_HEADER] = lastStatus;
        agent.fault(_local3, message);
    }
    public function httpStatusHandler(_arg1:HTTPStatusEvent):void{
        lastStatus = _arg1.status;
    }
    public function completeHandler(_arg1:Event):void{
        result(null);
        var _local2:AcknowledgeMessage = new AcknowledgeMessage();
        _local2.clientId = clientId;
        _local2.correlationId = message.messageId;
        _local2.body = URLLoader(_arg1.target).data;
        _local2.headers[AbstractMessage.STATUS_CODE_HEADER] = lastStatus;
        agent.acknowledge(_local2, message);
    }

}
﻿package mx.messaging {
    import flash.events.*;
    import mx.rpc.*;
    import mx.events.*;
    import flash.utils.*;
    import mx.messaging.messages.*;
    import mx.rpc.events.*;
    import mx.messaging.events.*;
    import mx.resources.*;
    import mx.messaging.channels.*;
    import mx.utils.*;
    import mx.messaging.config.*;
    import mx.core.*;
    import mx.messaging.errors.*;
    import flash.errors.*;

    public class ChannelSet extends EventDispatcher {

        private var _shouldHunt:Boolean;
        private var _connected:Boolean;
        private var _hasRequestedClusterEndpoints:Boolean;
        private var _clustered:Boolean;
        private var _channels:Array;
        private var _hunting:Boolean;
        private var _authenticated:Boolean;
        private var _pendingMessages:Dictionary;
        private var _authAgent:AuthenticationAgent;
        private var resourceManager:IResourceManager;
        private var _heartbeatTimer:Timer;
        private var _credentials:String;
        private var _reconnectTimer:Timer = null;
        private var _credentialsCharset:String;
        private var _initialDestinationId:String;
        private var _shouldBeConnected:Boolean;
        private var _connecting:Boolean;
        private var _channelIds:Array;
        private var _configured:Boolean;
        private var _heartbeatInterval:int = 0;
        private var _currentChannel:Channel;
        private var _currentChannelIndex:int;
        private var _pendingSends:Array;
        private var _messageAgents:Array;
        private var _channelFailoverURIs:Object;

        public function ChannelSet(_arg1:Array=null, _arg2:Boolean=false){
            resourceManager = ResourceManager.getInstance();
            super();
            _clustered = _arg2;
            _connected = false;
            _connecting = false;
            _currentChannelIndex = -1;
            if (_arg1 != null){
                _channelIds = _arg1;
                _channels = new Array(_channelIds.length);
                _configured = true;
            } else {
                _channels = [];
                _configured = false;
            };
            _hasRequestedClusterEndpoints = false;
            _hunting = false;
            _messageAgents = [];
            _pendingMessages = new Dictionary();
            _pendingSends = [];
            _shouldBeConnected = false;
            _shouldHunt = true;
        }
        private function reconnectChannel(_arg1:TimerEvent):void{
            _reconnectTimer.stop();
            _reconnectTimer.removeEventListener(TimerEvent.TIMER, reconnectChannel);
            _reconnectTimer = null;
            connectChannel();
        }
        public function get connected():Boolean{
            return (_connected);
        }
        public function login(_arg1:String, _arg2:String, _arg3:String=null):AsyncToken{
            var _local7:String;
            var _local8:Base64Encoder;
            if (authenticated){
                throw (new IllegalOperationError("ChannelSet is already authenticated."));
            };
            if (((!((_authAgent == null))) && (!((_authAgent.state == AuthenticationAgent.LOGGED_OUT_STATE))))){
                throw (new IllegalOperationError("ChannelSet is in the process of logging in or logging out."));
            };
            if (_arg3 != Base64Encoder.CHARSET_UTF_8){
                _arg3 = null;
            };
            var _local4:String;
            if (((!((_arg1 == null))) && (!((_arg2 == null))))){
                _local7 = ((_arg1 + ":") + _arg2);
                _local8 = new Base64Encoder();
                if (_arg3 == Base64Encoder.CHARSET_UTF_8){
                    _local8.encodeUTFBytes(_local7);
                } else {
                    _local8.encode(_local7);
                };
                _local4 = _local8.drain();
            };
            var _local5:CommandMessage = new CommandMessage();
            _local5.operation = CommandMessage.LOGIN_OPERATION;
            _local5.body = _local4;
            if (_arg3 != null){
                _local5.headers[CommandMessage.CREDENTIALS_CHARSET_HEADER] = _arg3;
            };
            _local5.destination = "auth";
            var _local6:AsyncToken = new AsyncToken(_local5);
            if (_authAgent == null){
                _authAgent = new AuthenticationAgent(this);
            };
            _authAgent.registerToken(_local6);
            _authAgent.state = AuthenticationAgent.LOGGING_IN_STATE;
            send(_authAgent, _local5);
            return (_local6);
        }
        protected function sendHeartbeat():void{
            var _local1:PollingChannel = (currentChannel as PollingChannel);
            if (((!((_local1 == null))) && (_local1._shouldPoll))){
                return;
            };
            var _local2:CommandMessage = new CommandMessage();
            _local2.operation = CommandMessage.CLIENT_PING_OPERATION;
            _local2.headers[CommandMessage.HEARTBEAT_HEADER] = true;
            currentChannel.sendInternalMessage(new MessageResponder(null, _local2));
        }
        private function hunt():Boolean{
            var _local1:String;
            if (_channels.length == 0){
                _local1 = resourceManager.getString("messaging", "noAvailableChannels");
                throw (new NoChannelAvailableError(_local1));
            };
            if (_currentChannel != null){
                disconnectChannel();
            };
            if (++_currentChannelIndex >= _channels.length){
                _currentChannelIndex = -1;
                return (false);
            };
            if (_currentChannelIndex > 0){
                _hunting = true;
            };
            if (configured){
                if (_channels[_currentChannelIndex] != null){
                    _currentChannel = _channels[_currentChannelIndex];
                } else {
                    _currentChannel = ServerConfig.getChannel(_channelIds[_currentChannelIndex], _clustered);
                    _currentChannel.setCredentials(_credentials);
                    _channels[_currentChannelIndex] = _currentChannel;
                };
            } else {
                _currentChannel = _channels[_currentChannelIndex];
            };
            if (((!((_channelFailoverURIs == null))) && (!((_channelFailoverURIs[_currentChannel.id] == null))))){
                _currentChannel.failoverURIs = _channelFailoverURIs[_currentChannel.id];
            };
            return (true);
        }
        public function get clustered():Boolean{
            return (_clustered);
        }
        public function disconnect(_arg1:MessageAgent):void{
            var _local2:Array;
            var _local3:int;
            var _local4:int;
            var _local5:int;
            var _local6:int;
            var _local7:int;
            var _local8:PendingSend;
            if (_arg1 == null){
                _local2 = _messageAgents.slice();
                _local3 = _local2.length;
                _local4 = 0;
                while (_local4 < _local3) {
                    _local2[_local4].disconnect();
                    _local4++;
                };
                if (_authAgent != null){
                    _authAgent.state = AuthenticationAgent.SHUTDOWN_STATE;
                    _authAgent = null;
                };
            } else {
                _local5 = ((_arg1)!=null) ? _messageAgents.indexOf(_arg1) : -1;
                if (_local5 != -1){
                    _messageAgents.splice(_local5, 1);
                    removeEventListener(ChannelEvent.CONNECT, _arg1.channelConnectHandler);
                    removeEventListener(ChannelEvent.DISCONNECT, _arg1.channelDisconnectHandler);
                    removeEventListener(ChannelFaultEvent.FAULT, _arg1.channelFaultHandler);
                    if (((connected) || (_connecting))){
                        _arg1.channelDisconnectHandler(ChannelEvent.createEvent(ChannelEvent.DISCONNECT, _currentChannel, false));
                    } else {
                        _local6 = _pendingSends.length;
                        _local7 = 0;
                        while (_local7 < _local6) {
                            _local8 = PendingSend(_pendingSends[_local7]);
                            if (_local8.agent == _arg1){
                                _pendingSends.splice(_local7, 1);
                                _local7--;
                                _local6--;
                                delete _pendingMessages[_local8.message];
                            };
                            _local7++;
                        };
                    };
                    if (_messageAgents.length == 0){
                        _shouldBeConnected = false;
                        _currentChannelIndex = -1;
                        if (connected){
                            disconnectChannel();
                        };
                    };
                    if (_arg1.channelSetMode == MessageAgent.AUTO_CONFIGURED_CHANNELSET){
                        _arg1.internalSetChannelSet(null);
                    };
                };
            };
        }
        public function set channels(_arg1:Array):void{
            var _local5:String;
            var _local6:int;
            var _local7:int;
            if (configured){
                _local5 = resourceManager.getString("messaging", "cannotAddWhenConfigured");
                throw (new IllegalOperationError(_local5));
            };
            var _local2:Array = _channels.slice();
            var _local3:int = _local2.length;
            var _local4:int;
            while (_local4 < _local3) {
                removeChannel(_local2[_local4]);
                _local4++;
            };
            if (((!((_arg1 == null))) && ((_arg1.length > 0)))){
                _local6 = _arg1.length;
                _local7 = 0;
                while (_local7 < _local6) {
                    addChannel(_arg1[_local7]);
                    _local7++;
                };
            };
        }
        public function addChannel(_arg1:Channel):void{
            var _local2:String;
            if (_arg1 == null){
                return;
            };
            if (configured){
                _local2 = resourceManager.getString("messaging", "cannotAddWhenConfigured");
                throw (new IllegalOperationError(_local2));
            };
            if (((clustered) && ((_arg1.id == null)))){
                _local2 = resourceManager.getString("messaging", "cannotAddNullIdChannelWhenClustered");
                throw (new IllegalOperationError(_local2));
            };
            if (_channels.indexOf(_arg1) != -1){
                return;
            };
            _channels.push(_arg1);
            if (_credentials){
                _arg1.setCredentials(_credentials, null, _credentialsCharset);
            };
        }
        protected function scheduleHeartbeat():void{
            if ((((_heartbeatTimer == null)) && ((heartbeatInterval > 0)))){
                _heartbeatTimer = new Timer(heartbeatInterval, 1);
                _heartbeatTimer.addEventListener(TimerEvent.TIMER, sendHeartbeatHandler);
                _heartbeatTimer.start();
            };
        }
        public function send(_arg1:MessageAgent, _arg2:IMessage):void{
            var _local3:AcknowledgeMessage;
            var _local4:CommandMessage;
            if (((((!((_currentChannel == null))) && (_currentChannel.connected))) && (!(_arg1.needsConfig)))){
                if ((((_arg2 is CommandMessage)) && ((CommandMessage(_arg2).operation == CommandMessage.TRIGGER_CONNECT_OPERATION)))){
                    _local3 = new AcknowledgeMessage();
                    _local3.clientId = _arg1.clientId;
                    _local3.correlationId = _arg2.messageId;
                    new AsyncDispatcher(_arg1.acknowledge, [_local3, _arg2], 1);
                    return;
                };
                if (((!(_hasRequestedClusterEndpoints)) && (clustered))){
                    _local4 = new CommandMessage();
                    if ((_arg1 is AuthenticationAgent)){
                        _local4.destination = initialDestinationId;
                    } else {
                        _local4.destination = _arg1.destination;
                    };
                    _local4.operation = CommandMessage.CLUSTER_REQUEST_OPERATION;
                    _currentChannel.sendInternalMessage(new ClusterMessageResponder(_local4, this));
                    _hasRequestedClusterEndpoints = true;
                };
                unscheduleHeartbeat();
                _currentChannel.send(_arg1, _arg2);
                scheduleHeartbeat();
            } else {
                if (_pendingMessages[_arg2] == null){
                    _pendingMessages[_arg2] = true;
                    _pendingSends.push(new PendingSend(_arg1, _arg2));
                };
                if (!_connecting){
                    if ((((_currentChannel == null)) || ((_currentChannelIndex == -1)))){
                        hunt();
                    };
                    if ((_currentChannel is NetConnectionChannel)){
                        if (_reconnectTimer == null){
                            _reconnectTimer = new Timer(1, 1);
                            _reconnectTimer.addEventListener(TimerEvent.TIMER, reconnectChannel);
                            _reconnectTimer.start();
                        };
                    } else {
                        connectChannel();
                    };
                };
            };
        }
        public function logout(_arg1:MessageAgent=null):AsyncToken{
            var _local2:int;
            var _local3:int;
            var _local4:CommandMessage;
            var _local5:AsyncToken;
            var _local6:int;
            var _local7:int;
            _credentials = null;
            if (_arg1 == null){
                if (((!((_authAgent == null))) && ((((_authAgent.state == AuthenticationAgent.LOGGING_OUT_STATE)) || ((_authAgent.state == AuthenticationAgent.LOGGING_IN_STATE)))))){
                    throw (new IllegalOperationError("ChannelSet is in the process of logging in or logging out."));
                };
                _local2 = _messageAgents.length;
                _local3 = 0;
                while (_local3 < _local2) {
                    _messageAgents[_local3].internalSetCredentials(null);
                    _local3++;
                };
                _local2 = _channels.length;
                _local3 = 0;
                while (_local3 < _local2) {
                    if (_channels[_local3] != null){
                        _channels[_local3].internalSetCredentials(null);
                        if ((_channels[_local3] is PollingChannel)){
                            PollingChannel(_channels[_local3]).disablePolling();
                        };
                    };
                    _local3++;
                };
                _local4 = new CommandMessage();
                _local4.operation = CommandMessage.LOGOUT_OPERATION;
                _local4.destination = "auth";
                _local5 = new AsyncToken(_local4);
                if (_authAgent == null){
                    _authAgent = new AuthenticationAgent(this);
                };
                _authAgent.registerToken(_local5);
                _authAgent.state = AuthenticationAgent.LOGGING_OUT_STATE;
                send(_authAgent, _local4);
                return (_local5);
            };
            _local6 = _channels.length;
            _local7 = 0;
            while (_local7 < _local6) {
                if (_channels[_local7] != null){
                    _channels[_local7].logout(_arg1);
                };
                _local7++;
            };
            return (null);
        }
        public function set clustered(_arg1:Boolean):void{
            var _local2:Array;
            var _local3:int;
            var _local4:int;
            var _local5:String;
            if (_clustered != _arg1){
                if (_arg1){
                    _local2 = channelIds;
                    _local3 = _local2.length;
                    _local4 = 0;
                    while (_local4 < _local3) {
                        if (_local2[_local4] == null){
                            _local5 = resourceManager.getString("messaging", "cannotSetClusteredWithdNullChannelIds");
                            throw (new IllegalOperationError(_local5));
                        };
                        _local4++;
                    };
                };
                _clustered = _arg1;
            };
        }
        public function get channelIds():Array{
            var _local1:Array;
            var _local2:int;
            var _local3:int;
            if (_channelIds != null){
                return (_channelIds);
            };
            _local1 = [];
            _local2 = _channels.length;
            _local3 = 0;
            while (_local3 < _local2) {
                if (_channels[_local3] != null){
                    _local1.push(_channels[_local3].id);
                } else {
                    _local1.push(null);
                };
                _local3++;
            };
            return (_local1);
        }
        public function get authenticated():Boolean{
            return (_authenticated);
        }
        private function connectChannel():void{
            _connecting = true;
            _currentChannel.connect(this);
            _currentChannel.addEventListener(MessageEvent.MESSAGE, messageHandler);
        }
        protected function unscheduleHeartbeat():void{
            if (_heartbeatTimer != null){
                _heartbeatTimer.stop();
                _heartbeatTimer.removeEventListener(TimerEvent.TIMER, sendHeartbeatHandler);
                _heartbeatTimer = null;
            };
        }
        mx_internal function get channelFailoverURIs():Object{
            return (_channelFailoverURIs);
        }
        mx_internal function get configured():Boolean{
            return (_configured);
        }
        public function setCredentials(_arg1:String, _arg2:MessageAgent, _arg3:String=null):void{
            _credentials = _arg1;
            var _local4:int = _channels.length;
            var _local5:int;
            while (_local5 < _local4) {
                if (_channels[_local5] != null){
                    _channels[_local5].setCredentials(_credentials, _arg2, _arg3);
                };
                _local5++;
            };
        }
        public function set heartbeatInterval(_arg1:int):void{
            var _local2:PropertyChangeEvent;
            if (_heartbeatInterval != _arg1){
                _local2 = PropertyChangeEvent.createUpdateEvent(this, "heartbeatInterval", _heartbeatInterval, _arg1);
                _heartbeatInterval = _arg1;
                dispatchEvent(_local2);
                if ((((_heartbeatInterval > 0)) && (connected))){
                    scheduleHeartbeat();
                };
            };
        }
        protected function messageHandler(_arg1:MessageEvent):void{
            dispatchEvent(_arg1);
        }
        protected function setConnected(_arg1:Boolean):void{
            var _local2:PropertyChangeEvent;
            if (_connected != _arg1){
                _local2 = PropertyChangeEvent.createUpdateEvent(this, "connected", _connected, _arg1);
                _connected = _arg1;
                dispatchEvent(_local2);
                setAuthenticated(((((_arg1) && (currentChannel))) && (currentChannel.authenticated)), _credentials, false);
                if (!connected){
                    unscheduleHeartbeat();
                } else {
                    if (heartbeatInterval > 0){
                        scheduleHeartbeat();
                    };
                };
            };
        }
        public function get currentChannel():Channel{
            return (_currentChannel);
        }
        private function disconnectChannel():void{
            _connecting = false;
            _currentChannel.removeEventListener(MessageEvent.MESSAGE, messageHandler);
            _currentChannel.disconnect(this);
        }
        public function get channels():Array{
            return (_channels);
        }
        public function set initialDestinationId(_arg1:String):void{
            _initialDestinationId = _arg1;
        }
        protected function faultPendingSends(_arg1:ChannelEvent):void{
            var _local2:PendingSend;
            var _local3:IMessage;
            var _local4:ErrorMessage;
            var _local5:ChannelFaultEvent;
            while (_pendingSends.length > 0) {
                _local2 = (_pendingSends.shift() as PendingSend);
                _local3 = _local2.message;
                delete _pendingMessages[_local3];
                _local4 = new ErrorMessage();
                _local4.correlationId = _local3.messageId;
                _local4.headers[ErrorMessage.RETRYABLE_HINT_HEADER] = true;
                _local4.faultCode = "Client.Error.MessageSend";
                _local4.faultString = resourceManager.getString("messaging", "sendFailed");
                if ((_arg1 is ChannelFaultEvent)){
                    _local5 = (_arg1 as ChannelFaultEvent);
                    _local4.faultDetail = ((((_local5.faultCode + " ") + _local5.faultString) + " ") + _local5.faultDetail);
                    if (_local5.faultCode == "Channel.Authentication.Error"){
                        _local4.faultCode = _local5.faultCode;
                    };
                } else {
                    _local4.faultDetail = resourceManager.getString("messaging", "cannotConnectToDestination");
                };
                _local4.rootCause = _arg1;
                _local2.agent.fault(_local4, _local3);
            };
        }
        public function channelDisconnectHandler(_arg1:ChannelEvent):void{
            _connecting = false;
            setConnected(false);
            if (((((_shouldBeConnected) && (!(_arg1.reconnecting)))) && (!(_arg1.rejected)))){
                if (((_shouldHunt) && (hunt()))){
                    _arg1.reconnecting = true;
                    dispatchEvent(_arg1);
                    if ((_currentChannel is NetConnectionChannel)){
                        if (_reconnectTimer == null){
                            _reconnectTimer = new Timer(1, 1);
                            _reconnectTimer.addEventListener(TimerEvent.TIMER, reconnectChannel);
                            _reconnectTimer.start();
                        };
                    } else {
                        connectChannel();
                    };
                } else {
                    dispatchEvent(_arg1);
                    faultPendingSends(_arg1);
                };
            } else {
                dispatchEvent(_arg1);
                if (_arg1.rejected){
                    faultPendingSends(_arg1);
                };
            };
            _shouldHunt = true;
        }
        public function removeChannel(_arg1:Channel):void{
            var _local3:String;
            if (configured){
                _local3 = resourceManager.getString("messaging", "cannotRemoveWhenConfigured");
                throw (new IllegalOperationError(_local3));
            };
            var _local2:int = _channels.indexOf(_arg1);
            if (_local2 > -1){
                _channels.splice(_local2, 1);
                if (((!((_currentChannel == null))) && ((_currentChannel == _arg1)))){
                    if (connected){
                        _shouldHunt = false;
                        disconnectChannel();
                    };
                    _currentChannel = null;
                    _currentChannelIndex = -1;
                };
            };
        }
        public function get heartbeatInterval():int{
            return (_heartbeatInterval);
        }
        public function channelConnectHandler(_arg1:ChannelEvent):void{
            var _local3:PendingSend;
            var _local4:CommandMessage;
            var _local5:AcknowledgeMessage;
            _connecting = false;
            _connected = true;
            _currentChannelIndex = -1;
            while (_pendingSends.length > 0) {
                _local3 = PendingSend(_pendingSends.shift());
                delete _pendingMessages[_local3.message];
                _local4 = (_local3.message as CommandMessage);
                if (_local4 != null){
                    if (_local4.operation == CommandMessage.TRIGGER_CONNECT_OPERATION){
                        _local5 = new AcknowledgeMessage();
                        _local5.clientId = _local3.agent.clientId;
                        _local5.correlationId = _local4.messageId;
                        _local3.agent.acknowledge(_local5, _local4);
                        continue;
                    };
                    if (((((!(_local3.agent.configRequested)) && (_local3.agent.needsConfig))) && ((_local4.operation == CommandMessage.CLIENT_PING_OPERATION)))){
                        _local4.headers[CommandMessage.NEEDS_CONFIG_HEADER] = true;
                        _local3.agent.configRequested = true;
                    };
                };
                send(_local3.agent, _local3.message);
            };
            if (_hunting){
                _arg1.reconnecting = true;
                _hunting = false;
            };
            dispatchEvent(_arg1);
            var _local2:PropertyChangeEvent = PropertyChangeEvent.createUpdateEvent(this, "connected", false, true);
            dispatchEvent(_local2);
        }
        public function get initialDestinationId():String{
            return (_initialDestinationId);
        }
        public function connect(_arg1:MessageAgent):void{
            if (((!((_arg1 == null))) && ((_messageAgents.indexOf(_arg1) == -1)))){
                _shouldBeConnected = true;
                _messageAgents.push(_arg1);
                _arg1.internalSetChannelSet(this);
                addEventListener(ChannelEvent.CONNECT, _arg1.channelConnectHandler);
                addEventListener(ChannelEvent.DISCONNECT, _arg1.channelDisconnectHandler);
                addEventListener(ChannelFaultEvent.FAULT, _arg1.channelFaultHandler);
                if (((connected) && (!(_arg1.needsConfig)))){
                    _arg1.channelConnectHandler(ChannelEvent.createEvent(ChannelEvent.CONNECT, _currentChannel, false, false, connected));
                };
            };
        }
        public function channelFaultHandler(_arg1:ChannelFaultEvent):void{
            if (_arg1.channel.connected){
                dispatchEvent(_arg1);
            } else {
                _connecting = false;
                setConnected(false);
                if (((((_shouldBeConnected) && (!(_arg1.reconnecting)))) && (!(_arg1.rejected)))){
                    if (hunt()){
                        _arg1.reconnecting = true;
                        dispatchEvent(_arg1);
                        if ((_currentChannel is NetConnectionChannel)){
                            if (_reconnectTimer == null){
                                _reconnectTimer = new Timer(1, 1);
                                _reconnectTimer.addEventListener(TimerEvent.TIMER, reconnectChannel);
                                _reconnectTimer.start();
                            };
                        } else {
                            connectChannel();
                        };
                    } else {
                        dispatchEvent(_arg1);
                        faultPendingSends(_arg1);
                    };
                } else {
                    dispatchEvent(_arg1);
                    if (_arg1.rejected){
                        faultPendingSends(_arg1);
                    };
                };
            };
        }
        mx_internal function setAuthenticated(_arg1:Boolean, _arg2:String, _arg3:Boolean=true):void{
            var _local4:PropertyChangeEvent;
            var _local5:MessageAgent;
            var _local6:int;
            if (_authenticated != _arg1){
                _local4 = PropertyChangeEvent.createUpdateEvent(this, "authenticated", _authenticated, _arg1);
                _authenticated = _arg1;
                if (_arg3){
                    _local6 = 0;
                    while (_local6 < _messageAgents.length) {
                        _local5 = MessageAgent(_messageAgents[_local6]);
                        _local5.setAuthenticated(_arg1, _arg2);
                        _local6++;
                    };
                };
                dispatchEvent(_local4);
            };
        }
        protected function sendHeartbeatHandler(_arg1:TimerEvent):void{
            unscheduleHeartbeat();
            if (currentChannel != null){
                sendHeartbeat();
                scheduleHeartbeat();
            };
        }
        private function dispatchRPCEvent(_arg1:AbstractEvent):void{
            _arg1.callTokenResponders();
            dispatchEvent(_arg1);
        }
        mx_internal function authenticationSuccess(_arg1:AuthenticationAgent, _arg2:AsyncToken, _arg3:AcknowledgeMessage):void{
            var _local8:int;
            var _local9:int;
            var _local4:CommandMessage = CommandMessage(_arg2.message);
            var _local5 = (_local4.operation == CommandMessage.LOGIN_OPERATION);
            var _local6:String = ((_local5) ? String(_local4.body) : null);
            if (_local5){
                _credentials = _local6;
                _local8 = _messageAgents.length;
                _local9 = 0;
                while (_local9 < _local8) {
                    _messageAgents[_local9].internalSetCredentials(_local6);
                    _local9++;
                };
                _local8 = _channels.length;
                _local9 = 0;
                while (_local9 < _local8) {
                    if (_channels[_local9] != null){
                        _channels[_local9].internalSetCredentials(_local6);
                    };
                    _local9++;
                };
                _arg1.state = AuthenticationAgent.LOGGED_IN_STATE;
                currentChannel.setAuthenticated(true);
            } else {
                _arg1.state = AuthenticationAgent.SHUTDOWN_STATE;
                _authAgent = null;
                disconnect(_arg1);
                currentChannel.setAuthenticated(false);
            };
            var _local7:ResultEvent = ResultEvent.createEvent(_arg3.body, _arg2, _arg3);
            dispatchRPCEvent(_local7);
        }
        public function disconnectAll():void{
            disconnect(null);
        }
        public function get messageAgents():Array{
            return (_messageAgents);
        }
        mx_internal function set channelFailoverURIs(_arg1:Object):void{
            var _local4:Channel;
            _channelFailoverURIs = _arg1;
            var _local2:int = _channels.length;
            var _local3:int;
            while (_local3 < _local2) {
                _local4 = _channels[_local3];
                if (_local4 == null){
                    break;
                };
                if (_channelFailoverURIs[_local4.id] != null){
                    _local4.failoverURIs = _channelFailoverURIs[_local4.id];
                };
                _local3++;
            };
        }
        mx_internal function authenticationFailure(_arg1:AuthenticationAgent, _arg2:AsyncToken, _arg3:ErrorMessage):void{
            var _local4:MessageFaultEvent = MessageFaultEvent.createEvent(_arg3);
            var _local5:FaultEvent = FaultEvent.createEventFromMessageFault(_local4, _arg2);
            _arg1.state = AuthenticationAgent.SHUTDOWN_STATE;
            _authAgent = null;
            disconnect(_arg1);
            dispatchRPCEvent(_local5);
        }
        override public function toString():String{
            var _local1 = "[ChannelSet ";
            var _local2:uint;
            while (_local2 < _channels.length) {
                if (_channels[_local2] != null){
                    _local1 = (_local1 + (_channels[_local2].id + " "));
                };
                _local2++;
            };
            _local1 = (_local1 + "]");
            return (_local1);
        }

    }
}//package mx.messaging 

import mx.rpc.*;
import mx.collections.*;
import mx.messaging.messages.*;
import mx.messaging.events.*;
import mx.logging.*;

class AuthenticationAgent extends MessageAgent {

    public static const LOGGING_OUT_STATE:int = 3;
    public static const LOGGED_OUT_STATE:int = 0;
    public static const LOGGED_IN_STATE:int = 2;
    public static const LOGGING_IN_STATE:int = 1;
    public static const SHUTDOWN_STATE:int = 4;

    private var _state:int = 0;
    private var tokens:Object;

    public function AuthenticationAgent(_arg1:ChannelSet){
        tokens = {};
        super();
        _log = Log.getLogger("ChannelSet.AuthenticationAgent");
        _agentType = "authentication agent";
        this.channelSet = _arg1;
    }
    public function get state():int{
        return (_state);
    }
    public function registerToken(_arg1:AsyncToken):void{
        tokens[_arg1.message.messageId] = _arg1;
    }
    public function set state(_arg1:int):void{
        _state = _arg1;
        if (_arg1 == SHUTDOWN_STATE){
            tokens = null;
        };
    }
    override public function acknowledge(_arg1:AcknowledgeMessage, _arg2:IMessage):void{
        var _local4:AsyncToken;
        if (state == SHUTDOWN_STATE){
            return;
        };
        var _local3:Boolean = _arg1.headers[AcknowledgeMessage.ERROR_HINT_HEADER];
        super.acknowledge(_arg1, _arg2);
        if (!_local3){
            _local4 = tokens[_arg2.messageId];
            delete tokens[_arg2.messageId];
            channelSet.authenticationSuccess(this, _local4, (_arg1 as AcknowledgeMessage));
        };
    }
    override public function fault(_arg1:ErrorMessage, _arg2:IMessage):void{
        var _local4:AcknowledgeMessage;
        if (state == SHUTDOWN_STATE){
            return;
        };
        if ((((_arg1.rootCause is ChannelEvent)) && (((_arg1.rootCause as ChannelEvent).type == ChannelEvent.DISCONNECT)))){
            _local4 = new AcknowledgeMessage();
            _local4.clientId = clientId;
            _local4.correlationId = _arg2.messageId;
            acknowledge(_local4, _arg2);
            return;
        };
        super.fault(_arg1, _arg2);
        var _local3:AsyncToken = tokens[_arg2.messageId];
        delete tokens[_arg2.messageId];
        channelSet.authenticationFailure(this, _local3, (_arg1 as ErrorMessage));
    }

}
class PendingSend {

    public var agent:MessageAgent;
    public var message:IMessage;

    public function PendingSend(_arg1:MessageAgent, _arg2:IMessage){
        this.agent = _arg1;
        this.message = _arg2;
    }
}
class ClusterMessageResponder extends MessageResponder {

    private var _channelSet:ChannelSet;

    public function ClusterMessageResponder(_arg1:IMessage, _arg2:ChannelSet){
        super(null, _arg1);
        _channelSet = _arg2;
    }
    override protected function resultHandler(_arg1:IMessage):void{
        var _local2:Object;
        var _local3:Array;
        var _local4:int;
        var _local5:int;
        var _local6:Object;
        var _local7:Object;
        if (((!((_arg1.body == null))) && ((((_arg1.body is Array)) || ((_arg1.body is ArrayCollection)))))){
            _local2 = {};
            _local3 = (((_arg1.body is Array)) ? (_arg1.body as Array) : (_arg1.body as ArrayCollection).toArray());
            _local4 = _local3.length;
            _local5 = 0;
            while (_local5 < _local4) {
                _local6 = _local3[_local5];
                for (_local7 in _local6) {
                    if (_local2[_local7] == null){
                        _local2[_local7] = [];
                    };
                    _local2[_local7].push(_local6[_local7]);
                };
                _local5++;
            };
            _channelSet.channelFailoverURIs = _local2;
        };
    }

}
﻿package mx.messaging {
    import flash.events.*;
    import mx.rpc.*;
    import mx.events.*;
    import flash.utils.*;
    import mx.collections.*;
    import mx.messaging.messages.*;
    import mx.messaging.events.*;
    import mx.resources.*;
    import mx.logging.*;
    import mx.utils.*;
    import mx.messaging.config.*;
    import mx.core.*;
    import mx.messaging.errors.*;
    import flash.errors.*;

    public class Channel extends EventDispatcher implements IMXMLObject {

        private static const ENABLE_SMALL_MESSAGES:String = "enable-small-messages";
        private static const FALSE:String = "false";
        private static const RECORD_MESSAGE_SIZES:String = "record-message-sizes";
        private static const TRUE:String = "true";
        private static const REQUEST_TIMEOUT_SECONDS:String = "request-timeout-seconds";
        private static const CONNECT_TIMEOUT_SECONDS:String = "connect-timeout-seconds";
        private static const CLIENT_LOAD_BALANCING:String = "client-load-balancing";
        private static const SERIALIZATION:String = "serialization";
        private static const RECORD_MESSAGE_TIMES:String = "record-message-times";
        public static const SMALL_MESSAGES_FEATURE:String = "small_messages";
        private static const dep:ArrayCollection = null;

        private var _failoverIndex:int;
        private var _ownsWaitGuard:Boolean;
        protected var _recordMessageTimes:Boolean = false;
        private var _reconnecting:Boolean = false;
        private var _reliableReconnectLastTimestamp:Number;
        private var _reliableReconnectAttempts:int;
        private var _authenticated:Boolean = false;
        protected var messagingVersion:Number = 1;
        private var _channelSets:Array;
        private var _connectTimeout:int = -1;
        mx_internal var authenticating:Boolean;
        protected var _connecting:Boolean;
        private var _connectTimer:Timer;
        protected var _recordMessageSizes:Boolean = false;
        private var _failoverURIs:Array;
        protected var _log:ILogger;
        private var _connected:Boolean = false;
        private var _smallMessagesSupported:Boolean;
        private var _primaryURI:String;
        public var enableSmallMessages:Boolean = true;
        private var _id:String;
        private var _reliableReconnectBeginTimestamp:Number;
        private var resourceManager:IResourceManager;
        private var _uri:String;
        protected var _loginAfterDisconnect:Boolean = false;
        private var _isEndpointCalculated:Boolean;
        mx_internal var reliableReconnectDuration:int = -1;
        private var _shouldBeConnected:Boolean;
        private var _previouslyConnected:Boolean;
        private var _requestTimeout:int = -1;
        private var _endpoint:String;
        protected var credentials:String;

        public function Channel(_arg1:String=null, _arg2:String=null){
            resourceManager = ResourceManager.getInstance();
            _channelSets = [];
            super();
            _log = Log.getLogger("mx.messaging.Channel");
            _failoverIndex = -1;
            this.id = _arg1;
            _primaryURI = _arg2;
            this.uri = _arg2;
        }
        private function shuffle(_arg1:Array):void{
            var _local4:int;
            var _local5:Object;
            var _local2:int = _arg1.length;
            var _local3:int;
            while (_local3 < _local2) {
                _local4 = Math.floor((Math.random() * _local2));
                if (_local4 != _local3){
                    _local5 = _arg1[_local3];
                    _arg1[_local3] = _arg1[_local4];
                    _arg1[_local4] = _local5;
                };
                _local3++;
            };
        }
        public function get connected():Boolean{
            return (_connected);
        }
        private function shutdownConnectTimer():void{
            if (_connectTimer != null){
                _connectTimer.stop();
                _connectTimer.removeEventListener(TimerEvent.TIMER, connectTimeoutHandler);
                _connectTimer = null;
            };
        }
        public function get connectTimeout():int{
            return (_connectTimeout);
        }
        public function get id():String{
            return (_id);
        }
        private function calculateEndpoint():void{
            var _local3:String;
            if (uri == null){
                _local3 = resourceManager.getString("messaging", "noURLSpecified");
                throw (new InvalidChannelError(_local3));
            };
            var _local1:String = uri;
            var _local2:String = URLUtil.getProtocol(_local1);
            if (_local2.length == 0){
                _local1 = URLUtil.getFullURL(LoaderConfig.url, _local1);
            };
            if (!URLUtil.hasUnresolvableTokens()){
                _isEndpointCalculated = false;
                return;
            };
            _local1 = URLUtil.replaceTokens(_local1);
            _local2 = URLUtil.getProtocol(_local1);
            if (_local2.length > 0){
                _endpoint = URLUtil.replaceProtocol(_local1, protocol);
            } else {
                _endpoint = ((protocol + ":") + _local1);
            };
            _isEndpointCalculated = true;
            if (Log.isInfo()){
                _log.info("'{0}' channel endpoint set to {1}", id, _endpoint);
            };
        }
        public function get reconnecting():Boolean{
            return (_reconnecting);
        }
        public function get useSmallMessages():Boolean{
            return (((_smallMessagesSupported) && (enableSmallMessages)));
        }
        public function set connectTimeout(_arg1:int):void{
            _connectTimeout = _arg1;
        }
        public function get authenticated():Boolean{
            return (_authenticated);
        }
        protected function getMessageResponder(_arg1:MessageAgent, _arg2:IMessage):MessageResponder{
            throw (new IllegalOperationError(("Channel subclasses must override " + " getMessageResponder().")));
        }
        public function set failoverURIs(_arg1:Array):void{
            if (_arg1 != null){
                _failoverURIs = _arg1;
                _failoverIndex = -1;
            };
        }
        protected function internalDisconnect(_arg1:Boolean=false):void{
        }
        public function setCredentials(_arg1:String, _arg2:MessageAgent=null, _arg3:String=null):void{
            var _local5:CommandMessage;
            var _local4 = !((this.credentials === _arg1));
            if (((authenticating) && (_local4))){
                throw (new IllegalOperationError("Credentials cannot be set while authenticating or logging out."));
            };
            if (((authenticated) && (_local4))){
                throw (new IllegalOperationError("Credentials cannot be set when already authenticated. Logout must be performed before changing credentials."));
            };
            this.credentials = _arg1;
            if (((((connected) && (_local4))) && (!((_arg1 == null))))){
                authenticating = true;
                _local5 = new CommandMessage();
                _local5.operation = CommandMessage.LOGIN_OPERATION;
                _local5.body = _arg1;
                if (_arg3 != null){
                    _local5.headers[CommandMessage.CREDENTIALS_CHARSET_HEADER] = _arg3;
                };
                internalSend(new AuthenticationMessageResponder(_arg2, _local5, this, _log));
            };
        }
        public function set id(_arg1:String):void{
            if (_id != _arg1){
                _id = _arg1;
            };
        }
        public function get mpiEnabled():Boolean{
            return (((_recordMessageSizes) || (_recordMessageTimes)));
        }
        protected function applyClientLoadBalancingSettings(_arg1:XML):void{
            var _local5:XML;
            var _local2:XMLList = _arg1[CLIENT_LOAD_BALANCING];
            if (_local2.length() == 0){
                return;
            };
            var _local3:int = _local2.url.length();
            if (_local3 == 0){
                return;
            };
            var _local4:Array = new Array();
            for each (_local5 in _local2.url) {
                _local4.push(_local5.toString());
            };
            shuffle(_local4);
            if (Log.isInfo()){
                _log.info("'{0}' channel picked {1} as its main url.", id, _local4[0]);
            };
            this.url = _local4[0];
            var _local6:Array = _local4.slice(1);
            if (_local6.length > 0){
                this.failoverURIs = _local6;
            };
        }
        protected function setFlexClientIdOnMessage(_arg1:IMessage):void{
            var _local2:String = FlexClient.getInstance().id;
            _arg1.headers[AbstractMessage.FLEX_CLIENT_ID_HEADER] = ((_local2)!=null) ? _local2 : FlexClient.NULL_FLEXCLIENT_ID;
        }
        protected function connectTimeoutHandler(_arg1:TimerEvent):void{
            var _local2:String;
            var _local3:ChannelFaultEvent;
            shutdownConnectTimer();
            if (!connected){
                _shouldBeConnected = false;
                _local2 = resourceManager.getString("messaging", "connectTimedOut");
                _local3 = ChannelFaultEvent.createEvent(this, false, "Channel.Connect.Failed", "error", _local2);
                connectFailed(_local3);
            };
        }
        protected function flexClientWaitHandler(_arg1:PropertyChangeEvent):void{
            var _local2:FlexClient;
            if (_arg1.property == "waitForFlexClientId"){
                _local2 = (_arg1.source as FlexClient);
                if (_local2.waitForFlexClientId == false){
                    _local2.removeEventListener(PropertyChangeEvent.PROPERTY_CHANGE, flexClientWaitHandler);
                    _local2.waitForFlexClientId = true;
                    _ownsWaitGuard = true;
                    internalConnect();
                };
            };
        }
        protected function get shouldBeConnected():Boolean{
            return (_shouldBeConnected);
        }
        public function set useSmallMessages(_arg1:Boolean):void{
            _smallMessagesSupported = _arg1;
        }
        mx_internal function internalSetCredentials(_arg1:String):void{
            this.credentials = _arg1;
        }
        private function reconnect(_arg1:TimerEvent=null):void{
            internalConnect();
        }
        private function connectCleanup():void{
            if (_ownsWaitGuard){
                _ownsWaitGuard = false;
                FlexClient.getInstance().waitForFlexClientId = false;
            };
            _connecting = false;
            setReconnecting(false);
            reliableReconnectCleanup();
        }
        mx_internal function get realtime():Boolean{
            return (false);
        }
        protected function internalConnect():void{
        }
        public function get url():String{
            return (uri);
        }
        public function get recordMessageTimes():Boolean{
            return (_recordMessageTimes);
        }
        public function get uri():String{
            return (_uri);
        }
        private function initializeRequestTimeout(_arg1:MessageResponder):void{
            var _local2:IMessage = _arg1.message;
            if (_local2.headers[AbstractMessage.REQUEST_TIMEOUT_HEADER] != null){
                _arg1.startRequestTimeout(_local2.headers[AbstractMessage.REQUEST_TIMEOUT_HEADER]);
            } else {
                if (requestTimeout > 0){
                    _arg1.startRequestTimeout(requestTimeout);
                };
            };
        }
        public function send(_arg1:MessageAgent, _arg2:IMessage):void{
            var _local4:String;
            if (_arg2.destination.length == 0){
                if (_arg1.destination.length == 0){
                    _local4 = resourceManager.getString("messaging", "noDestinationSpecified");
                    throw (new InvalidDestinationError(_local4));
                };
                _arg2.destination = _arg1.destination;
            };
            if (Log.isDebug()){
                _log.debug("'{0}' channel sending message:\n{1}", id, _arg2.toString());
            };
            _arg2.headers[AbstractMessage.ENDPOINT_HEADER] = id;
            var _local3:MessageResponder = getMessageResponder(_arg1, _arg2);
            initializeRequestTimeout(_local3);
            internalSend(_local3);
        }
        public function logout(_arg1:MessageAgent):void{
            var _local2:CommandMessage;
            if (((((((connected) && (authenticated))) && (credentials))) || (((authenticating) && (credentials))))){
                _local2 = new CommandMessage();
                _local2.operation = CommandMessage.LOGOUT_OPERATION;
                internalSend(new AuthenticationMessageResponder(_arg1, _local2, this, _log));
                authenticating = true;
            };
            credentials = null;
        }
        public function get endpoint():String{
            if (!_isEndpointCalculated){
                calculateEndpoint();
            };
            return (_endpoint);
        }
        public function get protocol():String{
            throw (new IllegalOperationError((("Channel subclasses must override " + "the get function for 'protocol' to return the proper protocol ") + "string.")));
        }
        public function get failoverURIs():Array{
            return (((_failoverURIs)!=null) ? _failoverURIs : []);
        }
        final public function disconnect(_arg1:ChannelSet):void{
            if (_ownsWaitGuard){
                _ownsWaitGuard = false;
                FlexClient.getInstance().waitForFlexClientId = false;
            };
            var _local2:int = ((_arg1)!=null) ? _channelSets.indexOf(_arg1) : -1;
            if (_local2 != -1){
                _channelSets.splice(_local2, 1);
                removeEventListener(ChannelEvent.CONNECT, _arg1.channelConnectHandler, false);
                removeEventListener(ChannelEvent.DISCONNECT, _arg1.channelDisconnectHandler, false);
                removeEventListener(ChannelFaultEvent.FAULT, _arg1.channelFaultHandler, false);
                if (connected){
                    _arg1.channelDisconnectHandler(ChannelEvent.createEvent(ChannelEvent.DISCONNECT, this, false));
                };
                if (_channelSets.length == 0){
                    _shouldBeConnected = false;
                    if (connected){
                        internalDisconnect();
                    };
                };
            };
        }
        public function set requestTimeout(_arg1:int):void{
            _requestTimeout = _arg1;
        }
        private function shouldAttemptFailover():Boolean{
            return (((_shouldBeConnected) && (((((_previouslyConnected) || (!((reliableReconnectDuration == -1))))) || (((!((_failoverURIs == null))) && ((_failoverURIs.length > 0))))))));
        }
        private function setReconnecting(_arg1:Boolean):void{
            var _local2:PropertyChangeEvent;
            if (_reconnecting != _arg1){
                _local2 = PropertyChangeEvent.createUpdateEvent(this, "reconnecting", _reconnecting, _arg1);
                _reconnecting = _arg1;
                dispatchEvent(_local2);
            };
        }
        public function applySettings(_arg1:XML):void{
            var _local2:XML;
            var _local3:XMLList;
            if (Log.isInfo()){
                _log.info("'{0}' channel settings are:\n{1}", id, _arg1);
            };
            if (_arg1.properties.length() != 0){
                _local2 = _arg1.properties[0];
                applyClientLoadBalancingSettings(_local2);
                if (_local2[CONNECT_TIMEOUT_SECONDS].length() != 0){
                    connectTimeout = _local2[CONNECT_TIMEOUT_SECONDS].toString();
                };
                if (_local2[RECORD_MESSAGE_TIMES].length() != 0){
                    _recordMessageTimes = (_local2[RECORD_MESSAGE_TIMES].toString() == TRUE);
                };
                if (_local2[RECORD_MESSAGE_SIZES].length() != 0){
                    _recordMessageSizes = (_local2[RECORD_MESSAGE_SIZES].toString() == TRUE);
                };
                if (_local2[REQUEST_TIMEOUT_SECONDS].length() != 0){
                    requestTimeout = _local2[REQUEST_TIMEOUT_SECONDS].toString();
                };
                _local3 = _local2[SERIALIZATION];
                if (((!((_local3.length() == 0))) && ((_local3[ENABLE_SMALL_MESSAGES].toString() == FALSE)))){
                    enableSmallMessages = false;
                };
            };
        }
        private function reliableReconnectCleanup():void{
            reliableReconnectDuration = -1;
            _reliableReconnectBeginTimestamp = 0;
            _reliableReconnectLastTimestamp = 0;
            _reliableReconnectAttempts = 0;
        }
        protected function connectSuccess():void{
            var _local1:int;
            var _local2:Array;
            var _local3:int;
            shutdownConnectTimer();
            if (ServerConfig.fetchedConfig(endpoint)){
                _local1 = 0;
                while (_local1 < channelSets.length) {
                    _local2 = ChannelSet(channelSets[_local1]).messageAgents;
                    _local3 = 0;
                    while (_local3 < _local2.length) {
                        _local2[_local3].needsConfig = false;
                        _local3++;
                    };
                    _local1++;
                };
            };
            setConnected(true);
            _failoverIndex = -1;
            if (Log.isInfo()){
                _log.info("'{0}' channel is connected.", id);
            };
            dispatchEvent(ChannelEvent.createEvent(ChannelEvent.CONNECT, this, reconnecting));
            connectCleanup();
        }
        public function get recordMessageSizes():Boolean{
            return (_recordMessageSizes);
        }
        protected function setConnected(_arg1:Boolean):void{
            var _local2:PropertyChangeEvent;
            if (_connected != _arg1){
                if (_connected){
                    _previouslyConnected = true;
                };
                _local2 = PropertyChangeEvent.createUpdateEvent(this, "connected", _connected, _arg1);
                _connected = _arg1;
                dispatchEvent(_local2);
                if (!_arg1){
                    setAuthenticated(false);
                };
            };
        }
        public function get requestTimeout():int{
            return (_requestTimeout);
        }
        protected function connectFailed(_arg1:ChannelFaultEvent):void{
            shutdownConnectTimer();
            setConnected(false);
            if (Log.isError()){
                _log.error("'{0}' channel connect failed.", id);
            };
            if (((!(_arg1.rejected)) && (shouldAttemptFailover()))){
                _connecting = true;
                failover();
            } else {
                connectCleanup();
            };
            if (reconnecting){
                _arg1.reconnecting = true;
            };
            dispatchEvent(_arg1);
        }
        public function set uri(_arg1:String):void{
            if (_arg1 != null){
                _uri = _arg1;
                calculateEndpoint();
            };
        }
        public function initialized(_arg1:Object, _arg2:String):void{
            this.id = _arg2;
        }
        public function set url(_arg1:String):void{
            uri = _arg1;
        }
        protected function disconnectSuccess(_arg1:Boolean=false):void{
            setConnected(false);
            if (Log.isInfo()){
                _log.info("'{0}' channel disconnected.", id);
            };
            if (((!(_arg1)) && (shouldAttemptFailover()))){
                _connecting = true;
                failover();
            } else {
                connectCleanup();
            };
            dispatchEvent(ChannelEvent.createEvent(ChannelEvent.DISCONNECT, this, reconnecting, _arg1));
        }
        protected function internalSend(_arg1:MessageResponder):void{
        }
        mx_internal function sendInternalMessage(_arg1:MessageResponder):void{
            internalSend(_arg1);
        }
        final public function connect(_arg1:ChannelSet):void{
            var _local5:FlexClient;
            var _local2:Boolean;
            var _local3:int = _channelSets.length;
            var _local4:int;
            while (_local4 < _channelSets.length) {
                if (_channelSets[_local4] == _arg1){
                    _local2 = true;
                    break;
                };
                _local4++;
            };
            _shouldBeConnected = true;
            if (!_local2){
                _channelSets.push(_arg1);
                addEventListener(ChannelEvent.CONNECT, _arg1.channelConnectHandler);
                addEventListener(ChannelEvent.DISCONNECT, _arg1.channelDisconnectHandler);
                addEventListener(ChannelFaultEvent.FAULT, _arg1.channelFaultHandler);
            };
            if (connected){
                _arg1.channelConnectHandler(ChannelEvent.createEvent(ChannelEvent.CONNECT, this, false, false, connected));
            } else {
                if (!_connecting){
                    _connecting = true;
                    if (connectTimeout > 0){
                        _connectTimer = new Timer((connectTimeout * 1000), 1);
                        _connectTimer.addEventListener(TimerEvent.TIMER, connectTimeoutHandler);
                        _connectTimer.start();
                    };
                    if (FlexClient.getInstance().id == null){
                        _local5 = FlexClient.getInstance();
                        if (!_local5.waitForFlexClientId){
                            _local5.waitForFlexClientId = true;
                            _ownsWaitGuard = true;
                            internalConnect();
                        } else {
                            _local5.addEventListener(PropertyChangeEvent.PROPERTY_CHANGE, flexClientWaitHandler);
                        };
                    } else {
                        internalConnect();
                    };
                };
            };
        }
        private function resetToPrimaryURI():void{
            _connecting = false;
            setReconnecting(false);
            uri = _primaryURI;
            _failoverIndex = -1;
        }
        mx_internal function setAuthenticated(_arg1:Boolean):void{
            var _local2:PropertyChangeEvent;
            var _local3:ChannelSet;
            var _local4:int;
            if (_arg1 != _authenticated){
                _local2 = PropertyChangeEvent.createUpdateEvent(this, "authenticated", _authenticated, _arg1);
                _authenticated = _arg1;
                _local4 = 0;
                while (_local4 < _channelSets.length) {
                    _local3 = ChannelSet(_channelSets[_local4]);
                    _local3.setAuthenticated(authenticated, credentials);
                    _local4++;
                };
                dispatchEvent(_local2);
            };
        }
        protected function handleServerMessagingVersion(_arg1:Number):void{
            useSmallMessages = (_arg1 >= messagingVersion);
        }
        mx_internal function get loginAfterDisconnect():Boolean{
            return (_loginAfterDisconnect);
        }
        private function failover():void{
            var acs:* = null;
            var duration:* = 0;
            var channelSet:* = null;
            var d:* = 0;
            var remaining:* = NaN;
            var delay:* = 0;
            if (_previouslyConnected){
                _previouslyConnected = false;
                acs = null;
                try {
                    acs = (getDefinitionByName("mx.messaging.AdvancedChannelSet") as Class);
                } catch(ignore:Error) {
                };
                duration = -1;
                if (acs != null){
                    for each (channelSet in channelSets) {
                        if ((channelSet is acs)){
                            d = (channelSet as acs)["reliableReconnectDuration"];
                            if (d > duration){
                                duration = d;
                            };
                        };
                    };
                };
                if (duration != -1){
                    setReconnecting(true);
                    reliableReconnectDuration = duration;
                    _reliableReconnectBeginTimestamp = new Date().valueOf();
                    new AsyncDispatcher(reconnect, null, 1);
                    return;
                };
            };
            if (reliableReconnectDuration != -1){
                _reliableReconnectLastTimestamp = new Date().valueOf();
                remaining = (reliableReconnectDuration - (_reliableReconnectLastTimestamp - _reliableReconnectBeginTimestamp));
                if (remaining > 0){
                    delay = 1000;
                    (delay << ++_reliableReconnectAttempts);
                    if (delay < remaining){
                        new AsyncDispatcher(reconnect, null, delay);
                        return;
                    };
                };
                reliableReconnectCleanup();
            };
            _failoverIndex++;
            if ((_failoverIndex + 1) <= failoverURIs.length){
                setReconnecting(true);
                uri = failoverURIs[_failoverIndex];
                if (Log.isInfo()){
                    _log.info("'{0}' channel attempting to connect to {1}.", id, endpoint);
                };
                new AsyncDispatcher(reconnect, null, 1);
            } else {
                if (Log.isInfo()){
                    _log.info("'{0}' channel has exhausted failover options and has reset to its primary endpoint.", id);
                };
                resetToPrimaryURI();
            };
        }
        public function get channelSets():Array{
            return (_channelSets);
        }
        protected function disconnectFailed(_arg1:ChannelFaultEvent):void{
            _connecting = false;
            setConnected(false);
            if (Log.isError()){
                _log.error("'{0}' channel disconnect failed.", id);
            };
            if (reconnecting){
                resetToPrimaryURI();
                _arg1.reconnecting = false;
            };
            dispatchEvent(_arg1);
        }

    }
}//package mx.messaging 

import mx.messaging.messages.*;
import mx.messaging.events.*;
import mx.logging.*;

class AuthenticationMessageResponder extends MessageResponder {

    private var _log:ILogger;

    public function AuthenticationMessageResponder(_arg1:MessageAgent, _arg2:IMessage, _arg3:Channel, _arg4:ILogger){
        super(_arg1, _arg2, _arg3);
        _log = _arg4;
    }
    override protected function statusHandler(_arg1:IMessage):void{
        var _local3:ErrorMessage;
        var _local4:ChannelFaultEvent;
        var _local2:CommandMessage = CommandMessage(message);
        if (Log.isDebug()){
            _log.debug("{1} failure: {0}", _arg1.toString(), (((_local2.operation == CommandMessage.LOGIN_OPERATION)) ? "Login" : "Logout"));
        };
        channel.authenticating = false;
        channel.setAuthenticated(false);
        if (((!((agent == null))) && (agent.hasPendingRequestForMessage(message)))){
            agent.fault(ErrorMessage(_arg1), message);
        } else {
            _local3 = ErrorMessage(_arg1);
            _local4 = ChannelFaultEvent.createEvent(channel, false, "Channel.Authentication.Error", "warn", _local3.faultString);
            _local4.rootCause = _local3;
            channel.dispatchEvent(_local4);
        };
    }
    override protected function resultHandler(_arg1:IMessage):void{
        var _local2:CommandMessage = (message as CommandMessage);
        channel.authenticating = false;
        if (_local2.operation == CommandMessage.LOGIN_OPERATION){
            if (Log.isDebug()){
                _log.debug("Login successful");
            };
            channel.setAuthenticated(true);
        } else {
            if (Log.isDebug()){
                _log.debug("Logout successful");
            };
            channel.setAuthenticated(false);
        };
    }

}
﻿package mx.messaging {
    import mx.events.*;
    import mx.messaging.messages.*;
    import mx.logging.*;

    public class Producer extends AbstractProducer {

        public static const DEFAULT_PRIORITY:int = 4;

        private var _subtopic:String = "";

        public function Producer(){
            _log = Log.getLogger("mx.messaging.Producer");
            _agentType = "producer";
        }
        override protected function internalSend(_arg1:IMessage, _arg2:Boolean=true):void{
            if (subtopic.length > 0){
                _arg1.headers[AsyncMessage.SUBTOPIC_HEADER] = subtopic;
            };
            handlePriority(_arg1);
            super.internalSend(_arg1, _arg2);
        }
        private function handlePriority(_arg1:IMessage):void{
            var _local2:int;
            if (_arg1.headers[AbstractMessage.PRIORITY_HEADER] != null){
                _local2 = _arg1.headers[AbstractMessage.PRIORITY_HEADER];
                if (_local2 < 0){
                    _arg1.headers[AbstractMessage.PRIORITY_HEADER] = 0;
                } else {
                    if (_local2 > 9){
                        _arg1.headers[AbstractMessage.PRIORITY_HEADER] = 9;
                    };
                };
            } else {
                if (priority > -1){
                    _arg1.headers[AbstractMessage.PRIORITY_HEADER] = priority;
                };
            };
        }
        public function set subtopic(_arg1:String):void{
            var _local2:PropertyChangeEvent;
            if (_subtopic != _arg1){
                if (_arg1 == null){
                    _arg1 = "";
                };
                _local2 = PropertyChangeEvent.createUpdateEvent(this, "subtopic", _subtopic, _arg1);
                _subtopic = _arg1;
                dispatchEvent(_local2);
            };
        }
        public function get subtopic():String{
            return (_subtopic);
        }

    }
}//package mx.messaging 
﻿package mx.messaging {
    import flash.utils.*;
    import mx.messaging.events.*;
    import mx.logging.*;

    public class ConsumerMessageDispatcher {

        private static var _instance:ConsumerMessageDispatcher;

        private const _consumerDuplicateMessageBarrier:Object;
        private const _channelSetRefCounts:Dictionary;
        private const _consumers:Object;

        public function ConsumerMessageDispatcher(){
            _consumers = {};
            _channelSetRefCounts = new Dictionary();
            _consumerDuplicateMessageBarrier = {};
            super();
        }
        public static function getInstance():ConsumerMessageDispatcher{
            if (!_instance){
                _instance = new (ConsumerMessageDispatcher)();
            };
            return (_instance);
        }

        public function registerSubscription(_arg1:AbstractConsumer):void{
            _consumers[_arg1.clientId] = _arg1;
            if (_channelSetRefCounts[_arg1.channelSet] == null){
                _arg1.channelSet.addEventListener(MessageEvent.MESSAGE, messageHandler);
                _channelSetRefCounts[_arg1.channelSet] = 1;
            } else {
                var _local2 = _channelSetRefCounts;
                var _local3 = _arg1.channelSet;
                var _local4 = (_local2[_local3] + 1);
                _local2[_local3] = _local4;
            };
        }
        private function messageHandler(_arg1:MessageEvent):void{
            var _local3:int;
            var _local4:ChannelSet;
            var _local5:Array;
            var _local2:AbstractConsumer = _consumers[_arg1.message.clientId];
            if (_local2 == null){
                if (Log.isDebug()){
                    Log.getLogger("mx.messaging.Consumer").debug("'{0}' received pushed message for consumer but no longer subscribed: {1}", _arg1.message.clientId, _arg1.message);
                };
                return;
            };
            if (_arg1.target.currentChannel.channelSets.length > 1){
                _local3 = 0;
                for each (_local4 in _arg1.target.currentChannel.channelSets) {
                    if (_channelSetRefCounts[_local4] != null){
                        _local3++;
                    };
                };
                if (_local3 > 1){
                    if (_consumerDuplicateMessageBarrier[_local2.id] == null){
                        _consumerDuplicateMessageBarrier[_local2.id] = [_arg1.messageId, _local3];
                        _local2.messageHandler(_arg1);
                    };
                    _local5 = _consumerDuplicateMessageBarrier[_local2.id];
                    if (_local5[0] == _arg1.messageId){
                        var _local6 = _local5;
                        var _local7 = 1;
                        var _local8 = (_local6[_local7] - 1);
                        _local6[_local7] = _local8;
                        if (_local8 == 0){
                            delete _consumerDuplicateMessageBarrier[_local2.id];
                        };
                    };
                    return;
                };
            };
            _local2.messageHandler(_arg1);
        }
        public function unregisterSubscription(_arg1:AbstractConsumer):void{
            delete _consumers[_arg1.clientId];
            var _local2:int = _channelSetRefCounts[_arg1.channelSet];
            --_local2;
            if (_local2 == 0){
                _arg1.channelSet.removeEventListener(MessageEvent.MESSAGE, messageHandler);
                delete _channelSetRefCounts[_arg1.channelSet];
                if (_consumerDuplicateMessageBarrier[_arg1.id] != null){
                    delete _consumerDuplicateMessageBarrier[_arg1.id];
                };
            } else {
                _channelSetRefCounts[_arg1.channelSet] = _local2;
            };
        }
        public function isChannelUsedForSubscriptions(_arg1:Channel):Boolean{
            var _local2:Array = _arg1.channelSets;
            var _local3:ChannelSet;
            var _local4:int = _local2.length;
            var _local5:int;
            while (_local5 < _local4) {
                _local3 = _local2[_local5];
                if (((!((_channelSetRefCounts[_local3] == null))) && ((_local3.currentChannel == _arg1)))){
                    return (true);
                };
                _local5++;
            };
            return (false);
        }

    }
}//package mx.messaging 
﻿package mx.messaging.messages {

    public class MessagePerformanceUtils {

        public static const MPI_HEADER_PUSH:String = "DSMPIP";
        public static const MPI_HEADER_OUT:String = "DSMPIO";
        public static const MPI_HEADER_IN:String = "DSMPII";

        public var mpii:MessagePerformanceInfo;
        public var mpio:MessagePerformanceInfo;
        public var mpip:MessagePerformanceInfo;

        public function MessagePerformanceUtils(_arg1:Object):void{
            this.mpii = (_arg1.headers[MPI_HEADER_IN] as MessagePerformanceInfo);
            this.mpio = (_arg1.headers[MPI_HEADER_OUT] as MessagePerformanceInfo);
            if ((((mpio == null)) || ((((mpii == null)) && ((_arg1.headers[MPI_HEADER_PUSH] == null)))))){
                throw (new Error("Message is missing MPI headers.  Verify that all participants have it enabled."));
            };
            if (pushedMessageFlag){
                this.mpip = (_arg1.headers[MPI_HEADER_PUSH] as MessagePerformanceInfo);
            };
        }
        public function get serverPollDelay():Number{
            if (mpip == null){
                return (0);
            };
            if ((((mpip.serverPrePushTime == 0)) || ((mpio.sendTime == 0)))){
                return (0);
            };
            return ((mpio.sendTime - mpip.serverPrePushTime));
        }
        public function get clientReceiveTime():Number{
            return (mpio.receiveTime);
        }
        public function get serverPrePushTime():Number{
            if (mpii == null){
                return (0);
            };
            if (mpii.serverPrePushTime == 0){
                return (serverProcessingTime);
            };
            return ((mpii.serverPrePushTime - mpii.receiveTime));
        }
        public function get pushOneWayTime():Number{
            return ((clientReceiveTime - serverSendTime));
        }
        public function prettyPrint():String{
            var _local1:String = new String("");
            if (messageSize != 0){
                _local1 = (_local1 + (("Original message size(B): " + messageSize) + "\n"));
            };
            if (responseMessageSize != 0){
                _local1 = (_local1 + (("Response message size(B): " + responseMessageSize) + "\n"));
            };
            if (totalTime != 0){
                _local1 = (_local1 + (("Total time (s): " + (totalTime / 1000)) + "\n"));
            };
            if (networkRTT != 0){
                _local1 = (_local1 + (("Network Roundtrip time (s): " + (networkRTT / 1000)) + "\n"));
            };
            if (serverProcessingTime != 0){
                _local1 = (_local1 + (("Server processing time (s): " + (serverProcessingTime / 1000)) + "\n"));
            };
            if (serverAdapterTime != 0){
                _local1 = (_local1 + (("Server adapter time (s): " + (serverAdapterTime / 1000)) + "\n"));
            };
            if (serverNonAdapterTime != 0){
                _local1 = (_local1 + (("Server non-adapter time (s): " + (serverNonAdapterTime / 1000)) + "\n"));
            };
            if (serverAdapterExternalTime != 0){
                _local1 = (_local1 + (("Server adapter external time (s): " + (serverAdapterExternalTime / 1000)) + "\n"));
            };
            if (pushedMessageFlag){
                _local1 = (_local1 + "PUSHED MESSAGE INFORMATION:\n");
                if (totalPushTime != 0){
                    _local1 = (_local1 + (("Total push time (s): " + (totalPushTime / 1000)) + "\n"));
                };
                if (pushOneWayTime != 0){
                    _local1 = (_local1 + (("Push one way time (s): " + (pushOneWayTime / 1000)) + "\n"));
                };
                if (originatingMessageSize != 0){
                    _local1 = (_local1 + (("Originating Message size (B): " + originatingMessageSize) + "\n"));
                };
                if (serverPollDelay != 0){
                    _local1 = (_local1 + (("Server poll delay (s): " + (serverPollDelay / 1000)) + "\n"));
                };
            };
            return (_local1);
        }
        public function get serverSendTime():Number{
            return (mpio.sendTime);
        }
        public function get serverNonAdapterTime():Number{
            return ((serverProcessingTime - serverAdapterTime));
        }
        public function get pushedMessageFlag():Boolean{
            return (mpio.pushedFlag);
        }
        public function get originatingMessageSentTime():Number{
            return (mpip.sendTime);
        }
        public function get serverProcessingTime():Number{
            if (pushedMessageFlag){
                return ((mpip.serverPrePushTime - mpip.receiveTime));
            };
            return ((mpio.sendTime - mpii.receiveTime));
        }
        public function get serverAdapterExternalTime():Number{
            if (pushedMessageFlag){
                if (mpip == null){
                    return (0);
                };
                if ((((mpip.serverPreAdapterExternalTime == 0)) || ((mpip.serverPostAdapterExternalTime == 0)))){
                    return (0);
                };
                return ((mpip.serverPostAdapterExternalTime - mpip.serverPreAdapterExternalTime));
            };
            if (mpii == null){
                return (0);
            };
            if ((((mpii.serverPreAdapterExternalTime == 0)) || ((mpii.serverPostAdapterExternalTime == 0)))){
                return (0);
            };
            return ((mpii.serverPostAdapterExternalTime - mpii.serverPreAdapterExternalTime));
        }
        public function get responseMessageSize():int{
            return (mpio.messageSize);
        }
        public function get messageSize():int{
            if (mpii == null){
                return (0);
            };
            return (mpii.messageSize);
        }
        public function get networkRTT():Number{
            if (!pushedMessageFlag){
                return ((totalTime - serverProcessingTime));
            };
            return (0);
        }
        public function get totalTime():Number{
            if (mpii == null){
                return (0);
            };
            return ((mpio.receiveTime - mpii.sendTime));
        }
        public function get totalPushTime():Number{
            return (((clientReceiveTime - originatingMessageSentTime) - pushedOverheadTime));
        }
        public function get serverAdapterTime():Number{
            if (pushedMessageFlag){
                if (mpip == null){
                    return (0);
                };
                if ((((mpip.serverPreAdapterTime == 0)) || ((mpip.serverPostAdapterTime == 0)))){
                    return (0);
                };
                return ((mpip.serverPostAdapterTime - mpip.serverPreAdapterTime));
            };
            if (mpii == null){
                return (0);
            };
            if ((((mpii.serverPreAdapterTime == 0)) || ((mpii.serverPostAdapterTime == 0)))){
                return (0);
            };
            return ((mpii.serverPostAdapterTime - mpii.serverPreAdapterTime));
        }
        private function get pushedOverheadTime():Number{
            return (mpip.overheadTime);
        }
        public function get originatingMessageSize():Number{
            return (mpip.messageSize);
        }

    }
}//package mx.messaging.messages 
﻿package mx.messaging.messages {

    public class ErrorMessage extends AcknowledgeMessage {

        public static const RETRYABLE_HINT_HEADER:String = "DSRetryableErrorHint";
        public static const MESSAGE_DELIVERY_IN_DOUBT:String = "Client.Error.DeliveryInDoubt";

        public var faultString:String;
        public var extendedData:Object;
        public var rootCause:Object;
        public var faultCode:String;
        public var faultDetail:String;

        override public function getSmallMessage():IMessage{
            return (null);
        }

    }
}//package mx.messaging.messages 
﻿package mx.messaging.messages {

    public interface IMessage {

        function get body():Object;
        function set messageId(_arg1:String):void;
        function get clientId():String;
        function set timeToLive(_arg1:Number):void;
        function get messageId():String;
        function set body(_arg1:Object):void;
        function set timestamp(_arg1:Number):void;
        function get headers():Object;
        function get destination():String;
        function set clientId(_arg1:String):void;
        function get timeToLive():Number;
        function get timestamp():Number;
        function toString():String;
        function set headers(_arg1:Object):void;
        function set destination(_arg1:String):void;

    }
}//package mx.messaging.messages 
﻿package mx.messaging.messages {

    public class HTTPRequestMessage extends AbstractMessage {

        public static const POST_METHOD:String = "POST";
        public static const CONTENT_TYPE_SOAP_XML:String = "text/xml; charset=utf-8";
        public static const CONTENT_TYPE_FORM:String = "application/x-www-form-urlencoded";
        public static const GET_METHOD:String = "GET";
        public static const HEAD_METHOD:String = "HEAD";
        public static const PUT_METHOD:String = "PUT";
        public static const TRACE_METHOD:String = "TRACE";
        public static const DELETE_METHOD:String = "DELETE";
        public static const CONTENT_TYPE_XML:String = "application/xml";
        public static const OPTIONS_METHOD:String = "OPTIONS";
        private static const VALID_METHODS:String = "POST,PUT,GET,HEAD,DELETE,OPTIONS,TRACE";

        private var _method:String;
        public var httpHeaders:Object;
        public var url:String;
        public var contentType:String;
        public var recordHeaders:Boolean;

        public function HTTPRequestMessage(){
            _method = GET_METHOD;
        }
        public function get method():String{
            return (_method);
        }
        public function set method(_arg1:String):void{
            _method = _arg1;
        }

    }
}//package mx.messaging.messages 
﻿package mx.messaging.messages {
    import flash.utils.*;

    public class CommandMessage extends AsyncMessage {

        public static const SUBSCRIBE_OPERATION:uint = 0;
        public static const MAX_FREQUENCY_HEADER:String = "DSMaxFrequency";
        private static const OPERATION_FLAG:uint = 1;
        public static const CLIENT_SYNC_OPERATION:uint = 4;
        public static const POLL_WAIT_HEADER:String = "DSPollWait";
        public static const ADD_SUBSCRIPTIONS:String = "DSAddSub";
        public static const SUBSCRIPTION_INVALIDATE_OPERATION:uint = 10;
        public static const TRIGGER_CONNECT_OPERATION:uint = 13;
        public static const CLIENT_PING_OPERATION:uint = 5;
        public static const UNSUBSCRIBE_OPERATION:uint = 1;
        public static const CREDENTIALS_CHARSET_HEADER:String = "DSCredentialsCharset";
        public static const AUTHENTICATION_MESSAGE_REF_TYPE:String = "flex.messaging.messages.AuthenticationMessage";
        public static const POLL_OPERATION:uint = 2;
        public static const MULTI_SUBSCRIBE_OPERATION:uint = 11;
        public static const LOGIN_OPERATION:uint = 8;
        public static const CLUSTER_REQUEST_OPERATION:uint = 7;
        public static const HEARTBEAT_HEADER:String = "DS<3";
        public static const LOGOUT_OPERATION:uint = 9;
        public static const REMOVE_SUBSCRIPTIONS:String = "DSRemSub";
        public static const MESSAGING_VERSION:String = "DSMessagingVersion";
        public static const NEEDS_CONFIG_HEADER:String = "DSNeedsConfig";
        public static const SELECTOR_HEADER:String = "DSSelector";
        public static const UNKNOWN_OPERATION:uint = 10000;
        public static const PRESERVE_DURABLE_HEADER:String = "DSPreserveDurable";
        public static const NO_OP_POLL_HEADER:String = "DSNoOpPoll";
        public static const SUBTOPIC_SEPARATOR:String = "_;_";
        public static const DISCONNECT_OPERATION:uint = 12;

        private static var operationTexts:Object = null;

        public var operation:uint;

        public function CommandMessage(){
            operation = UNKNOWN_OPERATION;
        }
        public static function getOperationAsString(_arg1:uint):String{
            if (operationTexts == null){
                operationTexts = {};
                operationTexts[SUBSCRIBE_OPERATION] = "subscribe";
                operationTexts[UNSUBSCRIBE_OPERATION] = "unsubscribe";
                operationTexts[POLL_OPERATION] = "poll";
                operationTexts[CLIENT_SYNC_OPERATION] = "client sync";
                operationTexts[CLIENT_PING_OPERATION] = "client ping";
                operationTexts[CLUSTER_REQUEST_OPERATION] = "cluster request";
                operationTexts[LOGIN_OPERATION] = "login";
                operationTexts[LOGOUT_OPERATION] = "logout";
                operationTexts[SUBSCRIPTION_INVALIDATE_OPERATION] = "subscription invalidate";
                operationTexts[MULTI_SUBSCRIBE_OPERATION] = "multi-subscribe";
                operationTexts[DISCONNECT_OPERATION] = "disconnect";
                operationTexts[TRIGGER_CONNECT_OPERATION] = "trigger connect";
                operationTexts[UNKNOWN_OPERATION] = "unknown";
            };
            var _local2:* = operationTexts[_arg1];
            return ((((_local2 == undefined)) ? _arg1.toString() : String(_local2)));
        }

        override public function readExternal(_arg1:IDataInput):void{
            var _local4:uint;
            var _local5:uint;
            var _local6:uint;
            super.readExternal(_arg1);
            var _local2:Array = readFlags(_arg1);
            var _local3:uint;
            while (_local3 < _local2.length) {
                _local4 = (_local2[_local3] as uint);
                _local5 = 0;
                if (_local3 == 0){
                    if ((_local4 & OPERATION_FLAG) != 0){
                        operation = (_arg1.readObject() as uint);
                    };
                    _local5 = 1;
                };
                if ((_local4 >> _local5) != 0){
                    _local6 = _local5;
                    while (_local6 < 6) {
                        if (((_local4 >> _local6) & 1) != 0){
                            _arg1.readObject();
                        };
                        _local6++;
                    };
                };
                _local3++;
            };
        }
        override protected function addDebugAttributes(_arg1:Object):void{
            super.addDebugAttributes(_arg1);
            _arg1["operation"] = getOperationAsString(operation);
        }
        override public function writeExternal(_arg1:IDataOutput):void{
            super.writeExternal(_arg1);
            var _local2:uint;
            if (operation != 0){
                _local2 = (_local2 | OPERATION_FLAG);
            };
            _arg1.writeByte(_local2);
            if (operation != 0){
                _arg1.writeObject(operation);
            };
        }
        override public function toString():String{
            return (getDebugString());
        }
        override public function getSmallMessage():IMessage{
            if (operation == POLL_OPERATION){
                return (new CommandMessageExt(this));
            };
            return (null);
        }

    }
}//package mx.messaging.messages 
﻿package mx.messaging.messages {
    import flash.utils.*;

    public class AcknowledgeMessageExt extends AcknowledgeMessage implements IExternalizable {

        private var _message:AcknowledgeMessage;

        public function AcknowledgeMessageExt(_arg1:AcknowledgeMessage=null){
            _message = _arg1;
        }
        override public function get messageId():String{
            if (_message != null){
                return (_message.messageId);
            };
            return (super.messageId);
        }
        override public function writeExternal(_arg1:IDataOutput):void{
            if (_message != null){
                _message.writeExternal(_arg1);
            } else {
                super.writeExternal(_arg1);
            };
        }

    }
}//package mx.messaging.messages 
﻿package mx.messaging.messages {
    import flash.utils.*;

    public class AsyncMessageExt extends AsyncMessage implements IExternalizable {

        private var _message:AsyncMessage;

        public function AsyncMessageExt(_arg1:AsyncMessage=null){
            _message = _arg1;
        }
        override public function get messageId():String{
            if (_message != null){
                return (_message.messageId);
            };
            return (super.messageId);
        }
        override public function writeExternal(_arg1:IDataOutput):void{
            if (_message != null){
                _message.writeExternal(_arg1);
            } else {
                super.writeExternal(_arg1);
            };
        }

    }
}//package mx.messaging.messages 
﻿package mx.messaging.messages {

    public interface ISmallMessage extends IMessage {

        function getSmallMessage():IMessage;

    }
}//package mx.messaging.messages 
﻿package mx.messaging.messages {
    import flash.utils.*;
    import mx.utils.*;

    public class AbstractMessage implements IMessage {

        public static const FLEX_CLIENT_ID_HEADER:String = "DSId";
        private static const MESSAGE_ID_FLAG:uint = 16;
        public static const PRIORITY_HEADER:String = "DSPriority";
        private static const TIME_TO_LIVE_FLAG:uint = 64;
        private static const TIMESTAMP_FLAG:uint = 32;
        private static const CLIENT_ID_BYTES_FLAG:uint = 1;
        public static const REQUEST_TIMEOUT_HEADER:String = "DSRequestTimeout";
        private static const DESTINATION_FLAG:uint = 4;
        public static const STATUS_CODE_HEADER:String = "DSStatusCode";
        private static const CLIENT_ID_FLAG:uint = 2;
        private static const HEADERS_FLAG:uint = 8;
        private static const BODY_FLAG:uint = 1;
        public static const REMOTE_CREDENTIALS_CHARSET_HEADER:String = "DSRemoteCredentialsCharset";
        private static const MESSAGE_ID_BYTES_FLAG:uint = 2;
        public static const DESTINATION_CLIENT_ID_HEADER:String = "DSDstClientId";
        public static const REMOTE_CREDENTIALS_HEADER:String = "DSRemoteCredentials";
        private static const HAS_NEXT_FLAG:uint = 128;
        public static const ENDPOINT_HEADER:String = "DSEndpoint";

        private var _body:Object;
        private var _messageId:String;
        private var messageIdBytes:ByteArray;
        private var _timestamp:Number = 0;
        private var _clientId:String;
        private var clientIdBytes:ByteArray;
        private var _headers:Object;
        private var _destination:String = "";
        private var _timeToLive:Number = 0;

        public function AbstractMessage(){
            _body = {};
            super();
        }
        public function set messageId(_arg1:String):void{
            _messageId = _arg1;
            messageIdBytes = null;
        }
        public function get headers():Object{
            if (_headers == null){
                _headers = {};
            };
            return (_headers);
        }
        public function readExternal(_arg1:IDataInput):void{
            var _local4:uint;
            var _local5:uint;
            var _local6:uint;
            var _local2:Array = readFlags(_arg1);
            var _local3:uint;
            while (_local3 < _local2.length) {
                _local4 = (_local2[_local3] as uint);
                _local5 = 0;
                if (_local3 == 0){
                    if ((_local4 & BODY_FLAG) != 0){
                        body = _arg1.readObject();
                    } else {
                        body = null;
                    };
                    if ((_local4 & CLIENT_ID_FLAG) != 0){
                        clientId = _arg1.readObject();
                    };
                    if ((_local4 & DESTINATION_FLAG) != 0){
                        destination = (_arg1.readObject() as String);
                    };
                    if ((_local4 & HEADERS_FLAG) != 0){
                        headers = _arg1.readObject();
                    };
                    if ((_local4 & MESSAGE_ID_FLAG) != 0){
                        messageId = (_arg1.readObject() as String);
                    };
                    if ((_local4 & TIMESTAMP_FLAG) != 0){
                        timestamp = (_arg1.readObject() as Number);
                    };
                    if ((_local4 & TIME_TO_LIVE_FLAG) != 0){
                        timeToLive = (_arg1.readObject() as Number);
                    };
                    _local5 = 7;
                } else {
                    if (_local3 == 1){
                        if ((_local4 & CLIENT_ID_BYTES_FLAG) != 0){
                            clientIdBytes = (_arg1.readObject() as ByteArray);
                            clientId = RPCUIDUtil.fromByteArray(clientIdBytes);
                        };
                        if ((_local4 & MESSAGE_ID_BYTES_FLAG) != 0){
                            messageIdBytes = (_arg1.readObject() as ByteArray);
                            messageId = RPCUIDUtil.fromByteArray(messageIdBytes);
                        };
                        _local5 = 2;
                    };
                };
                if ((_local4 >> _local5) != 0){
                    _local6 = _local5;
                    while (_local6 < 6) {
                        if (((_local4 >> _local6) & 1) != 0){
                            _arg1.readObject();
                        };
                        _local6++;
                    };
                };
                _local3++;
            };
        }
        public function get messageId():String{
            if (_messageId == null){
                _messageId = RPCUIDUtil.createUID();
            };
            return (_messageId);
        }
        public function set clientId(_arg1:String):void{
            _clientId = _arg1;
            clientIdBytes = null;
        }
        public function get destination():String{
            return (_destination);
        }
        public function get timestamp():Number{
            return (_timestamp);
        }
        protected function readFlags(_arg1:IDataInput):Array{
            var _local4:uint;
            var _local2:Boolean;
            var _local3:Array = [];
            while (((_local2) && ((_arg1.bytesAvailable > 0)))) {
                _local4 = _arg1.readUnsignedByte();
                _local3.push(_local4);
                if ((_local4 & HAS_NEXT_FLAG) != 0){
                    _local2 = true;
                } else {
                    _local2 = false;
                };
            };
            return (_local3);
        }
        public function set headers(_arg1:Object):void{
            _headers = _arg1;
        }
        public function get body():Object{
            return (_body);
        }
        public function set destination(_arg1:String):void{
            _destination = _arg1;
        }
        public function set timestamp(_arg1:Number):void{
            _timestamp = _arg1;
        }
        protected function addDebugAttributes(_arg1:Object):void{
            _arg1["body"] = body;
            _arg1["clientId"] = clientId;
            _arg1["destination"] = destination;
            _arg1["headers"] = headers;
            _arg1["messageId"] = messageId;
            _arg1["timestamp"] = timestamp;
            _arg1["timeToLive"] = timeToLive;
        }
        public function get timeToLive():Number{
            return (_timeToLive);
        }
        public function set body(_arg1:Object):void{
            _body = _arg1;
        }
        public function get clientId():String{
            return (_clientId);
        }
        public function writeExternal(_arg1:IDataOutput):void{
            var _local2:uint;
            var _local3:String = messageId;
            if (clientIdBytes == null){
                clientIdBytes = RPCUIDUtil.toByteArray(_clientId);
            };
            if (messageIdBytes == null){
                messageIdBytes = RPCUIDUtil.toByteArray(_messageId);
            };
            if (body != null){
                _local2 = (_local2 | BODY_FLAG);
            };
            if (((!((clientId == null))) && ((clientIdBytes == null)))){
                _local2 = (_local2 | CLIENT_ID_FLAG);
            };
            if (destination != null){
                _local2 = (_local2 | DESTINATION_FLAG);
            };
            if (headers != null){
                _local2 = (_local2 | HEADERS_FLAG);
            };
            if (((!((messageId == null))) && ((messageIdBytes == null)))){
                _local2 = (_local2 | MESSAGE_ID_FLAG);
            };
            if (timestamp != 0){
                _local2 = (_local2 | TIMESTAMP_FLAG);
            };
            if (timeToLive != 0){
                _local2 = (_local2 | TIME_TO_LIVE_FLAG);
            };
            if (((!((clientIdBytes == null))) || (!((messageIdBytes == null))))){
                _local2 = (_local2 | HAS_NEXT_FLAG);
            };
            _arg1.writeByte(_local2);
            _local2 = 0;
            if (clientIdBytes != null){
                _local2 = (_local2 | CLIENT_ID_BYTES_FLAG);
            };
            if (messageIdBytes != null){
                _local2 = (_local2 | MESSAGE_ID_BYTES_FLAG);
            };
            if (_local2 != 0){
                _arg1.writeByte(_local2);
            };
            if (body != null){
                _arg1.writeObject(body);
            };
            if (((!((clientId == null))) && ((clientIdBytes == null)))){
                _arg1.writeObject(clientId);
            };
            if (destination != null){
                _arg1.writeObject(destination);
            };
            if (headers != null){
                _arg1.writeObject(headers);
            };
            if (((!((messageId == null))) && ((messageIdBytes == null)))){
                _arg1.writeObject(messageId);
            };
            if (timestamp != 0){
                _arg1.writeObject(timestamp);
            };
            if (timeToLive != 0){
                _arg1.writeObject(timeToLive);
            };
            if (clientIdBytes != null){
                _arg1.writeObject(clientIdBytes);
            };
            if (messageIdBytes != null){
                _arg1.writeObject(messageIdBytes);
            };
        }
        final protected function getDebugString():String{
            var _local4:String;
            var _local5:uint;
            var _local6:String;
            var _local7:String;
            var _local1 = (("(" + getQualifiedClassName(this)) + ")");
            var _local2:Object = {};
            addDebugAttributes(_local2);
            var _local3:Array = [];
            for (_local4 in _local2) {
                _local3.push(_local4);
            };
            _local3.sort();
            _local5 = 0;
            while (_local5 < _local3.length) {
                _local6 = String(_local3[_local5]);
                _local7 = RPCObjectUtil.toString(_local2[_local6]);
                _local1 = (_local1 + RPCStringUtil.substitute("\n  {0}={1}", _local6, _local7));
                _local5++;
            };
            return (_local1);
        }
        public function toString():String{
            return (RPCObjectUtil.toString(this));
        }
        public function set timeToLive(_arg1:Number):void{
            _timeToLive = _arg1;
        }

    }
}//package mx.messaging.messages 
﻿package mx.messaging.messages {
    import flash.utils.*;
    import mx.utils.*;

    public class AsyncMessage extends AbstractMessage implements ISmallMessage {

        private static const CORRELATION_ID_FLAG:uint = 1;
        private static const CORRELATION_ID_BYTES_FLAG:uint = 2;
        public static const SUBTOPIC_HEADER:String = "DSSubtopic";

        private var _correlationId:String;
        private var correlationIdBytes:ByteArray;

        public function AsyncMessage(_arg1:Object=null, _arg2:Object=null){
            correlationId = "";
            if (_arg1 != null){
                this.body = _arg1;
            };
            if (_arg2 != null){
                this.headers = _arg2;
            };
        }
        override protected function addDebugAttributes(_arg1:Object):void{
            super.addDebugAttributes(_arg1);
            _arg1["correlationId"] = correlationId;
        }
        override public function readExternal(_arg1:IDataInput):void{
            var _local4:uint;
            var _local5:uint;
            var _local6:uint;
            super.readExternal(_arg1);
            var _local2:Array = readFlags(_arg1);
            var _local3:uint;
            while (_local3 < _local2.length) {
                _local4 = (_local2[_local3] as uint);
                _local5 = 0;
                if (_local3 == 0){
                    if ((_local4 & CORRELATION_ID_FLAG) != 0){
                        correlationId = (_arg1.readObject() as String);
                    };
                    if ((_local4 & CORRELATION_ID_BYTES_FLAG) != 0){
                        correlationIdBytes = (_arg1.readObject() as ByteArray);
                        correlationId = RPCUIDUtil.fromByteArray(correlationIdBytes);
                    };
                    _local5 = 2;
                };
                if ((_local4 >> _local5) != 0){
                    _local6 = _local5;
                    while (_local6 < 6) {
                        if (((_local4 >> _local6) & 1) != 0){
                            _arg1.readObject();
                        };
                        _local6++;
                    };
                };
                _local3++;
            };
        }
        public function getSmallMessage():IMessage{
            var _local1:Object = this;
            if (_local1.constructor == AsyncMessage){
                return (new AsyncMessageExt(this));
            };
            return (null);
        }
        override public function writeExternal(_arg1:IDataOutput):void{
            super.writeExternal(_arg1);
            if (correlationIdBytes == null){
                correlationIdBytes = RPCUIDUtil.toByteArray(_correlationId);
            };
            var _local2:uint;
            if (((!((correlationId == null))) && ((correlationIdBytes == null)))){
                _local2 = (_local2 | CORRELATION_ID_FLAG);
            };
            if (correlationIdBytes != null){
                _local2 = (_local2 | CORRELATION_ID_BYTES_FLAG);
            };
            _arg1.writeByte(_local2);
            if (((!((correlationId == null))) && ((correlationIdBytes == null)))){
                _arg1.writeObject(correlationId);
            };
            if (correlationIdBytes != null){
                _arg1.writeObject(correlationIdBytes);
            };
        }
        public function set correlationId(_arg1:String):void{
            _correlationId = _arg1;
            correlationIdBytes = null;
        }
        public function get correlationId():String{
            return (_correlationId);
        }

    }
}//package mx.messaging.messages 
﻿package mx.messaging.messages {

    public class MessagePerformanceInfo {

        public var recordMessageSizes:Boolean;
        public var pushedFlag:Boolean;
        public var serverPrePushTime:Number;
        public var receiveTime:Number;
        public var overheadTime:Number;
        public var serverPostAdapterExternalTime:Number;
        private var _infoType:String;
        public var messageSize:int;
        public var serverPreAdapterExternalTime:Number;
        public var recordMessageTimes:Boolean;
        public var sendTime:Number = 0;
        public var serverPostAdapterTime:Number;
        public var serverPreAdapterTime:Number;

        public function get infoType():String{
            return (this._infoType);
        }
        public function set infoType(_arg1:String):void{
            var _local2:Date;
            _infoType = _arg1;
            if (_infoType == "OUT"){
                _local2 = new Date();
                this.receiveTime = _local2.getTime();
            };
        }

    }
}//package mx.messaging.messages 
﻿package mx.messaging.messages {
    import flash.utils.*;

    public class AcknowledgeMessage extends AsyncMessage implements ISmallMessage {

        public static const ERROR_HINT_HEADER:String = "DSErrorHint";

        override public function readExternal(_arg1:IDataInput):void{
            var _local4:uint;
            var _local5:uint;
            var _local6:uint;
            super.readExternal(_arg1);
            var _local2:Array = readFlags(_arg1);
            var _local3:uint;
            while (_local3 < _local2.length) {
                _local4 = (_local2[_local3] as uint);
                _local5 = 0;
                if ((_local4 >> _local5) != 0){
                    _local6 = _local5;
                    while (_local6 < 6) {
                        if (((_local4 >> _local6) & 1) != 0){
                            _arg1.readObject();
                        };
                        _local6++;
                    };
                };
                _local3++;
            };
        }
        override public function writeExternal(_arg1:IDataOutput):void{
            super.writeExternal(_arg1);
            var _local2:uint;
            _arg1.writeByte(_local2);
        }
        override public function getSmallMessage():IMessage{
            var _local1:Object = this;
            if (_local1.constructor == AcknowledgeMessage){
                return (new AcknowledgeMessageExt(this));
            };
            return (null);
        }

    }
}//package mx.messaging.messages 
﻿package mx.messaging.messages {
    import flash.utils.*;

    public class CommandMessageExt extends CommandMessage implements IExternalizable {

        private var _message:CommandMessage;

        public function CommandMessageExt(_arg1:CommandMessage=null){
            _message = _arg1;
        }
        override public function get messageId():String{
            if (_message != null){
                return (_message.messageId);
            };
            return (super.messageId);
        }
        override public function writeExternal(_arg1:IDataOutput):void{
            if (_message != null){
                _message.writeExternal(_arg1);
            } else {
                super.writeExternal(_arg1);
            };
        }

    }
}//package mx.messaging.messages 
﻿package mx.messaging.config {
    import mx.core.*;

    public class LoaderConfig {

        mx_internal static const VERSION:String = "3.5.0.12683";

        mx_internal static var _parameters:Object;
        mx_internal static var _swfVersion:uint;
        mx_internal static var _url:String = null;

        public static function get parameters():Object{
            return (_parameters);
        }
        public static function get url():String{
            return (_url);
        }
        public static function get swfVersion():uint{
            return (_swfVersion);
        }

    }
}//package mx.messaging.config 
﻿package mx.messaging.config {
    import flash.utils.*;
    import mx.collections.*;
    import mx.messaging.*;
    import mx.resources.*;
    import mx.utils.*;
    import mx.core.*;
    import mx.messaging.errors.*;

    public class ServerConfig {

        public static const URI_ATTR:String = "uri";
        public static const CLASS_ATTR:String = "type";

        private static var _resourceManager:IResourceManager;
        private static var _clusteredChannels:Object = {};
        private static var _unclusteredChannels:Object = {};
        private static var _configFetchedChannels:Object;
        public static var channelSetFactory:Class = ChannelSet;
        public static var serverConfigData:XML;
        private static var _channelSets:Object = {};

        public static function getProperties(_arg1:String):XMLList{
            var destination:* = null;
            var message:* = null;
            var destinationId:* = _arg1;
            destination = xml..destination.(@id == destinationId);
            if (destination.length() > 0){
                return (destination.properties);
            };
            message = resourceManager.getString("messaging", "unknownDestination", [destinationId]);
            throw (new InvalidDestinationError(message));
        }
        mx_internal static function getChannelIdList(_arg1:String):Array{
            var _local2:XML = getDestinationConfig(_arg1);
            return (((_local2) ? getChannelIds(_local2) : getDefaultChannelIds()));
        }
        private static function convertToXML(_arg1:ConfigMap, _arg2:XML):void{
            var _local3:Object;
            var _local4:Object;
            var _local5:Array;
            var _local6:int;
            var _local7:XML;
            var _local8:XML;
            for (_local3 in _arg1) {
                _local4 = _arg1[_local3];
                if ((_local4 is String)){
                    if (_local3 == ""){
                        _arg2.appendChild(_local4);
                    } else {
                        _arg2.@[_local3] = _local4;
                    };
                } else {
                    if ((((_local4 is ArrayCollection)) || ((_local4 is Array)))){
                        if ((_local4 is ArrayCollection)){
                            _local5 = ArrayCollection(_local4).toArray();
                        } else {
                            _local5 = (_local4 as Array);
                        };
                        _local6 = 0;
                        while (_local6 < _local5.length) {
                            _local7 = new XML((((("<" + _local3) + "></") + _local3) + ">"));
                            _arg2.appendChild(_local7);
                            convertToXML((_local5[_local6] as ConfigMap), _local7);
                            _local6++;
                        };
                    } else {
                        _local8 = new XML((((("<" + _local3) + "></") + _local3) + ">"));
                        _arg2.appendChild(_local8);
                        convertToXML((_local4 as ConfigMap), _local8);
                    };
                };
            };
        }
        public static function getChannel(_arg1:String, _arg2:Boolean=false):Channel{
            var _local3:Channel;
            if (!_arg2){
                if ((_arg1 in _unclusteredChannels)){
                    return (_unclusteredChannels[_arg1]);
                };
                _local3 = createChannel(_arg1);
                _unclusteredChannels[_arg1] = _local3;
                return (_local3);
            };
            if ((_arg1 in _clusteredChannels)){
                return (_clusteredChannels[_arg1]);
            };
            _local3 = createChannel(_arg1);
            _clusteredChannels[_arg1] = _local3;
            return (_local3);
        }
        mx_internal static function needsConfig(_arg1:Channel):Boolean{
            var _local2:Array;
            var _local3:int;
            var _local4:int;
            var _local5:Array;
            var _local6:int;
            var _local7:int;
            if ((((_configFetchedChannels == null)) || ((_configFetchedChannels[_arg1.endpoint] == null)))){
                _local2 = _arg1.channelSets;
                _local3 = _local2.length;
                _local4 = 0;
                while (_local4 < _local3) {
                    if (getQualifiedClassName(_local2[_local4]).indexOf("Advanced") != -1){
                        return (true);
                    };
                    _local5 = ChannelSet(_local2[_local4]).messageAgents;
                    _local6 = _local5.length;
                    _local7 = 0;
                    while (_local7 < _local6) {
                        if (MessageAgent(_local5[_local7]).needsConfig){
                            return (true);
                        };
                        _local7++;
                    };
                    _local4++;
                };
            };
            return (false);
        }
        public static function getChannelSet(_arg1:String):ChannelSet{
            var _local2:XML = getDestinationConfig(_arg1);
            return (internalGetChannelSet(_local2, _arg1));
        }
        public static function get xml():XML{
            if (serverConfigData == null){
                serverConfigData = <services/>
                ;
            };
            return (serverConfigData);
        }
        mx_internal static function updateServerConfigData(_arg1:ConfigMap, _arg2:String=null):void{
            var newServices:* = null;
            var newService:* = null;
            var newChannels:* = null;
            var oldServices:* = null;
            var oldDestinations:* = null;
            var newDestination:* = null;
            var oldService:* = null;
            var oldChannels:* = null;
            var serverConfig:* = _arg1;
            var endpoint = _arg2;
            if (serverConfig != null){
                if (endpoint != null){
                    if (_configFetchedChannels == null){
                        _configFetchedChannels = {};
                    };
                    _configFetchedChannels[endpoint] = true;
                };
                newServices = <services></services>
                ;
                convertToXML(serverConfig, newServices);
                xml["default-channels"] = newServices["default-channels"];
                for each (newService in newServices..service) {
                    oldServices = xml.service.(@id == newService.@id);
                    if (oldServices.length() != 0){
                        oldService = oldServices[0];
                        for each (newDestination in newService..destination) {
                            oldDestinations = oldService.destination.(@id == newDestination.@id);
                            if (oldDestinations.length() != 0){
                                delete oldDestinations[0];
                            };
                            oldService.appendChild(newDestination.copy());
                        };
                    } else {
                        for each (newDestination in newService..destination) {
                            oldDestinations = xml..destination.(@id == newDestination.@id);
                            if (oldDestinations.length() != 0){
                                oldDestinations[0] = newDestination[0].copy();
                                delete newService..destination.(@id == newDestination.@id)[0];
                            };
                        };
                        if (newService.children().length() > 0){
                            xml.appendChild(newService);
                        };
                    };
                };
                newChannels = newServices.channels;
                if (newChannels.length() > 0){
                    oldChannels = xml.channels[0];
                    if ((((oldChannels == null)) || ((oldChannels.length() == 0)))){
                        xml.appendChild(newChannels);
                    };
                };
            };
        }
        private static function internalGetChannelSet(_arg1:XML, _arg2:String):ChannelSet{
            var _local3:Array;
            var _local4:Boolean;
            var _local6:String;
            var _local7:ChannelSet;
            var _local8:int;
            if (_arg1 == null){
                _local3 = getDefaultChannelIds();
                if (_local3.length == 0){
                    _local6 = resourceManager.getString("messaging", "noChannelForDestination", [_arg2]);
                    throw (new InvalidDestinationError(_local6));
                };
                _local4 = false;
            } else {
                _local3 = getChannelIds(_arg1);
                _local4 = ((_arg1.properties.network.cluster.length())>0) ? true : false;
            };
            var _local5:String = ((_local3.join(",") + ":") + _local4);
            if ((_local5 in _channelSets)){
                return (_channelSets[_local5]);
            };
            _local7 = new channelSetFactory(_local3, _local4);
            _local8 = serverConfigData["flex-client"]["heartbeat-interval-millis"];
            if (_local8 > 0){
                _local7.heartbeatInterval = _local8;
            };
            if (_local4){
                _local7.initialDestinationId = _arg2;
            };
            _channelSets[_local5] = _local7;
            return (_local7);
        }
        private static function getDefaultChannelIds():Array{
            var _local1:Array = [];
            var _local2:XMLList = xml["default-channels"].channel;
            var _local3:int = _local2.length();
            var _local4:int;
            while (_local4 < _local3) {
                _local1.push(_local2[_local4].@ref.toString());
                _local4++;
            };
            return (_local1);
        }
        private static function createChannel(_arg1:String):Channel{
            var message:* = null;
            var channels:* = null;
            var channelConfig:* = null;
            var className:* = null;
            var endpoint:* = null;
            var uri:* = null;
            var channel:* = null;
            var channelClass:* = null;
            var channelId:* = _arg1;
            channels = xml.channels.channel.(@id == channelId);
            if (channels.length() == 0){
                message = resourceManager.getString("messaging", "unknownChannelWithId", [channelId]);
                throw (new InvalidChannelError(message));
            };
            channelConfig = channels[0];
            className = channelConfig.attribute(CLASS_ATTR).toString();
            endpoint = channelConfig.endpoint;
            uri = (((endpoint.length() > 0)) ? endpoint[0].attribute(URI_ATTR).toString() : null);
            channel = null;
            try {
                channelClass = (getDefinitionByName(className) as Class);
                channel = new channelClass(channelId, uri);
                channel.applySettings(channelConfig);
                if (((!((LoaderConfig.parameters == null))) && (!((LoaderConfig.parameters.WSRP_ENCODED_CHANNEL == null))))){
                    channel.url = LoaderConfig.parameters.WSRP_ENCODED_CHANNEL;
                };
            } catch(e:ReferenceError) {
                message = resourceManager.getString("messaging", "unknownChannelClass", [className]);
                throw (new InvalidChannelError(message));
            };
            return (channel);
        }
        public static function set xml(_arg1:XML):void{
            serverConfigData = _arg1;
            _channelSets = {};
            _clusteredChannels = {};
            _unclusteredChannels = {};
        }
        private static function getChannelIds(_arg1:XML):Array{
            var _local2:Array = [];
            var _local3:XMLList = _arg1.channels.channel;
            var _local4:int = _local3.length();
            var _local5:int;
            while (_local5 < _local4) {
                _local2.push(_local3[_local5].@ref.toString());
                _local5++;
            };
            return (_local2);
        }
        private static function getDestinationConfig(_arg1:String):XML{
            var destinations:* = null;
            var destinationCount:* = 0;
            var destinationId:* = _arg1;
            destinations = xml..destination.(@id == destinationId);
            destinationCount = destinations.length();
            if (destinationCount == 0){
                return (null);
            };
            return (destinations[0]);
        }
        mx_internal static function fetchedConfig(_arg1:String):Boolean{
            return (((!((_configFetchedChannels == null))) && (!((_configFetchedChannels[_arg1] == null)))));
        }
        mx_internal static function channelSetMatchesDestinationConfig(_arg1:ChannelSet, _arg2:String):Boolean{
            var csUris:* = null;
            var csChannels:* = null;
            var i:* = 0;
            var ids:* = null;
            var dsUris:* = null;
            var dsChannels:* = null;
            var channelConfig:* = null;
            var endpoint:* = null;
            var dsUri:* = null;
            var j:* = 0;
            var channelSet:* = _arg1;
            var destination:* = _arg2;
            if (channelSet != null){
                if (ObjectUtil.compare(channelSet.channelIds, getChannelIdList(destination)) == 0){
                    return (true);
                };
                csUris = [];
                csChannels = channelSet.channels;
                i = 0;
                while (i < csChannels.length) {
                    csUris.push(csChannels[i].uri);
                    i = (i + 1);
                };
                ids = getChannelIdList(destination);
                dsUris = [];
                j = 0;
                while (j < ids.length) {
                    dsChannels = xml.channels.channel.(@id == ids[j]);
                    channelConfig = dsChannels[0];
                    endpoint = channelConfig.endpoint;
                    dsUri = (((endpoint.length() > 0)) ? endpoint[0].attribute(URI_ATTR).toString() : null);
                    if (dsUri != null){
                        dsUris.push(dsUri);
                    };
                    j = (j + 1);
                };
                return ((ObjectUtil.compare(csUris, dsUris) == 0));
            };
            return (false);
        }
        public static function checkChannelConsistency(_arg1:String, _arg2:String):void{
            var _local3:Array = getChannelIdList(_arg1);
            var _local4:Array = getChannelIdList(_arg2);
            if (ObjectUtil.compare(_local3, _local4) != 0){
                throw (new ArgumentError("Specified destinations are not channel consistent"));
            };
        }
        private static function get resourceManager():IResourceManager{
            if (!_resourceManager){
                _resourceManager = ResourceManager.getInstance();
            };
            return (_resourceManager);
        }

    }
}//package mx.messaging.config 
﻿package mx.messaging.config {
    import flash.utils.*;
    import mx.utils.*;

    public dynamic class ConfigMap extends Proxy {

        private var _item:Object;
        object_proxy var propertyList:Array;

        public function ConfigMap(_arg1:Object=null){
            if (!_arg1){
                _arg1 = {};
            };
            _item = _arg1;
            propertyList = [];
        }
        override "http://www.adobe.com/2006/actionscript/flash/proxy"?? function deleteProperty(_arg1):Boolean{
            var _local2:Object = _item[_arg1];
            var _local3 = delete _item[_arg1];
            var _local4 = -1;
            var _local5:int;
            while (_local5 < propertyList.length) {
                if (propertyList[_local5] == _arg1){
                    _local4 = _local5;
                    break;
                };
                _local5++;
            };
            if (_local4 > -1){
                propertyList.splice(_local4, 1);
            };
            return (_local3);
        }
        override "http://www.adobe.com/2006/actionscript/flash/proxy"?? function nextName(_arg1:int):String{
            return (propertyList[(_arg1 - 1)]);
        }
        override "http://www.adobe.com/2006/actionscript/flash/proxy"?? function getProperty(_arg1){
            var _local2:Object;
            _local2 = _item[_arg1];
            return (_local2);
        }
        override "http://www.adobe.com/2006/actionscript/flash/proxy"?? function hasProperty(_arg1):Boolean{
            return ((_arg1 in _item));
        }
        override "http://www.adobe.com/2006/actionscript/flash/proxy"?? function nextNameIndex(_arg1:int):int{
            if (_arg1 < propertyList.length){
                return ((_arg1 + 1));
            };
            return (0);
        }
        override "http://www.adobe.com/2006/actionscript/flash/proxy"?? function setProperty(_arg1, _arg2):void{
            var _local4:int;
            var _local3:* = _item[_arg1];
            if (_local3 !== _arg2){
                _item[_arg1] = _arg2;
                _local4 = 0;
                while (_local4 < propertyList.length) {
                    if (propertyList[_local4] == _arg1){
                        return;
                    };
                    _local4++;
                };
                propertyList.push(_arg1);
            };
        }
        override "http://www.adobe.com/2006/actionscript/flash/proxy"?? function callProperty(_arg1, ... _args){
            return (_item[_arg1].apply(_item, _args));
        }
        override "http://www.adobe.com/2006/actionscript/flash/proxy"?? function nextValue(_arg1:int){
            return (_item[propertyList[(_arg1 - 1)]]);
        }

    }
}//package mx.messaging.config 
﻿package mx.messaging {
    import flash.events.*;
    import mx.events.*;
    import flash.utils.*;
    import mx.messaging.messages.*;
    import mx.messaging.events.*;
    import mx.resources.*;
    import mx.logging.*;
    import mx.core.*;

    public class AbstractProducer extends MessageAgent {

        private var _priority:int = -1;
        private var _reconnectInterval:int;
        private var _autoConnect:Boolean = true;
        private var _reconnectTimer:Timer;
        protected var _shouldBeConnected:Boolean;
        private var _connectMsg:CommandMessage;
        private var _defaultHeaders:Object;
        private var _currentAttempt:int;
        private var _reconnectAttempts:int;
        private var resourceManager:IResourceManager;

        public function AbstractProducer(){
            resourceManager = ResourceManager.getInstance();
            super();
        }
        public function set reconnectAttempts(_arg1:int):void{
            var _local2:PropertyChangeEvent;
            if (_reconnectAttempts != _arg1){
                if (_arg1 == 0){
                    stopReconnectTimer();
                };
                _local2 = PropertyChangeEvent.createUpdateEvent(this, "reconnectAttempts", _reconnectAttempts, _arg1);
                _reconnectAttempts = _arg1;
                dispatchEvent(_local2);
            };
        }
        public function get defaultHeaders():Object{
            return (_defaultHeaders);
        }
        public function set reconnectInterval(_arg1:int):void{
            var _local2:PropertyChangeEvent;
            var _local3:String;
            if (_reconnectInterval != _arg1){
                if (_arg1 < 0){
                    _local3 = resourceManager.getString("messaging", "reconnectIntervalNegative");
                    throw (new ArgumentError(_local3));
                };
                if (_arg1 == 0){
                    stopReconnectTimer();
                } else {
                    if (_reconnectTimer != null){
                        _reconnectTimer.delay = _arg1;
                    };
                };
                _local2 = PropertyChangeEvent.createUpdateEvent(this, "reconnectInterval", _reconnectInterval, _arg1);
                _reconnectInterval = _arg1;
                dispatchEvent(_local2);
            };
        }
        public function set defaultHeaders(_arg1:Object):void{
            var _local2:PropertyChangeEvent;
            if (_defaultHeaders != _arg1){
                _local2 = PropertyChangeEvent.createUpdateEvent(this, "defaultHeaders", _defaultHeaders, _arg1);
                _defaultHeaders = _arg1;
                dispatchEvent(_local2);
            };
        }
        public function set priority(_arg1:int):void{
            var _local2:PropertyChangeEvent;
            if (_priority != _arg1){
                _arg1 = (((_arg1 < 0)) ? 0 : (((_arg1 > 9)) ? 9 : _arg1));
                _local2 = PropertyChangeEvent.createUpdateEvent(this, "priority", _priority, _arg1);
                _priority = _arg1;
                dispatchEvent(_local2);
            };
        }
        protected function stopReconnectTimer():void{
            if (_reconnectTimer != null){
                if (Log.isDebug()){
                    _log.debug("'{0}' {1} stopping reconnect timer.", id, _agentType);
                };
                _reconnectTimer.removeEventListener(TimerEvent.TIMER, reconnect);
                _reconnectTimer.reset();
                _reconnectTimer = null;
            };
        }
        override public function channelDisconnectHandler(_arg1:ChannelEvent):void{
            super.channelDisconnectHandler(_arg1);
            if (((_shouldBeConnected) && (!(_arg1.rejected)))){
                startReconnectTimer();
            };
        }
        public function send(_arg1:IMessage):void{
            var _local2:String;
            var _local3:ErrorMessage;
            if (((!(connected)) && (autoConnect))){
                _shouldBeConnected = true;
            };
            if (defaultHeaders != null){
                for (_local2 in defaultHeaders) {
                    if (!_arg1.headers.hasOwnProperty(_local2)){
                        _arg1.headers[_local2] = defaultHeaders[_local2];
                    };
                };
            };
            if (((!(connected)) && (!(autoConnect)))){
                _shouldBeConnected = false;
                _local3 = new ErrorMessage();
                _local3.faultCode = "Client.Error.MessageSend";
                _local3.faultString = resourceManager.getString("messaging", "producerSendError");
                _local3.faultDetail = resourceManager.getString("messaging", "producerSendErrorDetails");
                _local3.correlationId = _arg1.messageId;
                internalFault(_local3, _arg1, false, true);
            } else {
                if (Log.isInfo()){
                    _log.info("'{0}' {1} sending message '{2}'", id, _agentType, _arg1.messageId);
                };
                internalSend(_arg1);
            };
        }
        private function buildConnectErrorMessage():ErrorMessage{
            var _local1:ErrorMessage = new ErrorMessage();
            _local1.faultCode = "Client.Error.Connect";
            _local1.faultString = resourceManager.getString("messaging", "producerConnectError");
            _local1.faultDetail = resourceManager.getString("messaging", "failedToConnect");
            _local1.correlationId = _connectMsg.messageId;
            return (_local1);
        }
        override public function acknowledge(_arg1:AcknowledgeMessage, _arg2:IMessage):void{
            if (_disconnectBarrier){
                return;
            };
            super.acknowledge(_arg1, _arg2);
            if ((((_arg2 is CommandMessage)) && ((CommandMessage(_arg2).operation == CommandMessage.TRIGGER_CONNECT_OPERATION)))){
                stopReconnectTimer();
            };
        }
        public function get reconnectInterval():int{
            return (_reconnectInterval);
        }
        override public function fault(_arg1:ErrorMessage, _arg2:IMessage):void{
            internalFault(_arg1, _arg2);
        }
        override public function disconnect():void{
            _shouldBeConnected = false;
            stopReconnectTimer();
            super.disconnect();
        }
        mx_internal function internalFault(_arg1:ErrorMessage, _arg2:IMessage, _arg3:Boolean=true, _arg4:Boolean=false):void{
            var _local5:ErrorMessage;
            if (((_disconnectBarrier) && (!(_arg4)))){
                return;
            };
            if ((((_arg2 is CommandMessage)) && ((CommandMessage(_arg2).operation == CommandMessage.TRIGGER_CONNECT_OPERATION)))){
                if (_reconnectTimer == null){
                    if (((!((_connectMsg == null))) && ((_arg1.correlationId == _connectMsg.messageId)))){
                        _shouldBeConnected = false;
                        _local5 = buildConnectErrorMessage();
                        _local5.rootCause = _arg1.rootCause;
                        super.fault(_local5, _arg2);
                    } else {
                        super.fault(_arg1, _arg2);
                    };
                };
            } else {
                super.fault(_arg1, _arg2);
            };
        }
        public function connect():void{
            if (!connected){
                _shouldBeConnected = true;
                if (_connectMsg == null){
                    _connectMsg = buildConnectMessage();
                };
                internalSend(_connectMsg, false);
            };
        }
        public function get priority():int{
            return (_priority);
        }
        private function buildConnectMessage():CommandMessage{
            var _local1:CommandMessage = new CommandMessage();
            _local1.operation = CommandMessage.TRIGGER_CONNECT_OPERATION;
            _local1.clientId = clientId;
            _local1.destination = destination;
            return (_local1);
        }
        protected function reconnect(_arg1:TimerEvent):void{
            if (((!((_reconnectAttempts == -1))) && ((_currentAttempt >= _reconnectAttempts)))){
                stopReconnectTimer();
                _shouldBeConnected = false;
                fault(buildConnectErrorMessage(), _connectMsg);
                return;
            };
            if (Log.isDebug()){
                _log.debug("'{0}' {1} trying to reconnect.", id, _agentType);
            };
            _reconnectTimer.delay = _reconnectInterval;
            _currentAttempt++;
            if (_connectMsg == null){
                _connectMsg = buildConnectMessage();
            };
            internalSend(_connectMsg, false);
        }
        protected function startReconnectTimer():void{
            if (((_shouldBeConnected) && ((_reconnectTimer == null)))){
                if (((!((_reconnectAttempts == 0))) && ((_reconnectInterval > 0)))){
                    if (Log.isDebug()){
                        _log.debug("'{0}' {1} starting reconnect timer.", id, _agentType);
                    };
                    _reconnectTimer = new Timer(1);
                    _reconnectTimer.addEventListener(TimerEvent.TIMER, reconnect);
                    _reconnectTimer.start();
                    _currentAttempt = 0;
                };
            };
        }
        override public function channelFaultHandler(_arg1:ChannelFaultEvent):void{
            super.channelFaultHandler(_arg1);
            if (((((_shouldBeConnected) && (!(_arg1.rejected)))) && (!(_arg1.channel.connected)))){
                startReconnectTimer();
            };
        }
        public function set autoConnect(_arg1:Boolean):void{
            var _local2:PropertyChangeEvent;
            if (_autoConnect != _arg1){
                _local2 = PropertyChangeEvent.createUpdateEvent(this, "autoConnect", _autoConnect, _arg1);
                _autoConnect = _arg1;
                dispatchEvent(_local2);
            };
        }
        public function get autoConnect():Boolean{
            return (_autoConnect);
        }
        public function get reconnectAttempts():int{
            return (_reconnectAttempts);
        }

    }
}//package mx.messaging 
﻿package mx.messaging.events {
    import flash.events.*;
    import mx.messaging.messages.*;

    public class MessageAckEvent extends MessageEvent {

        public static const ACKNOWLEDGE:String = "acknowledge";

        public var correlation:IMessage;

        public function MessageAckEvent(_arg1:String, _arg2:Boolean=false, _arg3:Boolean=false, _arg4:AcknowledgeMessage=null, _arg5:IMessage=null){
            super(_arg1, _arg2, _arg3, _arg4);
            this.correlation = _arg5;
        }
        public static function createEvent(_arg1:AcknowledgeMessage=null, _arg2:IMessage=null):MessageAckEvent{
            return (new MessageAckEvent(MessageAckEvent.ACKNOWLEDGE, false, false, _arg1, _arg2));
        }

        public function get acknowledgeMessage():AcknowledgeMessage{
            return ((message as AcknowledgeMessage));
        }
        public function get correlationId():String{
            if (correlation != null){
                return (correlation.messageId);
            };
            return (null);
        }
        override public function clone():Event{
            return (new MessageAckEvent(type, bubbles, cancelable, (message as AcknowledgeMessage), correlation));
        }
        override public function toString():String{
            return (formatToString("MessageAckEvent", "messageId", "correlationId", "type", "bubbles", "cancelable", "eventPhase"));
        }

    }
}//package mx.messaging.events 
﻿package mx.messaging.events {
    import flash.events.*;
    import mx.messaging.messages.*;

    public class MessageFaultEvent extends Event {

        public static const FAULT:String = "fault";

        public var message:ErrorMessage;

        public function MessageFaultEvent(_arg1:String, _arg2:Boolean=false, _arg3:Boolean=false, _arg4:ErrorMessage=null){
            super(_arg1, _arg2, _arg3);
            this.message = _arg4;
        }
        public static function createEvent(_arg1:ErrorMessage):MessageFaultEvent{
            return (new MessageFaultEvent(MessageFaultEvent.FAULT, false, false, _arg1));
        }

        public function get faultString():String{
            return (message.faultString);
        }
        public function get faultDetail():String{
            return (message.faultDetail);
        }
        public function get rootCause():Object{
            return (message.rootCause);
        }
        override public function toString():String{
            return (formatToString("MessageFaultEvent", "faultCode", "faultDetail", "faultString", "rootCause", "type", "bubbles", "cancelable", "eventPhase"));
        }
        override public function clone():Event{
            return (new MessageFaultEvent(type, bubbles, cancelable, message));
        }
        public function get faultCode():String{
            return (message.faultCode);
        }

    }
}//package mx.messaging.events 
﻿package mx.messaging.events {
    import flash.events.*;
    import mx.messaging.*;

    public class ChannelEvent extends Event {

        public static const CONNECT:String = "channelConnect";
        public static const DISCONNECT:String = "channelDisconnect";

        public var channel:Channel;
        public var connected:Boolean;
        public var reconnecting:Boolean;
        public var rejected:Boolean;

        public function ChannelEvent(_arg1:String, _arg2:Boolean=false, _arg3:Boolean=false, _arg4:Channel=null, _arg5:Boolean=false, _arg6:Boolean=false, _arg7:Boolean=false){
            super(_arg1, _arg2, _arg3);
            this.channel = _arg4;
            this.reconnecting = _arg5;
            this.rejected = _arg6;
            this.connected = _arg7;
        }
        public static function createEvent(_arg1:String, _arg2:Channel=null, _arg3:Boolean=false, _arg4:Boolean=false, _arg5:Boolean=false):ChannelEvent{
            return (new ChannelEvent(_arg1, false, false, _arg2, _arg3, _arg4, _arg5));
        }

        override public function toString():String{
            return (formatToString("ChannelEvent", "channelId", "reconnecting", "rejected", "type", "bubbles", "cancelable", "eventPhase"));
        }
        override public function clone():Event{
            return (new ChannelEvent(type, bubbles, cancelable, channel, reconnecting, rejected, connected));
        }
        public function get channelId():String{
            if (channel != null){
                return (channel.id);
            };
            return (null);
        }

    }
}//package mx.messaging.events 
﻿package mx.messaging.events {
    import flash.events.*;
    import mx.messaging.messages.*;

    public class MessageEvent extends Event {

        public static const RESULT:String = "result";
        public static const MESSAGE:String = "message";

        public var message:IMessage;

        public function MessageEvent(_arg1:String, _arg2:Boolean=false, _arg3:Boolean=false, _arg4:IMessage=null){
            super(_arg1, _arg2, _arg3);
            this.message = _arg4;
        }
        public static function createEvent(_arg1:String, _arg2:IMessage):MessageEvent{
            return (new MessageEvent(_arg1, false, false, _arg2));
        }

        public function get messageId():String{
            if (message != null){
                return (message.messageId);
            };
            return (null);
        }
        override public function toString():String{
            return (formatToString("MessageEvent", "messageId", "type", "bubbles", "cancelable", "eventPhase"));
        }
        override public function clone():Event{
            return (new MessageEvent(type, bubbles, cancelable, message));
        }

    }
}//package mx.messaging.events 
﻿package mx.messaging.events {
    import flash.events.*;
    import mx.messaging.messages.*;
    import mx.messaging.*;

    public class ChannelFaultEvent extends ChannelEvent {

        public static const FAULT:String = "channelFault";

        public var faultString:String;
        public var rootCause:Object;
        public var faultDetail:String;
        public var faultCode:String;

        public function ChannelFaultEvent(_arg1:String, _arg2:Boolean=false, _arg3:Boolean=false, _arg4:Channel=null, _arg5:Boolean=false, _arg6:String=null, _arg7:String=null, _arg8:String=null, _arg9:Boolean=false, _arg10:Boolean=false){
            super(_arg1, _arg2, _arg3, _arg4, _arg5, _arg9, _arg10);
            faultCode = _arg6;
            faultString = _arg7;
            faultDetail = _arg8;
        }
        public static function createEvent(_arg1:Channel, _arg2:Boolean=false, _arg3:String=null, _arg4:String=null, _arg5:String=null, _arg6:Boolean=false, _arg7:Boolean=false):ChannelFaultEvent{
            return (new ChannelFaultEvent(ChannelFaultEvent.FAULT, false, false, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7));
        }

        override public function clone():Event{
            var _local1:ChannelFaultEvent = new ChannelFaultEvent(type, bubbles, cancelable, channel, reconnecting, faultCode, faultString, faultDetail, rejected, connected);
            _local1.rootCause = rootCause;
            return (_local1);
        }
        public function createErrorMessage():ErrorMessage{
            var _local1:ErrorMessage = new ErrorMessage();
            _local1.faultCode = faultCode;
            _local1.faultString = faultString;
            _local1.faultDetail = faultDetail;
            _local1.rootCause = rootCause;
            return (_local1);
        }
        override public function toString():String{
            return (formatToString("ChannelFaultEvent", "faultCode", "faultString", "faultDetail", "channelId", "type", "bubbles", "cancelable", "eventPhase"));
        }

    }
}//package mx.messaging.events 
﻿package mx.messaging.errors {

    public class NoChannelAvailableError extends MessagingError {

        public function NoChannelAvailableError(_arg1:String){
            super(_arg1);
        }
    }
}//package mx.messaging.errors 
﻿package mx.messaging.errors {

    public class MessagingError extends Error {

        public function MessagingError(_arg1:String){
            super(_arg1);
        }
        public function toString():String{
            var _local1 = "[MessagingError";
            if (message != null){
                _local1 = (_local1 + ((" message='" + message) + "']"));
            } else {
                _local1 = (_local1 + "]");
            };
            return (_local1);
        }

    }
}//package mx.messaging.errors 
﻿package mx.messaging.errors {

    public class InvalidChannelError extends ChannelError {

        public function InvalidChannelError(_arg1:String){
            super(_arg1);
        }
    }
}//package mx.messaging.errors 
﻿package mx.messaging.errors {

    public class InvalidDestinationError extends ChannelError {

        public function InvalidDestinationError(_arg1:String){
            super(_arg1);
        }
    }
}//package mx.messaging.errors 
﻿package mx.messaging.errors {

    public class ChannelError extends MessagingError {

        public function ChannelError(_arg1:String){
            super(_arg1);
        }
    }
}//package mx.messaging.errors 
﻿package mx.messaging.errors {
    import mx.messaging.messages.*;

    public class MessageSerializationError extends MessagingError {

        public var fault:ErrorMessage;

        public function MessageSerializationError(_arg1:String, _arg2:ErrorMessage){
            super(_arg1);
            this.fault = _arg2;
        }
    }
}//package mx.messaging.errors 
﻿package mx.messaging {
    import flash.events.*;
    import mx.events.*;
    import flash.utils.*;
    import mx.messaging.messages.*;
    import mx.messaging.events.*;
    import mx.resources.*;
    import mx.logging.*;
    import mx.messaging.channels.*;
    import mx.core.*;

    public class AbstractConsumer extends MessageAgent {

        private var _currentAttempt:int;
        private var _timestamp:Number = -1;
        private var _resubscribeInterval:int = 5000;
        private var _resubscribeAttempts:int = 5;
        private var _resubscribeTimer:Timer;
        protected var _shouldBeSubscribed:Boolean;
        private var _subscribeMsg:CommandMessage;
        private var _maxFrequency:uint = 0;
        private var _subscribed:Boolean;
        private var resourceManager:IResourceManager;

        public function AbstractConsumer(){
            resourceManager = ResourceManager.getInstance();
            super();
            _log = Log.getLogger("mx.messaging.Consumer");
            _agentType = "consumer";
        }
        override public function channelFaultHandler(_arg1:ChannelFaultEvent):void{
            if (!_arg1.channel.connected){
                setSubscribed(false);
            };
            super.channelFaultHandler(_arg1);
            if (((((_shouldBeSubscribed) && (!(_arg1.rejected)))) && (!(_arg1.channel.connected)))){
                startResubscribeTimer();
            };
        }
        protected function buildUnsubscribeMessage(_arg1:Boolean):CommandMessage{
            var _local2:CommandMessage = new CommandMessage();
            _local2.operation = CommandMessage.UNSUBSCRIBE_OPERATION;
            _local2.clientId = clientId;
            _local2.destination = destination;
            if (_arg1){
                _local2.headers[CommandMessage.PRESERVE_DURABLE_HEADER] = _arg1;
            };
            return (_local2);
        }
        public function receive(_arg1:Number=0):void{
            var _local2:CommandMessage;
            if (clientId != null){
                _local2 = new CommandMessage();
                _local2.operation = CommandMessage.POLL_OPERATION;
                _local2.destination = destination;
                internalSend(_local2);
            };
        }
        protected function resubscribe(_arg1:TimerEvent):void{
            var _local2:ErrorMessage;
            if (((!((_resubscribeAttempts == -1))) && ((_currentAttempt >= _resubscribeAttempts)))){
                stopResubscribeTimer();
                _shouldBeSubscribed = false;
                _local2 = new ErrorMessage();
                _local2.faultCode = "Client.Error.Subscribe";
                _local2.faultString = resourceManager.getString("messaging", "consumerSubscribeError");
                _local2.faultDetail = resourceManager.getString("messaging", "failedToSubscribe");
                _local2.correlationId = _subscribeMsg.messageId;
                fault(_local2, _subscribeMsg);
                return;
            };
            if (Log.isDebug()){
                _log.debug("'{0}' {1} trying to resubscribe.", id, _agentType);
            };
            _resubscribeTimer.delay = _resubscribeInterval;
            _currentAttempt++;
            internalSend(_subscribeMsg, false);
        }
        override mx_internal function setClientId(_arg1:String):void{
            var _local2:Boolean;
            if (super.clientId != _arg1){
                _local2 = false;
                if (subscribed){
                    unsubscribe();
                    _local2 = true;
                };
                super.setClientId(_arg1);
                if (_local2){
                    subscribe(_arg1);
                };
            };
        }
        override public function disconnect():void{
            _shouldBeSubscribed = false;
            stopResubscribeTimer();
            setSubscribed(false);
            super.disconnect();
        }
        public function subscribe(_arg1:String=null):void{
            var _local2:Boolean = ((((!((_arg1 == null))) && (!((super.clientId == _arg1))))) ? true : false);
            if (((subscribed) && (_local2))){
                unsubscribe();
            };
            stopResubscribeTimer();
            _shouldBeSubscribed = true;
            if (_local2){
                super.setClientId(_arg1);
            };
            if (Log.isInfo()){
                _log.info("'{0}' {1} subscribe.", id, _agentType);
            };
            _subscribeMsg = buildSubscribeMessage();
            internalSend(_subscribeMsg);
        }
        override public function channelDisconnectHandler(_arg1:ChannelEvent):void{
            setSubscribed(false);
            super.channelDisconnectHandler(_arg1);
            if (((_shouldBeSubscribed) && (!(_arg1.rejected)))){
                startResubscribeTimer();
            };
        }
        protected function buildSubscribeMessage():CommandMessage{
            var _local1:CommandMessage = new CommandMessage();
            _local1.operation = CommandMessage.SUBSCRIBE_OPERATION;
            _local1.clientId = clientId;
            _local1.destination = destination;
            if (maxFrequency > 0){
                _local1.headers[CommandMessage.MAX_FREQUENCY_HEADER] = maxFrequency;
            };
            return (_local1);
        }
        protected function startResubscribeTimer():void{
            if (((_shouldBeSubscribed) && ((_resubscribeTimer == null)))){
                if (((!((_resubscribeAttempts == 0))) && ((_resubscribeInterval > 0)))){
                    if (Log.isDebug()){
                        _log.debug("'{0}' {1} starting resubscribe timer.", id, _agentType);
                    };
                    _resubscribeTimer = new Timer(1);
                    _resubscribeTimer.addEventListener(TimerEvent.TIMER, resubscribe);
                    _resubscribeTimer.start();
                    _currentAttempt = 0;
                };
            };
        }
        public function unsubscribe(_arg1:Boolean=false):void{
            _shouldBeSubscribed = false;
            if (subscribed){
                if (channelSet != null){
                    channelSet.removeEventListener(destination, messageHandler);
                };
                if (Log.isInfo()){
                    _log.info("'{0}' {1} unsubscribe.", id, _agentType);
                };
                internalSend(buildUnsubscribeMessage(_arg1));
            } else {
                stopResubscribeTimer();
            };
        }
        mx_internal function messageHandler(_arg1:MessageEvent):void{
            var _local3:CommandMessage;
            var _local2:IMessage = _arg1.message;
            if ((_local2 is CommandMessage)){
                _local3 = (_local2 as CommandMessage);
                switch (_local3.operation){
                    case CommandMessage.SUBSCRIPTION_INVALIDATE_OPERATION:
                        if ((channelSet.currentChannel is PollingChannel)){
                            PollingChannel(channelSet.currentChannel).disablePolling();
                        };
                        setSubscribed(false);
                        break;
                    default:
                        if (Log.isWarn()){
                            _log.warn("'{0}' received a CommandMessage '{1}' that could not be handled.", id, CommandMessage.getOperationAsString(_local3.operation));
                        };
                };
                return;
            };
            if (_local2.timestamp > _timestamp){
                _timestamp = _local2.timestamp;
            };
            if ((_local2 is ErrorMessage)){
                dispatchEvent(MessageFaultEvent.createEvent(ErrorMessage(_local2)));
            } else {
                dispatchEvent(MessageEvent.createEvent(MessageEvent.MESSAGE, _local2));
            };
        }
        public function get timestamp():Number{
            return (_timestamp);
        }
        public function get maxFrequency():uint{
            return (_maxFrequency);
        }
        public function get resubscribeInterval():int{
            return (_resubscribeInterval);
        }
        public function get subscribed():Boolean{
            return (_subscribed);
        }
        override public function fault(_arg1:ErrorMessage, _arg2:IMessage):void{
            if (_disconnectBarrier){
                return;
            };
            if (_arg1.headers[ErrorMessage.RETRYABLE_HINT_HEADER]){
                if (_resubscribeTimer == null){
                    if (((!((_subscribeMsg == null))) && ((_arg1.correlationId == _subscribeMsg.messageId)))){
                        _shouldBeSubscribed = false;
                    };
                    super.fault(_arg1, _arg2);
                };
            } else {
                super.fault(_arg1, _arg2);
            };
        }
        override public function set destination(_arg1:String):void{
            var _local2:Boolean;
            if (destination != _arg1){
                _local2 = false;
                if (subscribed){
                    unsubscribe();
                    _local2 = true;
                };
                super.destination = _arg1;
                if (_local2){
                    subscribe();
                };
            };
        }
        public function get resubscribeAttempts():int{
            return (_resubscribeAttempts);
        }
        protected function stopResubscribeTimer():void{
            if (_resubscribeTimer != null){
                if (Log.isDebug()){
                    _log.debug("'{0}' {1} stopping resubscribe timer.", id, _agentType);
                };
                _resubscribeTimer.removeEventListener(TimerEvent.TIMER, resubscribe);
                _resubscribeTimer.reset();
                _resubscribeTimer = null;
            };
        }
        override public function channelConnectHandler(_arg1:ChannelEvent):void{
            super.channelConnectHandler(_arg1);
            if (((((((((connected) && (!((channelSet == null))))) && (!((channelSet.currentChannel == null))))) && (!(channelSet.currentChannel.realtime)))) && (Log.isWarn()))){
                _log.warn(("'{0}' {1} connected over a non-realtime channel '{2}'" + " which means channel is not automatically receiving updates via polling or server push."), id, _agentType, channelSet.currentChannel.id);
            };
        }
        protected function setSubscribed(_arg1:Boolean):void{
            var _local2:PropertyChangeEvent;
            if (_subscribed != _arg1){
                _local2 = PropertyChangeEvent.createUpdateEvent(this, "subscribed", _subscribed, _arg1);
                _subscribed = _arg1;
                if (_subscribed){
                    ConsumerMessageDispatcher.getInstance().registerSubscription(this);
                    if (((((!((channelSet == null))) && (!((channelSet.currentChannel == null))))) && ((channelSet.currentChannel is PollingChannel)))){
                        PollingChannel(channelSet.currentChannel).enablePolling();
                    };
                } else {
                    ConsumerMessageDispatcher.getInstance().unregisterSubscription(this);
                    if (((((!((channelSet == null))) && (!((channelSet.currentChannel == null))))) && ((channelSet.currentChannel is PollingChannel)))){
                        PollingChannel(channelSet.currentChannel).disablePolling();
                    };
                };
                dispatchEvent(_local2);
            };
        }
        public function set maxFrequency(_arg1:uint):void{
            var _local2:PropertyChangeEvent = PropertyChangeEvent.createUpdateEvent(this, "maxFrequency", _maxFrequency, _arg1);
            _maxFrequency = _arg1;
            dispatchEvent(_local2);
        }
        override public function acknowledge(_arg1:AcknowledgeMessage, _arg2:IMessage):void{
            var _local3:CommandMessage;
            var _local4:int;
            var _local5:Array;
            var _local6:IMessage;
            if (_disconnectBarrier){
                return;
            };
            if (((!(_arg1.headers[AcknowledgeMessage.ERROR_HINT_HEADER])) && ((_arg2 is CommandMessage)))){
                _local3 = (_arg2 as CommandMessage);
                _local4 = _local3.operation;
                if (_local4 == CommandMessage.MULTI_SUBSCRIBE_OPERATION){
                    if (_arg2.headers.DSlastUnsub != null){
                        _local4 = CommandMessage.UNSUBSCRIBE_OPERATION;
                    } else {
                        _local4 = CommandMessage.SUBSCRIBE_OPERATION;
                    };
                };
                switch (_local4){
                    case CommandMessage.UNSUBSCRIBE_OPERATION:
                        if (Log.isInfo()){
                            _log.info("'{0}' {1} acknowledge for unsubscribe.", id, _agentType);
                        };
                        super.setClientId(null);
                        setSubscribed(false);
                        _arg1.clientId = null;
                        super.acknowledge(_arg1, _arg2);
                        break;
                    case CommandMessage.SUBSCRIBE_OPERATION:
                        stopResubscribeTimer();
                        if (_arg1.timestamp > _timestamp){
                            _timestamp = (_arg1.timestamp - 1);
                        };
                        if (Log.isInfo()){
                            _log.info("'{0}' {1} acknowledge for subscribe. Client id '{2}' new timestamp {3}", id, _agentType, _arg1.clientId, _timestamp);
                        };
                        super.setClientId(_arg1.clientId);
                        setSubscribed(true);
                        super.acknowledge(_arg1, _arg2);
                        break;
                    case CommandMessage.POLL_OPERATION:
                        if (((!((_arg1.body == null))) && ((_arg1.body is Array)))){
                            _local5 = (_arg1.body as Array);
                            for each (_local6 in _local5) {
                                messageHandler(MessageEvent.createEvent(MessageEvent.MESSAGE, _local6));
                            };
                        };
                        super.acknowledge(_arg1, _arg2);
                        break;
                };
            } else {
                super.acknowledge(_arg1, _arg2);
            };
        }
        public function set resubscribeInterval(_arg1:int):void{
            var _local2:PropertyChangeEvent;
            var _local3:String;
            if (_resubscribeInterval != _arg1){
                if (_arg1 < 0){
                    _local3 = resourceManager.getString("messaging", "resubscribeIntervalNegative");
                    throw (new ArgumentError(_local3));
                };
                if (_arg1 == 0){
                    stopResubscribeTimer();
                } else {
                    if (_resubscribeTimer != null){
                        _resubscribeTimer.delay = _arg1;
                    };
                };
                _local2 = PropertyChangeEvent.createUpdateEvent(this, "resubscribeInterval", _resubscribeInterval, _arg1);
                _resubscribeInterval = _arg1;
                dispatchEvent(_local2);
            };
        }
        public function set resubscribeAttempts(_arg1:int):void{
            var _local2:PropertyChangeEvent;
            if (_resubscribeAttempts != _arg1){
                if (_arg1 == 0){
                    stopResubscribeTimer();
                };
                _local2 = PropertyChangeEvent.createUpdateEvent(this, "resubscribeAttempts", _resubscribeAttempts, _arg1);
                _resubscribeAttempts = _arg1;
                dispatchEvent(_local2);
            };
        }
        public function set timestamp(_arg1:Number):void{
            var _local2:PropertyChangeEvent;
            if (_timestamp != _arg1){
                _local2 = PropertyChangeEvent.createUpdateEvent(this, "timestamp", _timestamp, _arg1);
                _timestamp = _arg1;
                dispatchEvent(_local2);
            };
        }

    }
}//package mx.messaging 
﻿package mx.messaging {
    import flash.events.*;
    import mx.events.*;
    import mx.messaging.messages.*;
    import mx.messaging.events.*;
    import mx.resources.*;
    import mx.logging.*;
    import mx.utils.*;
    import mx.messaging.config.*;
    import mx.core.*;
    import mx.messaging.errors.*;
    import mx.netmon.*;

    public class MessageAgent extends EventDispatcher implements IMXMLObject {

        mx_internal static const AUTO_CONFIGURED_CHANNELSET:int = 0;
        mx_internal static const MANUALLY_ASSIGNED_CHANNELSET:int = 1;

        private var _needsConfig:Boolean;
        protected var _disconnectBarrier:Boolean;
        protected var _log:ILogger;
        private var _connected:Boolean = false;
        private var _clientId:String;
        private var _sendRemoteCredentials:Boolean;
        private var _authenticated:Boolean;
        protected var _ignoreFault:Boolean = false;
        private var _id:String;
        protected var _credentials:String;
        private var resourceManager:IResourceManager;
        private var _channelSetMode:int = 0;
        mx_internal var configRequested:Boolean = false;
        private var _pendingConnectEvent:ChannelEvent;
        protected var _credentialsCharset:String;
        private var _remoteCredentials:String = "";
        private var _destination:String = "";
        protected var _agentType:String = "mx.messaging.MessageAgent";
        private var _requestTimeout:int = -1;
        private var _remoteCredentialsCharset:String;
        private var _clientIdWaitQueue:Array;
        private var _channelSet:ChannelSet;

        public function MessageAgent(){
            resourceManager = ResourceManager.getInstance();
            _id = UIDUtil.createUID();
            super();
        }
        public function get connected():Boolean{
            return (_connected);
        }
        public function get destination():String{
            return (_destination);
        }
        protected function initChannelSet(_arg1:IMessage):void{
            if (_channelSet == null){
                _channelSetMode = AUTO_CONFIGURED_CHANNELSET;
                internalSetChannelSet(ServerConfig.getChannelSet(destination));
            };
            if (((((_channelSet.connected) && (needsConfig))) && (!(configRequested)))){
                _arg1.headers[CommandMessage.NEEDS_CONFIG_HEADER] = true;
                configRequested = true;
            };
            _channelSet.connect(this);
            if (_credentials != null){
                channelSet.setCredentials(_credentials, this, _credentialsCharset);
            };
        }
        mx_internal function set needsConfig(_arg1:Boolean):void{
            var cs:* = null;
            var value:* = _arg1;
            if (_needsConfig == value){
                return;
            };
            _needsConfig = value;
            if (_needsConfig){
                cs = channelSet;
                try {
                    disconnect();
                } finally {
                    internalSetChannelSet(cs);
                };
            };
        }
        public function logout():void{
            _credentials = null;
            if (channelSet){
                channelSet.logout(this);
            };
        }
        public function get id():String{
            return (_id);
        }
        public function set destination(_arg1:String):void{
            var _local2:PropertyChangeEvent;
            if ((((_arg1 == null)) || ((_arg1.length == 0)))){
                return;
            };
            if (_destination != _arg1){
                if ((((_channelSetMode == AUTO_CONFIGURED_CHANNELSET)) && (!((channelSet == null))))){
                    channelSet.disconnect(this);
                    channelSet = null;
                };
                _local2 = PropertyChangeEvent.createUpdateEvent(this, "destination", _destination, _arg1);
                _destination = _arg1;
                dispatchEvent(_local2);
                if (Log.isInfo()){
                    _log.info("'{0}' {2} set destination to '{1}'.", id, _destination, _agentType);
                };
            };
        }
        mx_internal function get channelSetMode():int{
            return (_channelSetMode);
        }
        public function acknowledge(_arg1:AcknowledgeMessage, _arg2:IMessage):void{
            var mpiutil:* = null;
            var ackMsg:* = _arg1;
            var msg:* = _arg2;
            if (Log.isInfo()){
                _log.info("'{0}' {2} acknowledge of '{1}'.", id, msg.messageId, _agentType);
            };
            if (((((((Log.isDebug()) && (!((channelSet == null))))) && (!((channelSet.currentChannel == null))))) && (channelSet.currentChannel.mpiEnabled))){
                try {
                    mpiutil = new MessagePerformanceUtils(ackMsg);
                    _log.debug(mpiutil.prettyPrint());
                } catch(e:Error) {
                    _log.debug(("Could not get message performance information for: " + msg.toString()));
                };
            };
            if (configRequested){
                configRequested = false;
                ServerConfig.updateServerConfigData((ackMsg.body as ConfigMap));
                needsConfig = false;
                if (_pendingConnectEvent){
                    channelConnectHandler(_pendingConnectEvent);
                };
                _pendingConnectEvent = null;
            };
            if (clientId == null){
                if (ackMsg.clientId != null){
                    setClientId(ackMsg.clientId);
                } else {
                    flushClientIdWaitQueue();
                };
            };
            dispatchEvent(MessageAckEvent.createEvent(ackMsg, msg));
            monitorRpcMessage(ackMsg, msg);
        }
        mx_internal function internalSetChannelSet(_arg1:ChannelSet):void{
            var _local2:PropertyChangeEvent;
            if (_channelSet != _arg1){
                if (_channelSet != null){
                    _channelSet.disconnect(this);
                };
                _local2 = PropertyChangeEvent.createUpdateEvent(this, "channelSet", _channelSet, _arg1);
                _channelSet = _arg1;
                if (_channelSet != null){
                    if (_credentials){
                        _channelSet.setCredentials(_credentials, this, _credentialsCharset);
                    };
                    _channelSet.connect(this);
                };
                dispatchEvent(_local2);
            };
        }
        public function fault(_arg1:ErrorMessage, _arg2:IMessage):void{
            if (Log.isError()){
                _log.error("'{0}' {2} fault for '{1}'.", id, _arg2.messageId, _agentType);
            };
            _ignoreFault = false;
            configRequested = false;
            if (_arg1.headers[ErrorMessage.RETRYABLE_HINT_HEADER]){
                delete _arg1.headers[ErrorMessage.RETRYABLE_HINT_HEADER];
            };
            if (clientId == null){
                if (_arg1.clientId != null){
                    setClientId(_arg1.clientId);
                } else {
                    flushClientIdWaitQueue();
                };
            };
            dispatchEvent(MessageFaultEvent.createEvent(_arg1));
            monitorRpcMessage(_arg1, _arg2);
            if ((((((((_arg1.faultCode == "Client.Authentication")) && (authenticated))) && (!((channelSet == null))))) && (!((channelSet.currentChannel == null))))){
                channelSet.currentChannel.setAuthenticated(false);
                if (channelSet.currentChannel.loginAfterDisconnect){
                    reAuthorize(_arg2);
                    _ignoreFault = true;
                };
            };
        }
        public function set requestTimeout(_arg1:int):void{
            var _local2:PropertyChangeEvent;
            if (_requestTimeout != _arg1){
                _local2 = PropertyChangeEvent.createUpdateEvent(this, "requestTimeout", _requestTimeout, _arg1);
                _requestTimeout = _arg1;
                dispatchEvent(_local2);
            };
        }
        public function disconnect():void{
            if (!_disconnectBarrier){
                _clientIdWaitQueue = null;
                if (connected){
                    _disconnectBarrier = true;
                };
                if (_channelSetMode == AUTO_CONFIGURED_CHANNELSET){
                    internalSetChannelSet(null);
                } else {
                    if (_channelSet != null){
                        _channelSet.disconnect(this);
                    };
                };
            };
        }
        public function set id(_arg1:String):void{
            var _local2:PropertyChangeEvent;
            if (_id != _arg1){
                _local2 = PropertyChangeEvent.createUpdateEvent(this, "id", _id, _arg1);
                _id = _arg1;
                dispatchEvent(_local2);
            };
        }
        public function set channelSet(_arg1:ChannelSet):void{
            internalSetChannelSet(_arg1);
            _channelSetMode = MANUALLY_ASSIGNED_CHANNELSET;
        }
        public function get clientId():String{
            return (_clientId);
        }
        protected function setConnected(_arg1:Boolean):void{
            var _local2:PropertyChangeEvent;
            if (_connected != _arg1){
                _local2 = PropertyChangeEvent.createUpdateEvent(this, "connected", _connected, _arg1);
                _connected = _arg1;
                dispatchEvent(_local2);
                setAuthenticated(((((_arg1) && (channelSet))) && (channelSet.authenticated)), _credentials);
            };
        }
        mx_internal function setClientId(_arg1:String):void{
            var _local2:PropertyChangeEvent;
            if (_clientId != _arg1){
                _local2 = PropertyChangeEvent.createUpdateEvent(this, "clientId", _clientId, _arg1);
                _clientId = _arg1;
                flushClientIdWaitQueue();
                dispatchEvent(_local2);
            };
        }
        public function setCredentials(_arg1:String, _arg2:String, _arg3:String=null):void{
            var _local4:String;
            var _local5:Base64Encoder;
            if ((((_arg1 == null)) && ((_arg2 == null)))){
                _credentials = null;
                _credentialsCharset = null;
            } else {
                _local4 = ((_arg1 + ":") + _arg2);
                _local5 = new Base64Encoder();
                if (_arg3 == Base64Encoder.CHARSET_UTF_8){
                    _local5.encodeUTFBytes(_local4);
                } else {
                    _local5.encode(_local4);
                };
                _credentials = _local5.drain();
                _credentialsCharset = _arg3;
            };
            if (channelSet != null){
                channelSet.setCredentials(_credentials, this, _credentialsCharset);
            };
        }
        public function channelDisconnectHandler(_arg1:ChannelEvent):void{
            if (Log.isWarn()){
                _log.warn("'{0}' {1} channel disconnected.", id, _agentType);
            };
            setConnected(false);
            if (_remoteCredentials != null){
                _sendRemoteCredentials = true;
            };
            dispatchEvent(_arg1);
        }
        public function setRemoteCredentials(_arg1:String, _arg2:String, _arg3:String=null):void{
            var _local4:String;
            var _local5:Base64Encoder;
            if ((((_arg1 == null)) && ((_arg2 == null)))){
                _remoteCredentials = "";
                _remoteCredentialsCharset = null;
            } else {
                _local4 = ((_arg1 + ":") + _arg2);
                _local5 = new Base64Encoder();
                if (_arg3 == Base64Encoder.CHARSET_UTF_8){
                    _local5.encodeUTFBytes(_local4);
                } else {
                    _local5.encode(_local4);
                };
                _remoteCredentials = _local5.drain();
                _remoteCredentialsCharset = _arg3;
            };
            _sendRemoteCredentials = true;
        }
        mx_internal function get needsConfig():Boolean{
            return (_needsConfig);
        }
        public function hasPendingRequestForMessage(_arg1:IMessage):Boolean{
            return (false);
        }
        public function get authenticated():Boolean{
            return (_authenticated);
        }
        public function get requestTimeout():int{
            return (_requestTimeout);
        }
        public function initialized(_arg1:Object, _arg2:String):void{
            this.id = _arg2;
        }
        mx_internal function getNetmonId():String{
            return (null);
        }
        final protected function flushClientIdWaitQueue():void{
            var _local1:Array;
            if (_clientIdWaitQueue != null){
                if (clientId != null){
                    while (_clientIdWaitQueue.length > 0) {
                        internalSend((_clientIdWaitQueue.shift() as IMessage));
                    };
                };
                if (clientId == null){
                    if (_clientIdWaitQueue.length > 0){
                        _local1 = _clientIdWaitQueue;
                        _clientIdWaitQueue = null;
                        internalSend((_local1.shift() as IMessage));
                        _clientIdWaitQueue = _local1;
                    } else {
                        _clientIdWaitQueue = null;
                    };
                };
            };
        }
        private function monitorRpcMessage(_arg1:IMessage, _arg2:IMessage):void{
            if (NetworkMonitor.isMonitoring()){
                if ((_arg1 is ErrorMessage)){
                    NetworkMonitor.monitorFault(_arg2, MessageFaultEvent.createEvent(ErrorMessage(_arg1)));
                } else {
                    if ((_arg1 is AcknowledgeMessage)){
                        NetworkMonitor.monitorResult(_arg1, MessageEvent.createEvent(MessageEvent.RESULT, _arg2));
                    } else {
                        NetworkMonitor.monitorInvocation(getNetmonId(), _arg1, this);
                    };
                };
            };
        }
        final protected function assertCredentials(_arg1:String):void{
            var _local2:ErrorMessage;
            if (((!((_credentials == null))) && (!((_credentials == _arg1))))){
                _local2 = new ErrorMessage();
                _local2.faultCode = "Client.Authentication.Error";
                _local2.faultString = "Credentials specified do not match those used on underlying connection.";
                _local2.faultDetail = "Channel was authenticated with a different set of credentials than those used for this agent.";
                dispatchEvent(MessageFaultEvent.createEvent(_local2));
            };
        }
        public function get channelSet():ChannelSet{
            return (_channelSet);
        }
        public function channelConnectHandler(_arg1:ChannelEvent):void{
            _disconnectBarrier = false;
            if (needsConfig){
                if (Log.isInfo()){
                    _log.info("'{0}' {1} waiting for configuration information.", id, _agentType);
                };
                _pendingConnectEvent = _arg1;
            } else {
                if (Log.isInfo()){
                    _log.info("'{0}' {1} connected.", id, _agentType);
                };
                setConnected(true);
                dispatchEvent(_arg1);
            };
        }
        mx_internal function internalSetCredentials(_arg1:String):void{
            _credentials = _arg1;
        }
        public function channelFaultHandler(_arg1:ChannelFaultEvent):void{
            if (Log.isWarn()){
                _log.warn("'{0}' {1} channel faulted with {2} {3}", id, _agentType, _arg1.faultCode, _arg1.faultDetail);
            };
            if (!_arg1.channel.connected){
                setConnected(false);
                if (_remoteCredentials != null){
                    _sendRemoteCredentials = true;
                };
            };
            dispatchEvent(_arg1);
        }
        protected function internalSend(_arg1:IMessage, _arg2:Boolean=true):void{
            var _local3:String;
            if ((((((_arg1.clientId == null)) && (_arg2))) && ((clientId == null)))){
                if (_clientIdWaitQueue == null){
                    _clientIdWaitQueue = [];
                } else {
                    _clientIdWaitQueue.push(_arg1);
                    return;
                };
            };
            if (_arg1.clientId == null){
                _arg1.clientId = clientId;
            };
            if (requestTimeout > 0){
                _arg1.headers[AbstractMessage.REQUEST_TIMEOUT_HEADER] = requestTimeout;
            };
            if (_sendRemoteCredentials){
                if (!(((_arg1 is CommandMessage)) && ((CommandMessage(_arg1).operation == CommandMessage.TRIGGER_CONNECT_OPERATION)))){
                    _arg1.headers[AbstractMessage.REMOTE_CREDENTIALS_HEADER] = _remoteCredentials;
                    _arg1.headers[AbstractMessage.REMOTE_CREDENTIALS_CHARSET_HEADER] = _remoteCredentialsCharset;
                    _sendRemoteCredentials = false;
                };
            };
            if (channelSet != null){
                if (((!(connected)) && ((_channelSetMode == MANUALLY_ASSIGNED_CHANNELSET)))){
                    _channelSet.connect(this);
                };
                if (((((channelSet.connected) && (needsConfig))) && (!(configRequested)))){
                    _arg1.headers[CommandMessage.NEEDS_CONFIG_HEADER] = true;
                    configRequested = true;
                };
                channelSet.send(this, _arg1);
                monitorRpcMessage(_arg1, _arg1);
            } else {
                if (((!((destination == null))) && ((destination.length > 0)))){
                    initChannelSet(_arg1);
                    if (channelSet != null){
                        channelSet.send(this, _arg1);
                        monitorRpcMessage(_arg1, _arg1);
                    };
                } else {
                    _local3 = resourceManager.getString("messaging", "destinationNotSet");
                    throw (new InvalidDestinationError(_local3));
                };
            };
        }
        mx_internal function setAuthenticated(_arg1:Boolean, _arg2:String):void{
            var _local3:PropertyChangeEvent;
            if (_authenticated != _arg1){
                _local3 = PropertyChangeEvent.createUpdateEvent(this, "authenticated", _authenticated, _arg1);
                _authenticated = _arg1;
                dispatchEvent(_local3);
                if (_arg1){
                    assertCredentials(_arg2);
                };
            };
        }
        protected function reAuthorize(_arg1:IMessage):void{
            disconnect();
            internalSend(_arg1);
        }

    }
}//package mx.messaging 
﻿package mx.messaging {
    import flash.events.*;
    import mx.events.*;
    import mx.core.*;

    public class FlexClient extends EventDispatcher {

        mx_internal static const NULL_FLEXCLIENT_ID:String = "nil";

        private static var _instance:FlexClient;

        private var _waitForFlexClientId:Boolean = false;
        private var _id:String;

        public static function getInstance():FlexClient{
            if (_instance == null){
                _instance = new (FlexClient)();
            };
            return (_instance);
        }

        public function get id():String{
            return (_id);
        }
        mx_internal function get waitForFlexClientId():Boolean{
            return (_waitForFlexClientId);
        }
        public function set id(_arg1:String):void{
            var _local2:PropertyChangeEvent;
            if (_id != _arg1){
                _local2 = PropertyChangeEvent.createUpdateEvent(this, "id", _id, _arg1);
                _id = _arg1;
                dispatchEvent(_local2);
            };
        }
        mx_internal function set waitForFlexClientId(_arg1:Boolean):void{
            var _local2:PropertyChangeEvent;
            if (_waitForFlexClientId != _arg1){
                _local2 = PropertyChangeEvent.createUpdateEvent(this, "waitForFlexClientId", _waitForFlexClientId, _arg1);
                _waitForFlexClientId = _arg1;
                dispatchEvent(_local2);
            };
        }

    }
}//package mx.messaging 
﻿package mx.messaging {
    import mx.events.*;
    import mx.messaging.messages.*;

    public class Consumer extends AbstractConsumer {

        private var _selector:String = "";
        private var _subtopic:String = "";

        public function Consumer(_arg1:String="flex.messaging.messages.AsyncMessage"){
        }
        public function set subtopic(_arg1:String):void{
            var _local2:Boolean;
            if (subtopic != _arg1){
                _local2 = false;
                if (subscribed){
                    unsubscribe();
                    _local2 = true;
                };
                _subtopic = _arg1;
                if (_local2){
                    subscribe();
                };
            };
        }
        override protected function internalSend(_arg1:IMessage, _arg2:Boolean=true):void{
            if (subtopic.length > 0){
                _arg1.headers[AsyncMessage.SUBTOPIC_HEADER] = subtopic;
            };
            if (_selector.length > 0){
                _arg1.headers[CommandMessage.SELECTOR_HEADER] = _selector;
            };
            super.internalSend(_arg1, _arg2);
        }
        public function set selector(_arg1:String):void{
            var _local2:PropertyChangeEvent;
            var _local3:Boolean;
            if (_selector !== _arg1){
                _local2 = PropertyChangeEvent.createUpdateEvent(this, "selector", _selector, _arg1);
                _local3 = false;
                if (subscribed){
                    unsubscribe();
                    _local3 = true;
                };
                _selector = _arg1;
                if (_local3){
                    subscribe(clientId);
                };
                dispatchEvent(_local2);
            };
        }
        public function get subtopic():String{
            return (_subtopic);
        }
        public function get selector():String{
            return (_selector);
        }

    }
}//package mx.messaging 
﻿package mx.messaging {
    import flash.events.*;
    import flash.utils.*;
    import mx.messaging.messages.*;
    import mx.resources.*;
    import flash.net.*;

    public class MessageResponder extends Responder {

        private var _channel:Channel;
        private var _agent:MessageAgent;
        private var _requestTimedOut:Boolean;
        private var _message:IMessage;
        private var _requestTimer:Timer;
        private var resourceManager:IResourceManager;

        public function MessageResponder(_arg1:MessageAgent, _arg2:IMessage, _arg3:Channel=null){
            resourceManager = ResourceManager.getInstance();
            super(result, status);
            _agent = _arg1;
            _channel = _arg3;
            _message = _arg2;
            _requestTimedOut = false;
        }
        public function get channel():Channel{
            return (_channel);
        }
        public function get agent():MessageAgent{
            return (_agent);
        }
        protected function requestTimedOut():void{
        }
        final public function startRequestTimeout(_arg1:int):void{
            _requestTimer = new Timer((_arg1 * 1000), 1);
            _requestTimer.addEventListener(TimerEvent.TIMER, timeoutRequest);
            _requestTimer.start();
        }
        public function get message():IMessage{
            return (_message);
        }
        final public function result(_arg1:IMessage):void{
            if (!_requestTimedOut){
                if (_requestTimer != null){
                    releaseTimer();
                };
                resultHandler(_arg1);
            };
        }
        private function releaseTimer():void{
            _requestTimer.stop();
            _requestTimer.removeEventListener(TimerEvent.TIMER, timeoutRequest);
            _requestTimer = null;
        }
        public function set message(_arg1:IMessage):void{
            _message = _arg1;
        }
        protected function createRequestTimeoutErrorMessage():ErrorMessage{
            var _local1:ErrorMessage = new ErrorMessage();
            _local1.correlationId = message.messageId;
            _local1.faultCode = "Client.Error.RequestTimeout";
            _local1.faultString = resourceManager.getString("messaging", "requestTimedOut");
            _local1.faultDetail = resourceManager.getString("messaging", "requestTimedOut.details");
            return (_local1);
        }
        private function timeoutRequest(_arg1:TimerEvent):void{
            _requestTimedOut = true;
            releaseTimer();
            requestTimedOut();
        }
        final public function status(_arg1:IMessage):void{
            if (!_requestTimedOut){
                if (_requestTimer != null){
                    releaseTimer();
                };
                statusHandler(_arg1);
            };
        }
        protected function resultHandler(_arg1:IMessage):void{
        }
        protected function statusHandler(_arg1:IMessage):void{
        }

    }
}//package mx.messaging 
﻿package mx.modules {
    import flash.events.*;
    import flash.utils.*;
    import flash.system.*;
    import mx.core.*;

    public interface IModuleInfo extends IEventDispatcher {

        function get ready():Boolean;
        function get loaded():Boolean;
        function load(_arg1:ApplicationDomain=null, _arg2:SecurityDomain=null, _arg3:ByteArray=null):void;
        function release():void;
        function get error():Boolean;
        function get data():Object;
        function publish(_arg1:IFlexModuleFactory):void;
        function get factory():IFlexModuleFactory;
        function set data(_arg1:Object):void;
        function get url():String;
        function get setup():Boolean;
        function unload():void;

    }
}//package mx.modules 
﻿package mx.modules {

    public class ModuleManagerGlobals {

        public static var managerSingleton:Object = null;

    }
}//package mx.modules 
﻿package mx.modules {
    import mx.core.*;

    public class ModuleManager {

        mx_internal static const VERSION:String = "3.5.0.12683";

        public static function getModule(_arg1:String):IModuleInfo{
            return (getSingleton().getModule(_arg1));
        }
        private static function getSingleton():Object{
            if (!ModuleManagerGlobals.managerSingleton){
                ModuleManagerGlobals.managerSingleton = new ModuleManagerImpl();
            };
            return (ModuleManagerGlobals.managerSingleton);
        }
        public static function getAssociatedFactory(_arg1:Object):IFlexModuleFactory{
            return (getSingleton().getAssociatedFactory(_arg1));
        }

    }
}//package mx.modules 

import flash.events.*;
import flash.display.*;
import mx.events.*;
import flash.utils.*;
import flash.net.*;
import flash.system.*;
import mx.core.*;

class ModuleInfoProxy extends EventDispatcher implements IModuleInfo {

    private var _data:Object;
    private var info:ModuleInfo;
    private var referenced:Boolean = false;

    public function ModuleInfoProxy(_arg1:ModuleInfo){
        this.info = _arg1;
        _arg1.addEventListener(ModuleEvent.SETUP, moduleEventHandler, false, 0, true);
        _arg1.addEventListener(ModuleEvent.PROGRESS, moduleEventHandler, false, 0, true);
        _arg1.addEventListener(ModuleEvent.READY, moduleEventHandler, false, 0, true);
        _arg1.addEventListener(ModuleEvent.ERROR, moduleEventHandler, false, 0, true);
        _arg1.addEventListener(ModuleEvent.UNLOAD, moduleEventHandler, false, 0, true);
    }
    public function get loaded():Boolean{
        return (info.loaded);
    }
    public function release():void{
        if (referenced){
            info.removeReference();
            referenced = false;
        };
    }
    public function get error():Boolean{
        return (info.error);
    }
    public function get factory():IFlexModuleFactory{
        return (info.factory);
    }
    public function publish(_arg1:IFlexModuleFactory):void{
        info.publish(_arg1);
    }
    public function set data(_arg1:Object):void{
        _data = _arg1;
    }
    public function get ready():Boolean{
        return (info.ready);
    }
    public function load(_arg1:ApplicationDomain=null, _arg2:SecurityDomain=null, _arg3:ByteArray=null):void{
        var _local4:ModuleEvent;
        info.resurrect();
        if (!referenced){
            info.addReference();
            referenced = true;
        };
        if (info.error){
            dispatchEvent(new ModuleEvent(ModuleEvent.ERROR));
        } else {
            if (info.loaded){
                if (info.setup){
                    dispatchEvent(new ModuleEvent(ModuleEvent.SETUP));
                    if (info.ready){
                        _local4 = new ModuleEvent(ModuleEvent.PROGRESS);
                        _local4.bytesLoaded = info.size;
                        _local4.bytesTotal = info.size;
                        dispatchEvent(_local4);
                        dispatchEvent(new ModuleEvent(ModuleEvent.READY));
                    };
                };
            } else {
                info.load(_arg1, _arg2, _arg3);
            };
        };
    }
    private function moduleEventHandler(_arg1:ModuleEvent):void{
        dispatchEvent(_arg1);
    }
    public function get url():String{
        return (info.url);
    }
    public function get data():Object{
        return (_data);
    }
    public function get setup():Boolean{
        return (info.setup);
    }
    public function unload():void{
        info.unload();
        info.removeEventListener(ModuleEvent.SETUP, moduleEventHandler);
        info.removeEventListener(ModuleEvent.PROGRESS, moduleEventHandler);
        info.removeEventListener(ModuleEvent.READY, moduleEventHandler);
        info.removeEventListener(ModuleEvent.ERROR, moduleEventHandler);
        info.removeEventListener(ModuleEvent.UNLOAD, moduleEventHandler);
    }

}
class ModuleManagerImpl extends EventDispatcher {

    private var moduleList:Object;

    public function ModuleManagerImpl(){
        moduleList = {};
        super();
    }
    public function getModule(_arg1:String):IModuleInfo{
        var _local2:ModuleInfo = (moduleList[_arg1] as ModuleInfo);
        if (!_local2){
            _local2 = new ModuleInfo(_arg1);
            moduleList[_arg1] = _local2;
        };
        return (new ModuleInfoProxy(_local2));
    }
    public function getAssociatedFactory(_arg1:Object):IFlexModuleFactory{
        var m:* = null;
        var info:* = null;
        var domain:* = null;
        var cls:* = null;
        var object:* = _arg1;
        var className:* = getQualifiedClassName(object);
        for each (m in moduleList) {
            info = (m as ModuleInfo);
            if (!info.ready){
            } else {
                domain = info.applicationDomain;
                try {
                    cls = Class(domain.getDefinition(className));
                    if ((object is cls)){
                        return (info.factory);
                    };
                } catch(error:Error) {
                };
            };
        };
        return (null);
    }

}
class ModuleInfo extends EventDispatcher {

    private var _error:Boolean = false;
    private var loader:Loader;
    private var factoryInfo:FactoryInfo;
    private var limbo:Dictionary;
    private var _loaded:Boolean = false;
    private var _ready:Boolean = false;
    private var numReferences:int = 0;
    private var _url:String;
    private var _setup:Boolean = false;

    public function ModuleInfo(_arg1:String){
        _url = _arg1;
    }
    private function clearLoader():void{
        if (loader){
            if (loader.contentLoaderInfo){
                loader.contentLoaderInfo.removeEventListener(Event.INIT, initHandler);
                loader.contentLoaderInfo.removeEventListener(Event.COMPLETE, completeHandler);
                loader.contentLoaderInfo.removeEventListener(ProgressEvent.PROGRESS, progressHandler);
                loader.contentLoaderInfo.removeEventListener(IOErrorEvent.IO_ERROR, errorHandler);
                loader.contentLoaderInfo.removeEventListener(SecurityErrorEvent.SECURITY_ERROR, errorHandler);
            };
            try {
                if (loader.content){
                    loader.content.removeEventListener("ready", readyHandler);
                    loader.content.removeEventListener("error", moduleErrorHandler);
                };
            } catch(error:Error) {
            };
            if (_loaded){
                try {
                    loader.close();
                } catch(error:Error) {
                };
            };
            try {
                loader.unload();
            } catch(error:Error) {
            };
            loader = null;
        };
    }
    public function get size():int{
        return (((((!(limbo)) && (factoryInfo))) ? factoryInfo.bytesTotal : 0));
    }
    public function get loaded():Boolean{
        return (((limbo) ? false : _loaded));
    }
    public function release():void{
        if (((_ready) && (!(limbo)))){
            limbo = new Dictionary(true);
            limbo[factoryInfo] = 1;
            factoryInfo = null;
        } else {
            unload();
        };
    }
    public function get error():Boolean{
        return (((limbo) ? false : _error));
    }
    public function get factory():IFlexModuleFactory{
        return (((((!(limbo)) && (factoryInfo))) ? factoryInfo.factory : null));
    }
    public function completeHandler(_arg1:Event):void{
        var _local2:ModuleEvent = new ModuleEvent(ModuleEvent.PROGRESS, _arg1.bubbles, _arg1.cancelable);
        _local2.bytesLoaded = loader.contentLoaderInfo.bytesLoaded;
        _local2.bytesTotal = loader.contentLoaderInfo.bytesTotal;
        dispatchEvent(_local2);
    }
    public function publish(_arg1:IFlexModuleFactory):void{
        if (factoryInfo){
            return;
        };
        if (_url.indexOf("published://") != 0){
            return;
        };
        factoryInfo = new FactoryInfo();
        factoryInfo.factory = _arg1;
        _loaded = true;
        _setup = true;
        _ready = true;
        _error = false;
        dispatchEvent(new ModuleEvent(ModuleEvent.SETUP));
        dispatchEvent(new ModuleEvent(ModuleEvent.PROGRESS));
        dispatchEvent(new ModuleEvent(ModuleEvent.READY));
    }
    public function initHandler(_arg1:Event):void{
        var moduleEvent:* = null;
        var event:* = _arg1;
        factoryInfo = new FactoryInfo();
        try {
            factoryInfo.factory = (loader.content as IFlexModuleFactory);
        } catch(error:Error) {
        };
        if (!factoryInfo.factory){
            moduleEvent = new ModuleEvent(ModuleEvent.ERROR, event.bubbles, event.cancelable);
            moduleEvent.bytesLoaded = 0;
            moduleEvent.bytesTotal = 0;
            moduleEvent.errorText = "SWF is not a loadable module";
            dispatchEvent(moduleEvent);
            return;
        };
        loader.content.addEventListener("ready", readyHandler);
        loader.content.addEventListener("error", moduleErrorHandler);
        try {
            factoryInfo.applicationDomain = loader.contentLoaderInfo.applicationDomain;
        } catch(error:Error) {
        };
        _setup = true;
        dispatchEvent(new ModuleEvent(ModuleEvent.SETUP));
    }
    public function resurrect():void{
        var _local1:Object;
        if (((!(factoryInfo)) && (limbo))){
            for (_local1 in limbo) {
                factoryInfo = (_local1 as FactoryInfo);
                break;
            };
            limbo = null;
        };
        if (!factoryInfo){
            if (_loaded){
                dispatchEvent(new ModuleEvent(ModuleEvent.UNLOAD));
            };
            loader = null;
            _loaded = false;
            _setup = false;
            _ready = false;
            _error = false;
        };
    }
    public function errorHandler(_arg1:ErrorEvent):void{
        _error = true;
        var _local2:ModuleEvent = new ModuleEvent(ModuleEvent.ERROR, _arg1.bubbles, _arg1.cancelable);
        _local2.bytesLoaded = 0;
        _local2.bytesTotal = 0;
        _local2.errorText = _arg1.text;
        dispatchEvent(_local2);
    }
    public function get ready():Boolean{
        return (((limbo) ? false : _ready));
    }
    private function loadBytes(_arg1:ApplicationDomain, _arg2:ByteArray):void{
        var _local3:LoaderContext = new LoaderContext();
        _local3.applicationDomain = ((_arg1) ? _arg1 : new ApplicationDomain(ApplicationDomain.currentDomain));
        if (("allowLoadBytesCodeExecution" in _local3)){
            _local3["allowLoadBytesCodeExecution"] = true;
        };
        loader = new Loader();
        loader.contentLoaderInfo.addEventListener(Event.INIT, initHandler);
        loader.contentLoaderInfo.addEventListener(Event.COMPLETE, completeHandler);
        loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);
        loader.contentLoaderInfo.addEventListener(SecurityErrorEvent.SECURITY_ERROR, errorHandler);
        loader.loadBytes(_arg2, _local3);
    }
    public function removeReference():void{
        numReferences--;
        if (numReferences == 0){
            release();
        };
    }
    public function addReference():void{
        numReferences++;
    }
    public function progressHandler(_arg1:ProgressEvent):void{
        var _local2:ModuleEvent = new ModuleEvent(ModuleEvent.PROGRESS, _arg1.bubbles, _arg1.cancelable);
        _local2.bytesLoaded = _arg1.bytesLoaded;
        _local2.bytesTotal = _arg1.bytesTotal;
        dispatchEvent(_local2);
    }
    public function load(_arg1:ApplicationDomain=null, _arg2:SecurityDomain=null, _arg3:ByteArray=null):void{
        if (_loaded){
            return;
        };
        _loaded = true;
        limbo = null;
        if (_arg3){
            loadBytes(_arg1, _arg3);
            return;
        };
        if (_url.indexOf("published://") == 0){
            return;
        };
        var _local4:URLRequest = new URLRequest(_url);
        var _local5:LoaderContext = new LoaderContext();
        _local5.applicationDomain = ((_arg1) ? _arg1 : new ApplicationDomain(ApplicationDomain.currentDomain));
        _local5.securityDomain = _arg2;
        if ((((_arg2 == null)) && ((Security.sandboxType == Security.REMOTE)))){
            _local5.securityDomain = SecurityDomain.currentDomain;
        };
        loader = new Loader();
        loader.contentLoaderInfo.addEventListener(Event.INIT, initHandler);
        loader.contentLoaderInfo.addEventListener(Event.COMPLETE, completeHandler);
        loader.contentLoaderInfo.addEventListener(ProgressEvent.PROGRESS, progressHandler);
        loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);
        loader.contentLoaderInfo.addEventListener(SecurityErrorEvent.SECURITY_ERROR, errorHandler);
        loader.load(_local4, _local5);
    }
    public function get url():String{
        return (_url);
    }
    public function get applicationDomain():ApplicationDomain{
        return (((((!(limbo)) && (factoryInfo))) ? factoryInfo.applicationDomain : null));
    }
    public function moduleErrorHandler(_arg1:Event):void{
        var _local2:ModuleEvent;
        _ready = true;
        factoryInfo.bytesTotal = loader.contentLoaderInfo.bytesTotal;
        clearLoader();
        if ((_arg1 is ModuleEvent)){
            _local2 = ModuleEvent(_arg1);
        } else {
            _local2 = new ModuleEvent(ModuleEvent.ERROR);
        };
        dispatchEvent(_local2);
    }
    public function readyHandler(_arg1:Event):void{
        _ready = true;
        factoryInfo.bytesTotal = loader.contentLoaderInfo.bytesTotal;
        var _local2:ModuleEvent = new ModuleEvent(ModuleEvent.READY);
        _local2.bytesLoaded = loader.contentLoaderInfo.bytesLoaded;
        _local2.bytesTotal = loader.contentLoaderInfo.bytesTotal;
        clearLoader();
        dispatchEvent(_local2);
    }
    public function get setup():Boolean{
        return (((limbo) ? false : _setup));
    }
    public function unload():void{
        clearLoader();
        if (_loaded){
            dispatchEvent(new ModuleEvent(ModuleEvent.UNLOAD));
        };
        limbo = null;
        factoryInfo = null;
        _loaded = false;
        _setup = false;
        _ready = false;
        _error = false;
    }

}
class FactoryInfo {

    public var bytesTotal:int = 0;
    public var factory:IFlexModuleFactory;
    public var applicationDomain:ApplicationDomain;

    public function FactoryInfo(){
    }
}
﻿package mx.core {
    import flash.utils.*;

    public interface IFlexModuleFactory {

        function get preloadedRSLs():Dictionary;
        function allowInsecureDomain(... _args):void;
        function create(... _args):Object;
        function allowDomain(... _args):void;
        function info():Object;

    }
}//package mx.core 
﻿package mx.core {

    public interface IUID {

        function get uid():String;
        function set uid(_arg1:String):void;

    }
}//package mx.core 
﻿package mx.core {
    import flash.events.*;
    import flash.display.*;
    import flash.geom.*;
    import flash.accessibility.*;

    public interface IFlexDisplayObject extends IBitmapDrawable, IEventDispatcher {

        function get visible():Boolean;
        function get rotation():Number;
        function localToGlobal(_arg1:Point):Point;
        function get name():String;
        function set width(_arg1:Number):void;
        function get measuredHeight():Number;
        function get blendMode():String;
        function get scale9Grid():Rectangle;
        function set name(_arg1:String):void;
        function set scaleX(_arg1:Number):void;
        function set scaleY(_arg1:Number):void;
        function get measuredWidth():Number;
        function get accessibilityProperties():AccessibilityProperties;
        function set scrollRect(_arg1:Rectangle):void;
        function get cacheAsBitmap():Boolean;
        function globalToLocal(_arg1:Point):Point;
        function get height():Number;
        function set blendMode(_arg1:String):void;
        function get parent():DisplayObjectContainer;
        function getBounds(_arg1:DisplayObject):Rectangle;
        function get opaqueBackground():Object;
        function set scale9Grid(_arg1:Rectangle):void;
        function setActualSize(_arg1:Number, _arg2:Number):void;
        function set alpha(_arg1:Number):void;
        function set accessibilityProperties(_arg1:AccessibilityProperties):void;
        function get width():Number;
        function hitTestPoint(_arg1:Number, _arg2:Number, _arg3:Boolean=false):Boolean;
        function set cacheAsBitmap(_arg1:Boolean):void;
        function get scaleX():Number;
        function get scaleY():Number;
        function get scrollRect():Rectangle;
        function get mouseX():Number;
        function get mouseY():Number;
        function set height(_arg1:Number):void;
        function set mask(_arg1:DisplayObject):void;
        function getRect(_arg1:DisplayObject):Rectangle;
        function get alpha():Number;
        function set transform(_arg1:Transform):void;
        function move(_arg1:Number, _arg2:Number):void;
        function get loaderInfo():LoaderInfo;
        function get root():DisplayObject;
        function hitTestObject(_arg1:DisplayObject):Boolean;
        function set opaqueBackground(_arg1:Object):void;
        function set visible(_arg1:Boolean):void;
        function get mask():DisplayObject;
        function set x(_arg1:Number):void;
        function set y(_arg1:Number):void;
        function get transform():Transform;
        function set filters(_arg1:Array):void;
        function get x():Number;
        function get y():Number;
        function get filters():Array;
        function set rotation(_arg1:Number):void;
        function get stage():Stage;

    }
}//package mx.core 
﻿package mx.core {

    public interface IMXMLObject {

        function initialized(_arg1:Object, _arg2:String):void;

    }
}//package mx.core 
﻿package mx.core {
    import flash.events.*;

    public interface IPropertyChangeNotifier extends IEventDispatcher, IUID {

    }
}//package mx.core 
﻿package mx.core {

    public class Singleton {

        mx_internal static const VERSION:String = "3.5.0.12683";

        private static var classMap:Object = {};

        public static function registerClass(_arg1:String, _arg2:Class):void{
            var _local3:Class = classMap[_arg1];
            if (!_local3){
                classMap[_arg1] = _arg2;
            };
        }
        public static function getClass(_arg1:String):Class{
            return (classMap[_arg1]);
        }
        public static function getInstance(_arg1:String):Object{
            var _local2:Class = classMap[_arg1];
            if (!_local2){
                throw (new Error((("No class registered for interface '" + _arg1) + "'.")));
            };
            return (_local2["getInstance"]());
        }

    }
}//package mx.core 
﻿package mx.core {
    import flash.utils.*;

    public class ByteArrayAsset extends ByteArray implements IFlexAsset {

        mx_internal static const VERSION:String = "3.5.0.12683";

    }
}//package mx.core 
﻿package mx.core {

    public namespace mx_internal = "http://www.adobe.com/2006/flex/mx/internal";
}//package mx.core 
﻿package mx.core {
    import flash.display.*;

    public interface IUIComponent extends IFlexDisplayObject {

        function set focusPane(_arg1:Sprite):void;
        function get enabled():Boolean;
        function set enabled(_arg1:Boolean):void;
        function set isPopUp(_arg1:Boolean):void;
        function get explicitMinHeight():Number;
        function get percentWidth():Number;
        function get isPopUp():Boolean;
        function get owner():DisplayObjectContainer;
        function get percentHeight():Number;
        function get baselinePosition():Number;
        function initialize():void;
        function get maxWidth():Number;
        function get minWidth():Number;
        function getExplicitOrMeasuredWidth():Number;
        function get explicitMaxWidth():Number;
        function get explicitMaxHeight():Number;
        function set percentHeight(_arg1:Number):void;
        function get minHeight():Number;
        function set percentWidth(_arg1:Number):void;
        function get document():Object;
        function get focusPane():Sprite;
        function getExplicitOrMeasuredHeight():Number;
        function set tweeningProperties(_arg1:Array):void;
        function set explicitWidth(_arg1:Number):void;
        function set measuredMinHeight(_arg1:Number):void;
        function get explicitMinWidth():Number;
        function get tweeningProperties():Array;
        function get maxHeight():Number;
        function set owner(_arg1:DisplayObjectContainer):void;
        function set includeInLayout(_arg1:Boolean):void;
        function setVisible(_arg1:Boolean, _arg2:Boolean=false):void;
        function parentChanged(_arg1:DisplayObjectContainer):void;
        function get explicitWidth():Number;
        function get measuredMinHeight():Number;
        function set measuredMinWidth(_arg1:Number):void;
        function set explicitHeight(_arg1:Number):void;
        function get includeInLayout():Boolean;
        function get measuredMinWidth():Number;
        function get explicitHeight():Number;
        function owns(_arg1:DisplayObject):Boolean;
        function set document(_arg1:Object):void;

    }
}//package mx.core 
﻿package mx.core {

    public interface IFlexAsset {

    }
}//package mx.core 
﻿package mx.collections {
    import mx.rpc.*;
    import mx.core.*;

    public class ItemResponder implements IResponder {

        mx_internal static const VERSION:String = "3.5.0.12683";

        private var _faultHandler:Function;
        private var _token:Object;
        private var _resultHandler:Function;

        public function ItemResponder(_arg1:Function, _arg2:Function, _arg3:Object=null){
            _resultHandler = _arg1;
            _faultHandler = _arg2;
            _token = _arg3;
        }
        public function result(_arg1:Object):void{
            _resultHandler(_arg1, _token);
        }
        public function fault(_arg1:Object):void{
            _faultHandler(_arg1, _token);
        }

    }
}//package mx.collections 
﻿package mx.collections {
    import flash.events.*;
    import mx.resources.*;
    import mx.utils.*;
    import mx.core.*;
    import mx.collections.errors.*;

    public class SortField extends EventDispatcher {

        private var _caseInsensitive:Boolean;
        private var _numeric:Object;
        private var _descending:Boolean;
        private var _compareFunction:Function;
        private var _usingCustomCompareFunction:Boolean;
        private var _name:String;
        private var resourceManager:IResourceManager;

        public function SortField(_arg1:String=null, _arg2:Boolean=false, _arg3:Boolean=false, _arg4:Object=null){
            resourceManager = ResourceManager.getInstance();
            super();
            _name = _arg1;
            _caseInsensitive = _arg2;
            _descending = _arg3;
            _numeric = _arg4;
            _compareFunction = stringCompare;
        }
        public function get caseInsensitive():Boolean{
            return (_caseInsensitive);
        }
        mx_internal function get usingCustomCompareFunction():Boolean{
            return (_usingCustomCompareFunction);
        }
        public function set caseInsensitive(_arg1:Boolean):void{
            if (_arg1 != _caseInsensitive){
                _caseInsensitive = _arg1;
                dispatchEvent(new Event("caseInsensitiveChanged"));
            };
        }
        public function get name():String{
            return (_name);
        }
        public function get numeric():Object{
            return (_numeric);
        }
        public function set name(_arg1:String):void{
            _name = _arg1;
            dispatchEvent(new Event("nameChanged"));
        }
        private function numericCompare(_arg1:Object, _arg2:Object):int{
            var fa:* = NaN;
            var fb:* = NaN;
            var a:* = _arg1;
            var b:* = _arg2;
            try {
                fa = (((_name == null)) ? Number(a) : Number(a[_name]));
            } catch(error:Error) {
            };
            try {
                fb = (((_name == null)) ? Number(b) : Number(b[_name]));
            } catch(error:Error) {
            };
            return (ObjectUtil.numericCompare(fa, fb));
        }
        public function set numeric(_arg1:Object):void{
            if (_numeric != _arg1){
                _numeric = _arg1;
                dispatchEvent(new Event("numericChanged"));
            };
        }
        private function stringCompare(_arg1:Object, _arg2:Object):int{
            var fa:* = null;
            var fb:* = null;
            var a:* = _arg1;
            var b:* = _arg2;
            try {
                fa = (((_name == null)) ? String(a) : String(a[_name]));
            } catch(error:Error) {
            };
            try {
                fb = (((_name == null)) ? String(b) : String(b[_name]));
            } catch(error:Error) {
            };
            return (ObjectUtil.stringCompare(fa, fb, _caseInsensitive));
        }
        public function get compareFunction():Function{
            return (_compareFunction);
        }
        public function reverse():void{
            descending = !(descending);
        }
        mx_internal function getArraySortOnOptions():int{
            if (((((((usingCustomCompareFunction) || ((name == null)))) || ((_compareFunction == xmlCompare)))) || ((_compareFunction == dateCompare)))){
                return (-1);
            };
            var _local1:int;
            if (caseInsensitive){
                _local1 = (_local1 | Array.CASEINSENSITIVE);
            };
            if (descending){
                _local1 = (_local1 | Array.DESCENDING);
            };
            if ((((numeric == true)) || ((_compareFunction == numericCompare)))){
                _local1 = (_local1 | Array.NUMERIC);
            };
            return (_local1);
        }
        private function dateCompare(_arg1:Object, _arg2:Object):int{
            var fa:* = null;
            var fb:* = null;
            var a:* = _arg1;
            var b:* = _arg2;
            try {
                fa = (((_name == null)) ? (a as Date) : (a[_name] as Date));
            } catch(error:Error) {
            };
            try {
                fb = (((_name == null)) ? (b as Date) : (b[_name] as Date));
            } catch(error:Error) {
            };
            return (ObjectUtil.dateCompare(fa, fb));
        }
        mx_internal function internalCompare(_arg1:Object, _arg2:Object):int{
            var _local3:int = compareFunction(_arg1, _arg2);
            if (descending){
                _local3 = (_local3 * -1);
            };
            return (_local3);
        }
        override public function toString():String{
            return (ObjectUtil.toString(this));
        }
        private function nullCompare(_arg1:Object, _arg2:Object):int{
            var value:* = null;
            var left:* = null;
            var right:* = null;
            var message:* = null;
            var a:* = _arg1;
            var b:* = _arg2;
            var found:* = false;
            if ((((a == null)) && ((b == null)))){
                return (0);
            };
            if (_name){
                try {
                    left = a[_name];
                } catch(error:Error) {
                };
                try {
                    right = b[_name];
                } catch(error:Error) {
                };
            };
            if ((((left == null)) && ((right == null)))){
                return (0);
            };
            if ((((left == null)) && (!(_name)))){
                left = a;
            };
            if ((((right == null)) && (!(_name)))){
                right = b;
            };
            var typeLeft:* = typeof(left);
            var typeRight:* = typeof(right);
            if ((((typeLeft == "string")) || ((typeRight == "string")))){
                found = true;
                _compareFunction = stringCompare;
            } else {
                if ((((typeLeft == "object")) || ((typeRight == "object")))){
                    if ((((left is Date)) || ((right is Date)))){
                        found = true;
                        _compareFunction = dateCompare;
                    };
                } else {
                    if ((((typeLeft == "xml")) || ((typeRight == "xml")))){
                        found = true;
                        _compareFunction = xmlCompare;
                    } else {
                        if ((((((((typeLeft == "number")) || ((typeRight == "number")))) || ((typeLeft == "boolean")))) || ((typeRight == "boolean")))){
                            found = true;
                            _compareFunction = numericCompare;
                        };
                    };
                };
            };
            if (found){
                return (_compareFunction(left, right));
            };
            message = resourceManager.getString("collections", "noComparatorSortField", [name]);
            throw (new SortError(message));
        }
        public function set descending(_arg1:Boolean):void{
            if (_descending != _arg1){
                _descending = _arg1;
                dispatchEvent(new Event("descendingChanged"));
            };
        }
        mx_internal function initCompare(_arg1:Object):void{
            var value:* = null;
            var typ:* = null;
            var test:* = null;
            var obj:* = _arg1;
            if (!usingCustomCompareFunction){
                if (numeric == true){
                    _compareFunction = numericCompare;
                } else {
                    if (((caseInsensitive) || ((numeric == false)))){
                        _compareFunction = stringCompare;
                    } else {
                        if (_name){
                            try {
                                value = obj[_name];
                            } catch(error:Error) {
                            };
                        };
                        if (value == null){
                            value = obj;
                        };
                        typ = typeof(value);
                        switch (typ){
                            case "string":
                                _compareFunction = stringCompare;
                                break;
                            case "object":
                                if ((value is Date)){
                                    _compareFunction = dateCompare;
                                } else {
                                    _compareFunction = stringCompare;
                                    try {
                                        test = value.toString();
                                    } catch(error2:Error) {
                                    };
                                    if (((!(test)) || ((test == "[object Object]")))){
                                        _compareFunction = nullCompare;
                                    };
                                };
                                break;
                            case "xml":
                                _compareFunction = xmlCompare;
                                break;
                            case "boolean":
                            case "number":
                                _compareFunction = numericCompare;
                                break;
                        };
                    };
                };
            };
        }
        public function get descending():Boolean{
            return (_descending);
        }
        public function set compareFunction(_arg1:Function):void{
            _compareFunction = _arg1;
            _usingCustomCompareFunction = !((_arg1 == null));
        }
        private function xmlCompare(_arg1:Object, _arg2:Object):int{
            var sa:* = null;
            var sb:* = null;
            var a:* = _arg1;
            var b:* = _arg2;
            try {
                sa = (((_name == null)) ? a.toString() : a[_name].toString());
            } catch(error:Error) {
            };
            try {
                sb = (((_name == null)) ? b.toString() : b[_name].toString());
            } catch(error:Error) {
            };
            if (numeric == true){
                return (ObjectUtil.numericCompare(parseFloat(sa), parseFloat(sb)));
            };
            return (ObjectUtil.stringCompare(sa, sb, _caseInsensitive));
        }

    }
}//package mx.collections 
﻿package mx.collections {
    import flash.events.*;

    public interface IList extends IEventDispatcher {

        function addItem(_arg1:Object):void;
        function get length():int;
        function addItemAt(_arg1:Object, _arg2:int):void;
        function itemUpdated(_arg1:Object, _arg2:Object=null, _arg3:Object=null, _arg4:Object=null):void;
        function getItemIndex(_arg1:Object):int;
        function removeItemAt(_arg1:int):Object;
        function getItemAt(_arg1:int, _arg2:int=0):Object;
        function removeAll():void;
        function toArray():Array;
        function setItemAt(_arg1:Object, _arg2:int):Object;

    }
}//package mx.collections 
﻿package mx.collections {
    import flash.events.*;
    import mx.events.*;
    import flash.utils.*;
    import mx.resources.*;
    import mx.utils.*;
    import mx.core.*;

    public class ArrayList extends EventDispatcher implements IList, IExternalizable, IPropertyChangeNotifier {

        mx_internal static const VERSION:String = "3.5.0.12683";

        private var _source:Array;
        private var _dispatchEvents:int = 0;
        private var _uid:String;
        private var resourceManager:IResourceManager;

        public function ArrayList(_arg1:Array=null){
            resourceManager = ResourceManager.getInstance();
            super();
            disableEvents();
            this.source = _arg1;
            enableEvents();
            _uid = UIDUtil.createUID();
        }
        public function addAll(_arg1:IList):void{
            addAllAt(_arg1, length);
        }
        public function readExternal(_arg1:IDataInput):void{
            source = _arg1.readObject();
        }
        private function internalDispatchEvent(_arg1:String, _arg2:Object=null, _arg3:int=-1):void{
            var _local4:CollectionEvent;
            var _local5:PropertyChangeEvent;
            if (_dispatchEvents == 0){
                if (hasEventListener(CollectionEvent.COLLECTION_CHANGE)){
                    _local4 = new CollectionEvent(CollectionEvent.COLLECTION_CHANGE);
                    _local4.kind = _arg1;
                    _local4.items.push(_arg2);
                    _local4.location = _arg3;
                    dispatchEvent(_local4);
                };
                if (((hasEventListener(PropertyChangeEvent.PROPERTY_CHANGE)) && ((((_arg1 == CollectionEventKind.ADD)) || ((_arg1 == CollectionEventKind.REMOVE)))))){
                    _local5 = new PropertyChangeEvent(PropertyChangeEvent.PROPERTY_CHANGE);
                    _local5.property = _arg3;
                    if (_arg1 == CollectionEventKind.ADD){
                        _local5.newValue = _arg2;
                    } else {
                        _local5.oldValue = _arg2;
                    };
                    dispatchEvent(_local5);
                };
            };
        }
        public function removeAll():void{
            var _local1:int;
            var _local2:int;
            if (length > 0){
                _local1 = length;
                _local2 = 0;
                while (_local2 < _local1) {
                    stopTrackUpdates(source[_local2]);
                    _local2++;
                };
                source.splice(0, length);
                internalDispatchEvent(CollectionEventKind.RESET);
            };
        }
        public function getItemIndex(_arg1:Object):int{
            return (ArrayUtil.getItemIndex(_arg1, source));
        }
        public function removeItemAt(_arg1:int):Object{
            var _local3:String;
            if ((((_arg1 < 0)) || ((_arg1 >= length)))){
                _local3 = resourceManager.getString("collections", "outOfBounds", [_arg1]);
                throw (new RangeError(_local3));
            };
            var _local2:Object = source.splice(_arg1, 1)[0];
            stopTrackUpdates(_local2);
            internalDispatchEvent(CollectionEventKind.REMOVE, _local2, _arg1);
            return (_local2);
        }
        public function addAllAt(_arg1:IList, _arg2:int):void{
            var _local3:int = _arg1.length;
            var _local4:int;
            while (_local4 < _local3) {
                this.addItemAt(_arg1.getItemAt(_local4), (_local4 + _arg2));
                _local4++;
            };
        }
        public function itemUpdated(_arg1:Object, _arg2:Object=null, _arg3:Object=null, _arg4:Object=null):void{
            var _local5:PropertyChangeEvent = new PropertyChangeEvent(PropertyChangeEvent.PROPERTY_CHANGE);
            _local5.kind = PropertyChangeEventKind.UPDATE;
            _local5.source = _arg1;
            _local5.property = _arg2;
            _local5.oldValue = _arg3;
            _local5.newValue = _arg4;
            itemUpdateHandler(_local5);
        }
        public function get uid():String{
            return (_uid);
        }
        public function writeExternal(_arg1:IDataOutput):void{
            _arg1.writeObject(_source);
        }
        public function addItem(_arg1:Object):void{
            addItemAt(_arg1, length);
        }
        public function toArray():Array{
            return (source.concat());
        }
        public function get source():Array{
            return (_source);
        }
        public function getItemAt(_arg1:int, _arg2:int=0):Object{
            var _local3:String;
            if ((((_arg1 < 0)) || ((_arg1 >= length)))){
                _local3 = resourceManager.getString("collections", "outOfBounds", [_arg1]);
                throw (new RangeError(_local3));
            };
            return (source[_arg1]);
        }
        public function set uid(_arg1:String):void{
            _uid = _arg1;
        }
        public function setItemAt(_arg1:Object, _arg2:int):Object{
            var _local4:String;
            var _local5:Boolean;
            var _local6:Boolean;
            var _local7:PropertyChangeEvent;
            var _local8:CollectionEvent;
            if ((((_arg2 < 0)) || ((_arg2 >= length)))){
                _local4 = resourceManager.getString("collections", "outOfBounds", [_arg2]);
                throw (new RangeError(_local4));
            };
            var _local3:Object = source[_arg2];
            source[_arg2] = _arg1;
            stopTrackUpdates(_local3);
            startTrackUpdates(_arg1);
            if (_dispatchEvents == 0){
                _local5 = hasEventListener(CollectionEvent.COLLECTION_CHANGE);
                _local6 = hasEventListener(PropertyChangeEvent.PROPERTY_CHANGE);
                if (((_local5) || (_local6))){
                    _local7 = new PropertyChangeEvent(PropertyChangeEvent.PROPERTY_CHANGE);
                    _local7.kind = PropertyChangeEventKind.UPDATE;
                    _local7.oldValue = _local3;
                    _local7.newValue = _arg1;
                    _local7.property = _arg2;
                };
                if (_local5){
                    _local8 = new CollectionEvent(CollectionEvent.COLLECTION_CHANGE);
                    _local8.kind = CollectionEventKind.REPLACE;
                    _local8.location = _arg2;
                    _local8.items.push(_local7);
                    dispatchEvent(_local8);
                };
                if (_local6){
                    dispatchEvent(_local7);
                };
            };
            return (_local3);
        }
        public function get length():int{
            if (source){
                return (source.length);
            };
            return (0);
        }
        private function disableEvents():void{
            _dispatchEvents--;
        }
        protected function itemUpdateHandler(_arg1:PropertyChangeEvent):void{
            var _local2:PropertyChangeEvent;
            var _local3:uint;
            internalDispatchEvent(CollectionEventKind.UPDATE, _arg1);
            if ((((_dispatchEvents == 0)) && (hasEventListener(PropertyChangeEvent.PROPERTY_CHANGE)))){
                _local2 = PropertyChangeEvent(_arg1.clone());
                _local3 = getItemIndex(_arg1.target);
                _local2.property = ((_local3.toString() + ".") + _arg1.property);
                dispatchEvent(_local2);
            };
        }
        public function addItemAt(_arg1:Object, _arg2:int):void{
            var _local3:String;
            if ((((_arg2 < 0)) || ((_arg2 > length)))){
                _local3 = resourceManager.getString("collections", "outOfBounds", [_arg2]);
                throw (new RangeError(_local3));
            };
            source.splice(_arg2, 0, _arg1);
            startTrackUpdates(_arg1);
            internalDispatchEvent(CollectionEventKind.ADD, _arg1, _arg2);
        }
        public function removeItem(_arg1:Object):Boolean{
            var _local2:int = getItemIndex(_arg1);
            var _local3 = (_local2 >= 0);
            if (_local3){
                removeItemAt(_local2);
            };
            return (_local3);
        }
        protected function stopTrackUpdates(_arg1:Object):void{
            if (((_arg1) && ((_arg1 is IEventDispatcher)))){
                IEventDispatcher(_arg1).removeEventListener(PropertyChangeEvent.PROPERTY_CHANGE, itemUpdateHandler);
            };
        }
        protected function startTrackUpdates(_arg1:Object):void{
            if (((_arg1) && ((_arg1 is IEventDispatcher)))){
                IEventDispatcher(_arg1).addEventListener(PropertyChangeEvent.PROPERTY_CHANGE, itemUpdateHandler, false, 0, true);
            };
        }
        override public function toString():String{
            if (source){
                return (source.toString());
            };
            return (getQualifiedClassName(this));
        }
        private function enableEvents():void{
            _dispatchEvents++;
            if (_dispatchEvents > 0){
                _dispatchEvents = 0;
            };
        }
        public function set source(_arg1:Array):void{
            var _local2:int;
            var _local3:int;
            var _local4:CollectionEvent;
            if (((_source) && (_source.length))){
                _local3 = _source.length;
                _local2 = 0;
                while (_local2 < _local3) {
                    stopTrackUpdates(_source[_local2]);
                    _local2++;
                };
            };
            _source = ((_arg1) ? _arg1 : []);
            _local3 = _source.length;
            _local2 = 0;
            while (_local2 < _local3) {
                startTrackUpdates(_source[_local2]);
                _local2++;
            };
            if (_dispatchEvents == 0){
                _local4 = new CollectionEvent(CollectionEvent.COLLECTION_CHANGE);
                _local4.kind = CollectionEventKind.RESET;
                dispatchEvent(_local4);
            };
        }

    }
}//package mx.collections 
﻿package mx.collections {
    import flash.events.*;
    import mx.resources.*;
    import mx.utils.*;
    import mx.collections.errors.*;

    public class Sort extends EventDispatcher {

        public static const ANY_INDEX_MODE:String = "any";
        public static const LAST_INDEX_MODE:String = "last";
        public static const FIRST_INDEX_MODE:String = "first";

        private var noFieldsDescending:Boolean = false;
        private var usingCustomCompareFunction:Boolean;
        private var defaultEmptyField:SortField;
        private var _fields:Array;
        private var _compareFunction:Function;
        private var _unique:Boolean;
        private var fieldList:Array;
        private var resourceManager:IResourceManager;

        public function Sort(){
            resourceManager = ResourceManager.getInstance();
            fieldList = [];
            super();
        }
        public function get unique():Boolean{
            return (_unique);
        }
        public function get compareFunction():Function{
            return (((usingCustomCompareFunction) ? _compareFunction : internalCompare));
        }
        public function set unique(_arg1:Boolean):void{
            _unique = _arg1;
        }
        public function sort(_arg1:Array):void{
            const fixedCompareFunction:* = null;
            var message:* = null;
            var uniqueRet1:* = null;
            var fields:* = null;
            var i:* = 0;
            var sortArgs:* = null;
            var uniqueRet2:* = null;
            var items:* = _arg1;
            if (((!(items)) || ((items.length <= 1)))){
                return;
            };
            if (usingCustomCompareFunction){
                fixedCompareFunction = function (_arg1:Object, _arg2:Object):int{
                    return (compareFunction(_arg1, _arg2, _fields));
                };
                if (unique){
                    uniqueRet1 = items.sort(fixedCompareFunction, Array.UNIQUESORT);
                    if (uniqueRet1 == 0){
                        message = resourceManager.getString("collections", "nonUnique");
                        throw (new SortError(message));
                    };
                } else {
                    items.sort(fixedCompareFunction);
                };
            } else {
                fields = this.fields;
                if (((fields) && ((fields.length > 0)))){
                    sortArgs = initSortFields(items[0], true);
                    if (unique){
                        if (((sortArgs) && ((fields.length == 1)))){
                            uniqueRet2 = items.sortOn(sortArgs.fields[0], (sortArgs.options[0] | Array.UNIQUESORT));
                        } else {
                            uniqueRet2 = items.sort(internalCompare, Array.UNIQUESORT);
                        };
                        if (uniqueRet2 == 0){
                            message = resourceManager.getString("collections", "nonUnique");
                            throw (new SortError(message));
                        };
                    } else {
                        if (sortArgs){
                            items.sortOn(sortArgs.fields, sortArgs.options);
                        } else {
                            items.sort(internalCompare);
                        };
                    };
                } else {
                    items.sort(internalCompare);
                };
            };
        }
        public function propertyAffectsSort(_arg1:String):Boolean{
            var _local3:SortField;
            if (((usingCustomCompareFunction) || (!(fields)))){
                return (true);
            };
            var _local2:int;
            while (_local2 < fields.length) {
                _local3 = fields[_local2];
                if ((((_local3.name == _arg1)) || (_local3.usingCustomCompareFunction))){
                    return (true);
                };
                _local2++;
            };
            return (false);
        }
        private function internalCompare(_arg1:Object, _arg2:Object, _arg3:Array=null):int{
            var _local5:int;
            var _local6:int;
            var _local7:SortField;
            var _local4:int;
            if (!_fields){
                _local4 = noFieldsCompare(_arg1, _arg2);
            } else {
                _local5 = 0;
                _local6 = ((_arg3) ? _arg3.length : _fields.length);
                while ((((_local4 == 0)) && ((_local5 < _local6)))) {
                    _local7 = SortField(_fields[_local5]);
                    _local4 = _local7.internalCompare(_arg1, _arg2);
                    _local5++;
                };
            };
            return (_local4);
        }
        public function reverse():void{
            var _local1:int;
            if (fields){
                _local1 = 0;
                while (_local1 < fields.length) {
                    SortField(fields[_local1]).reverse();
                    _local1++;
                };
            };
            noFieldsDescending = !(noFieldsDescending);
        }
        private function noFieldsCompare(_arg1:Object, _arg2:Object, _arg3:Array=null):int{
            var message:* = null;
            var a:* = _arg1;
            var b:* = _arg2;
            var fields = _arg3;
            if (!defaultEmptyField){
                defaultEmptyField = new SortField();
                try {
                    defaultEmptyField.initCompare(a);
                } catch(e:SortError) {
                    message = resourceManager.getString("collections", "noComparator", [a]);
                    throw (new SortError(message));
                };
            };
            var result:* = defaultEmptyField.compareFunction(a, b);
            if (noFieldsDescending){
                result = (result * -1);
            };
            return (result);
        }
        public function findItem(_arg1:Array, _arg2:Object, _arg3:String, _arg4:Boolean=false, _arg5:Function=null):int{
            var compareForFind:* = null;
            var fieldsForCompare:* = null;
            var message:* = null;
            var index:* = 0;
            var fieldName:* = null;
            var hadPreviousFieldName:* = false;
            var i:* = 0;
            var hasFieldName:* = false;
            var objIndex:* = 0;
            var match:* = false;
            var prevCompare:* = 0;
            var nextCompare:* = 0;
            var items:* = _arg1;
            var values:* = _arg2;
            var mode:* = _arg3;
            var returnInsertionIndex:Boolean = _arg4;
            var compareFunction = _arg5;
            if (!items){
                message = resourceManager.getString("collections", "noItems");
                throw (new SortError(message));
            };
            if (items.length == 0){
                return (((returnInsertionIndex) ? 1 : -1));
            };
            if (compareFunction == null){
                compareForFind = this.compareFunction;
                if (((values) && ((fieldList.length > 0)))){
                    fieldsForCompare = [];
                    hadPreviousFieldName = true;
                    i = 0;
                    while (i < fieldList.length) {
                        fieldName = fieldList[i];
                        if (fieldName){
                            try {
                                hasFieldName = !((values[fieldName] === undefined));
                            } catch(e:Error) {
                                hasFieldName = false;
                            };
                            if (hasFieldName){
                                if (!hadPreviousFieldName){
                                    message = resourceManager.getString("collections", "findCondition", [fieldName]);
                                    throw (new SortError(message));
                                };
                                fieldsForCompare.push(fieldName);
                            } else {
                                hadPreviousFieldName = false;
                            };
                        } else {
                            fieldsForCompare.push(null);
                        };
                        i = (i + 1);
                    };
                    if (fieldsForCompare.length == 0){
                        message = resourceManager.getString("collections", "findRestriction");
                        throw (new SortError(message));
                    };
                    try {
                        initSortFields(items[0]);
                    } catch(initSortError:SortError) {
                    };
                };
            } else {
                compareForFind = compareFunction;
            };
            var found:* = false;
            var objFound:* = false;
            index = 0;
            var lowerBound:* = 0;
            var upperBound:* = (items.length - 1);
            var obj:* = null;
            var direction:* = 1;
            while (((!(objFound)) && ((lowerBound <= upperBound)))) {
                index = Math.round(((lowerBound + upperBound) / 2));
                obj = items[index];
                direction = ((fieldsForCompare) ? compareForFind(values, obj, fieldsForCompare) : compareForFind(values, obj));
                switch (direction){
                    case -1:
                        upperBound = (index - 1);
                        break;
                    case 0:
                        objFound = true;
                        switch (mode){
                            case ANY_INDEX_MODE:
                                found = true;
                                break;
                            case FIRST_INDEX_MODE:
                                found = (index == lowerBound);
                                objIndex = (index - 1);
                                match = true;
                                while (((((match) && (!(found)))) && ((objIndex >= lowerBound)))) {
                                    obj = items[objIndex];
                                    prevCompare = ((fieldsForCompare) ? compareForFind(values, obj, fieldsForCompare) : compareForFind(values, obj));
                                    match = (prevCompare == 0);
                                    if (((!(match)) || (((match) && ((objIndex == lowerBound)))))){
                                        found = true;
                                        index = (objIndex + ((match) ? 0 : 1));
                                    };
                                    objIndex = (objIndex - 1);
                                };
                                break;
                            case LAST_INDEX_MODE:
                                found = (index == upperBound);
                                objIndex = (index + 1);
                                match = true;
                                while (((((match) && (!(found)))) && ((objIndex <= upperBound)))) {
                                    obj = items[objIndex];
                                    nextCompare = ((fieldsForCompare) ? compareForFind(values, obj, fieldsForCompare) : compareForFind(values, obj));
                                    match = (nextCompare == 0);
                                    if (((!(match)) || (((match) && ((objIndex == upperBound)))))){
                                        found = true;
                                        index = (objIndex - ((match) ? 0 : 1));
                                    };
                                    objIndex = (objIndex + 1);
                                };
                                break;
                            default:
                                message = resourceManager.getString("collections", "unknownMode");
                                throw (new SortError(message));
                        };
                        break;
                    case 1:
                        lowerBound = (index + 1);
                        break;
                };
            };
            if (((!(found)) && (!(returnInsertionIndex)))){
                return (-1);
            };
            return (((direction)>0) ? (index + 1) : index);
        }
        private function initSortFields(_arg1:Object, _arg2:Boolean=false):Object{
            var _local4:int;
            var _local5:SortField;
            var _local6:int;
            var _local3:Object;
            _local4 = 0;
            while (_local4 < fields.length) {
                SortField(fields[_local4]).initCompare(_arg1);
                _local4++;
            };
            if (_arg2){
                _local3 = {
                    fields:[],
                    options:[]
                };
                _local4 = 0;
                while (_local4 < fields.length) {
                    _local5 = fields[_local4];
                    _local6 = _local5.getArraySortOnOptions();
                    if (_local6 == -1){
                        return (null);
                    };
                    _local3.fields.push(_local5.name);
                    _local3.options.push(_local6);
                    _local4++;
                };
            };
            return (_local3);
        }
        public function set fields(_arg1:Array):void{
            var _local2:SortField;
            var _local3:int;
            _fields = _arg1;
            fieldList = [];
            if (_fields){
                _local3 = 0;
                while (_local3 < _fields.length) {
                    _local2 = SortField(_fields[_local3]);
                    fieldList.push(_local2.name);
                    _local3++;
                };
            };
            dispatchEvent(new Event("fieldsChanged"));
        }
        public function get fields():Array{
            return (_fields);
        }
        public function set compareFunction(_arg1:Function):void{
            _compareFunction = _arg1;
            usingCustomCompareFunction = !((_compareFunction == null));
        }
        override public function toString():String{
            return (ObjectUtil.toString(this));
        }

    }
}//package mx.collections 
﻿package mx.collections {
    import flash.events.*;

    public interface IViewCursor extends IEventDispatcher {

        function get current():Object;
        function moveNext():Boolean;
        function get view():ICollectionView;
        function movePrevious():Boolean;
        function remove():Object;
        function findLast(_arg1:Object):Boolean;
        function get beforeFirst():Boolean;
        function get afterLast():Boolean;
        function findAny(_arg1:Object):Boolean;
        function get bookmark():CursorBookmark;
        function findFirst(_arg1:Object):Boolean;
        function seek(_arg1:CursorBookmark, _arg2:int=0, _arg3:int=0):void;
        function insert(_arg1:Object):void;

    }
}//package mx.collections 
﻿package mx.collections {
    import mx.core.*;

    public class CursorBookmark {

        mx_internal static const VERSION:String = "3.5.0.12683";

        private static var _first:CursorBookmark;
        private static var _last:CursorBookmark;
        private static var _current:CursorBookmark;

        private var _value:Object;

        public function CursorBookmark(_arg1:Object){
            _value = _arg1;
        }
        public static function get LAST():CursorBookmark{
            if (!_last){
                _last = new CursorBookmark("${L}");
            };
            return (_last);
        }
        public static function get FIRST():CursorBookmark{
            if (!_first){
                _first = new CursorBookmark("${F}");
            };
            return (_first);
        }
        public static function get CURRENT():CursorBookmark{
            if (!_current){
                _current = new CursorBookmark("${C}");
            };
            return (_current);
        }

        public function get value():Object{
            return (_value);
        }
        public function getViewIndex():int{
            return (-1);
        }

    }
}//package mx.collections 
﻿package mx.collections {
    import flash.events.*;
    import mx.events.*;
    import flash.utils.*;
    import mx.resources.*;
    import mx.utils.*;
    import mx.core.*;
    import mx.collections.errors.*;

    public class ListCollectionView extends Proxy implements ICollectionView, IList, IMXMLObject {

        private var autoUpdateCounter:int;
        private var _list:IList;
        private var _filterFunction:Function;
        protected var localIndex:Array;
        mx_internal var dispatchResetEvent:Boolean = true;
        private var pendingUpdates:Array;
        private var resourceManager:IResourceManager;
        private var eventDispatcher:EventDispatcher;
        private var revision:int;
        private var _sort:Sort;

        public function ListCollectionView(_arg1:IList=null){
            resourceManager = ResourceManager.getInstance();
            super();
            eventDispatcher = new EventDispatcher(this);
            this.list = _arg1;
        }
        private function handlePendingUpdates():void{
            var _local1:Array;
            var _local2:CollectionEvent;
            var _local3:int;
            var _local4:CollectionEvent;
            var _local5:int;
            if (pendingUpdates){
                _local1 = pendingUpdates;
                pendingUpdates = null;
                _local3 = 0;
                while (_local3 < _local1.length) {
                    _local4 = _local1[_local3];
                    if (_local4.kind == CollectionEventKind.UPDATE){
                        if (!_local2){
                            _local2 = _local4;
                        } else {
                            _local5 = 0;
                            while (_local5 < _local4.items.length) {
                                _local2.items.push(_local4.items[_local5]);
                                _local5++;
                            };
                        };
                    } else {
                        listChangeHandler(_local4);
                    };
                    _local3++;
                };
                if (_local2){
                    listChangeHandler(_local2);
                };
            };
        }
        private function replaceItemsInView(_arg1:Array, _arg2:int, _arg3:Boolean=true):void{
            var _local4:int;
            var _local5:Array;
            var _local6:Array;
            var _local7:int;
            var _local8:PropertyChangeEvent;
            var _local9:CollectionEvent;
            if (localIndex){
                _local4 = _arg1.length;
                _local5 = [];
                _local6 = [];
                _local7 = 0;
                while (_local7 < _local4) {
                    _local8 = _arg1[_local7];
                    _local5.push(_local8.oldValue);
                    _local6.push(_local8.newValue);
                    _local7++;
                };
                removeItemsFromView(_local5, _arg2, _arg3);
                addItemsToView(_local6, _arg2, _arg3);
            } else {
                _local9 = new CollectionEvent(CollectionEvent.COLLECTION_CHANGE);
                _local9.kind = CollectionEventKind.REPLACE;
                _local9.location = _arg2;
                _local9.items = _arg1;
                dispatchEvent(_local9);
            };
        }
        private function getFilteredItemIndex(_arg1:Object):int{
            var _local4:Object;
            var _local5:int;
            var _local6:int;
            var _local2:int = list.getItemIndex(_arg1);
            if (_local2 == 0){
                return (0);
            };
            var _local3:int = (_local2 - 1);
            while (_local3 >= 0) {
                _local4 = list.getItemAt(_local3);
                if (filterFunction(_local4)){
                    _local5 = localIndex.length;
                    _local6 = 0;
                    while (_local6 < _local5) {
                        if (localIndex[_local6] == _local4){
                            return ((_local6 + 1));
                        };
                        _local6++;
                    };
                };
                _local3--;
            };
            return (0);
        }
        public function willTrigger(_arg1:String):Boolean{
            return (eventDispatcher.willTrigger(_arg1));
        }
        mx_internal function findItem(_arg1:Object, _arg2:String, _arg3:Boolean=false):int{
            var _local4:String;
            if (!sort){
                _local4 = resourceManager.getString("collections", "itemNotFound");
                throw (new CollectionViewError(_local4));
            };
            if (localIndex.length == 0){
                return (((_arg3) ? 0 : -1));
            };
            return (sort.findItem(localIndex, _arg1, _arg2, _arg3));
        }
        public function removeEventListener(_arg1:String, _arg2:Function, _arg3:Boolean=false):void{
            eventDispatcher.removeEventListener(_arg1, _arg2, _arg3);
        }
        override "http://www.adobe.com/2006/actionscript/flash/proxy"?? function nextName(_arg1:int):String{
            return ((_arg1 - 1).toString());
        }
        public function removeAll():void{
            var _local2:int;
            var _local1:int = length;
            if (_local1 > 0){
                if (localIndex){
                    _local2 = (_local1 - 1);
                    while (_local2 >= 0) {
                        removeItemAt(_local2);
                        _local2--;
                    };
                } else {
                    list.removeAll();
                };
            };
        }
        override "http://www.adobe.com/2006/actionscript/flash/proxy"?? function hasProperty(_arg1):Boolean{
            var n:* = NaN;
            var name:* = _arg1;
            if ((name is QName)){
                name = name.localName;
            };
            var index:* = -1;
            try {
                n = parseInt(String(name));
                if (!isNaN(n)){
                    index = int(n);
                };
            } catch(e:Error) {
            };
            if (index == -1){
                return (false);
            };
            return ((((index >= 0)) && ((index < length))));
        }
        public function addAllAt(_arg1:IList, _arg2:int):void{
            var _local3:int = _arg1.length;
            var _local4:int;
            while (_local4 < _local3) {
                this.addItemAt(_arg1.getItemAt(_local4), (_local4 + _arg2));
                _local4++;
            };
        }
        public function getItemAt(_arg1:int, _arg2:int=0):Object{
            var _local3:String;
            if ((((_arg1 < 0)) || ((_arg1 >= length)))){
                _local3 = resourceManager.getString("collections", "outOfBounds", [_arg1]);
                throw (new RangeError(_local3));
            };
            if (localIndex){
                return (localIndex[_arg1]);
            };
            if (list){
                return (list.getItemAt(_arg1, _arg2));
            };
            return (null);
        }
        private function moveItemInView(_arg1:Object, _arg2:Boolean=true, _arg3:Array=null):void{
            var _local4:int;
            var _local5:int;
            var _local6:int;
            var _local7:CollectionEvent;
            if (localIndex){
                _local4 = -1;
                _local5 = 0;
                while (_local5 < localIndex.length) {
                    if (localIndex[_local5] == _arg1){
                        _local4 = _local5;
                        break;
                    };
                    _local5++;
                };
                if (_local4 > -1){
                    localIndex.splice(_local4, 1);
                };
                _local6 = addItemsToView([_arg1], _local4, false);
                if (_arg2){
                    _local7 = new CollectionEvent(CollectionEvent.COLLECTION_CHANGE);
                    _local7.items.push(_arg1);
                    if (((((_arg3) && ((_local6 == _local4)))) && ((_local6 > -1)))){
                        _arg3.push(_arg1);
                        return;
                    };
                    if ((((_local6 > -1)) && ((_local4 > -1)))){
                        _local7.kind = CollectionEventKind.MOVE;
                        _local7.location = _local6;
                        _local7.oldLocation = _local4;
                    } else {
                        if (_local6 > -1){
                            _local7.kind = CollectionEventKind.ADD;
                            _local7.location = _local6;
                        } else {
                            if (_local4 > -1){
                                _local7.kind = CollectionEventKind.REMOVE;
                                _local7.location = _local4;
                            } else {
                                _arg2 = false;
                            };
                        };
                    };
                    if (_arg2){
                        dispatchEvent(_local7);
                    };
                };
            };
        }
        public function contains(_arg1:Object):Boolean{
            return (!((getItemIndex(_arg1) == -1)));
        }
        public function get sort():Sort{
            return (_sort);
        }
        private function removeItemsFromView(_arg1:Array, _arg2:int, _arg3:Boolean=true):void{
            var _local6:int;
            var _local7:Object;
            var _local8:int;
            var _local9:CollectionEvent;
            var _local4:Array = ((localIndex) ? [] : _arg1);
            var _local5:int = _arg2;
            if (localIndex){
                _local6 = 0;
                while (_local6 < _arg1.length) {
                    _local7 = _arg1[_local6];
                    _local8 = getItemIndex(_local7);
                    if (_local8 > -1){
                        localIndex.splice(_local8, 1);
                        _local4.push(_local7);
                        _local5 = _local8;
                    };
                    _local6++;
                };
            };
            if (((_arg3) && ((_local4.length > 0)))){
                _local9 = new CollectionEvent(CollectionEvent.COLLECTION_CHANGE);
                _local9.kind = CollectionEventKind.REMOVE;
                _local9.location = ((((!(localIndex)) || ((_local4.length == 1)))) ? _local5 : -1);
                _local9.items = _local4;
                dispatchEvent(_local9);
            };
        }
        public function get list():IList{
            return (_list);
        }
        public function addItemAt(_arg1:Object, _arg2:int):void{
            var _local4:String;
            if ((((((_arg2 < 0)) || (!(list)))) || ((_arg2 > length)))){
                _local4 = resourceManager.getString("collections", "outOfBounds", [_arg2]);
                throw (new RangeError(_local4));
            };
            var _local3:int = _arg2;
            if (((localIndex) && (sort))){
                _local3 = list.length;
            } else {
                if (((localIndex) && (!((filterFunction == null))))){
                    if (_local3 == localIndex.length){
                        _local3 = list.length;
                    } else {
                        _local3 = list.getItemIndex(localIndex[_arg2]);
                    };
                };
            };
            list.addItemAt(_arg1, _local3);
        }
        public function itemUpdated(_arg1:Object, _arg2:Object=null, _arg3:Object=null, _arg4:Object=null):void{
            list.itemUpdated(_arg1, _arg2, _arg3, _arg4);
        }
        private function populateLocalIndex():void{
            if (list){
                localIndex = list.toArray();
            } else {
                localIndex = [];
            };
        }
        private function handlePropertyChangeEvents(_arg1:Array):void{
            var _local3:Array;
            var _local4:Object;
            var _local5:int;
            var _local6:Array;
            var _local7:int;
            var _local8:PropertyChangeEvent;
            var _local9:Object;
            var _local10:Boolean;
            var _local11:int;
            var _local12:int;
            var _local13:int;
            var _local14:int;
            var _local15:CollectionEvent;
            var _local2:Array = _arg1;
            if (((sort) || (!((filterFunction == null))))){
                _local3 = [];
                _local5 = 0;
                while (_local5 < _arg1.length) {
                    _local8 = _arg1[_local5];
                    if (_local8.target){
                        _local9 = _local8.target;
                        _local10 = !((_local8.target == _local8.source));
                    } else {
                        _local9 = _local8.source;
                        _local10 = false;
                    };
                    _local11 = 0;
                    while (_local11 < _local3.length) {
                        if (_local3[_local11].item == _local9){
                            _arg1 = _local3[_local11].events;
                            _local12 = _arg1.length;
                            _local13 = 0;
                            while (_local13 < _local12) {
                                if (_arg1[_local13].property != _local8.property){
                                    _arg1.push(_local8);
                                    break;
                                };
                                _local13++;
                            };
                            break;
                        };
                        _local11++;
                    };
                    if (_local11 < _local3.length){
                        _local4 = _local3[_local11];
                    } else {
                        _local4 = {
                            item:_local9,
                            move:_local10,
                            events:[_local8]
                        };
                        _local3.push(_local4);
                    };
                    _local4.move = ((((((_local4.move) || (filterFunction))) || (!(_local8.property)))) || (((sort) && (sort.propertyAffectsSort(String(_local8.property))))));
                    _local5++;
                };
                _local2 = [];
                _local5 = 0;
                while (_local5 < _local3.length) {
                    _local4 = _local3[_local5];
                    if (_local4.move){
                        moveItemInView(_local4.item, _local4.item, _local2);
                    } else {
                        _local2.push(_local4.item);
                    };
                    _local5++;
                };
                _local6 = [];
                _local7 = 0;
                while (_local7 < _local2.length) {
                    _local14 = 0;
                    while (_local14 < _local3.length) {
                        if (_local2[_local7] == _local3[_local14].item){
                            _local6 = _local6.concat(_local3[_local14].events);
                        };
                        _local14++;
                    };
                    _local7++;
                };
                _local2 = _local6;
            };
            if (_local2.length > 0){
                _local15 = new CollectionEvent(CollectionEvent.COLLECTION_CHANGE);
                _local15.kind = CollectionEventKind.UPDATE;
                _local15.items = _local2;
                dispatchEvent(_local15);
            };
        }
        public function set sort(_arg1:Sort):void{
            _sort = _arg1;
            dispatchEvent(new Event("sortChanged"));
        }
        override "http://www.adobe.com/2006/actionscript/flash/proxy"?? function nextValue(_arg1:int){
            return (getItemAt((_arg1 - 1)));
        }
        public function setItemAt(_arg1:Object, _arg2:int):Object{
            var _local4:String;
            var _local5:Object;
            if ((((((_arg2 < 0)) || (!(list)))) || ((_arg2 >= length)))){
                _local4 = resourceManager.getString("collections", "outOfBounds", [_arg2]);
                throw (new RangeError(_local4));
            };
            var _local3:int = _arg2;
            if (localIndex){
                if (_arg2 > localIndex.length){
                    _local3 = list.length;
                } else {
                    _local5 = localIndex[_arg2];
                    _local3 = list.getItemIndex(_local5);
                };
            };
            return (list.setItemAt(_arg1, _local3));
        }
        mx_internal function getBookmark(_arg1:int):ListCollectionViewBookmark{
            var value:* = null;
            var message:* = null;
            var index:* = _arg1;
            if ((((index < 0)) || ((index > length)))){
                message = resourceManager.getString("collections", "invalidIndex", [index]);
                throw (new CollectionViewError(message));
            };
            try {
                value = getItemAt(index);
            } catch(e:Error) {
                value = null;
            };
            return (new ListCollectionViewBookmark(value, this, revision, index));
        }
        private function addItemsToView(_arg1:Array, _arg2:int, _arg3:Boolean=true):int{
            var _local7:int;
            var _local8:int;
            var _local9:Object;
            var _local10:String;
            var _local11:CollectionEvent;
            var _local4:Array = ((localIndex) ? [] : _arg1);
            var _local5:int = _arg2;
            var _local6:Boolean;
            if (localIndex){
                _local7 = _arg2;
                _local8 = 0;
                while (_local8 < _arg1.length) {
                    _local9 = _arg1[_local8];
                    if ((((filterFunction == null)) || (filterFunction(_local9)))){
                        if (sort){
                            _local7 = findItem(_local9, Sort.ANY_INDEX_MODE, true);
                            if (_local6){
                                _local5 = _local7;
                                _local6 = false;
                            };
                        } else {
                            _local7 = getFilteredItemIndex(_local9);
                            if (_local6){
                                _local5 = _local7;
                                _local6 = false;
                            };
                        };
                        if (((((sort) && (sort.unique))) && ((sort.compareFunction(_local9, localIndex[_local7]) == 0)))){
                            _local10 = resourceManager.getString("collections", "incorrectAddition");
                            throw (new CollectionViewError(_local10));
                        };
                        var _temp1 = _local7;
                        _local7 = (_local7 + 1);
                        localIndex.splice(_temp1, 0, _local9);
                        _local4.push(_local9);
                    } else {
                        _local5 = -1;
                    };
                    _local8++;
                };
            };
            if (((localIndex) && ((_local4.length > 1)))){
                _local5 = -1;
            };
            if (((_arg3) && ((_local4.length > 0)))){
                _local11 = new CollectionEvent(CollectionEvent.COLLECTION_CHANGE);
                _local11.kind = CollectionEventKind.ADD;
                _local11.location = _local5;
                _local11.items = _local4;
                dispatchEvent(_local11);
            };
            return (_local5);
        }
        public function addAll(_arg1:IList):void{
            addAllAt(_arg1, length);
        }
        public function set list(_arg1:IList):void{
            var _local2:Boolean;
            var _local3:Boolean;
            if (_list != _arg1){
                if (_list){
                    _list.removeEventListener(CollectionEvent.COLLECTION_CHANGE, listChangeHandler);
                    _local2 = (_list.length > 0);
                };
                _list = _arg1;
                if (_list){
                    _list.addEventListener(CollectionEvent.COLLECTION_CHANGE, listChangeHandler, false, 0, true);
                    _local3 = (_list.length > 0);
                };
                if (((_local2) || (_local3))){
                    reset();
                };
                dispatchEvent(new Event("listChanged"));
            };
        }
        public function addEventListener(_arg1:String, _arg2:Function, _arg3:Boolean=false, _arg4:int=0, _arg5:Boolean=false):void{
            eventDispatcher.addEventListener(_arg1, _arg2, _arg3, _arg4, _arg5);
        }
        public function dispatchEvent(_arg1:Event):Boolean{
            return (eventDispatcher.dispatchEvent(_arg1));
        }
        public function getItemIndex(_arg1:Object):int{
            var _local2:int;
            var _local3:int;
            var _local4:int;
            var _local5:int;
            if (sort){
                _local3 = sort.findItem(localIndex, _arg1, Sort.FIRST_INDEX_MODE);
                if (_local3 == -1){
                    return (-1);
                };
                _local4 = sort.findItem(localIndex, _arg1, Sort.LAST_INDEX_MODE);
                _local2 = _local3;
                while (_local2 <= _local4) {
                    if (localIndex[_local2] == _arg1){
                        return (_local2);
                    };
                    _local2++;
                };
                return (-1);
            };
            if (filterFunction != null){
                _local5 = localIndex.length;
                _local2 = 0;
                while (_local2 < _local5) {
                    if (localIndex[_local2] == _arg1){
                        return (_local2);
                    };
                    _local2++;
                };
                return (-1);
            };
            return (list.getItemIndex(_arg1));
        }
        mx_internal function getLocalItemIndex(_arg1:Object):int{
            var _local2:int;
            var _local3:int = localIndex.length;
            _local2 = 0;
            while (_local2 < _local3) {
                if (localIndex[_local2] == _arg1){
                    return (_local2);
                };
                _local2++;
            };
            return (-1);
        }
        override "http://www.adobe.com/2006/actionscript/flash/proxy"?? function getProperty(_arg1){
            var n:* = NaN;
            var message:* = null;
            var name:* = _arg1;
            if ((name is QName)){
                name = name.localName;
            };
            var index:* = -1;
            try {
                n = parseInt(String(name));
                if (!isNaN(n)){
                    index = int(n);
                };
            } catch(e:Error) {
            };
            if (index == -1){
                message = resourceManager.getString("collections", "unknownProperty", [name]);
                throw (new Error(message));
            };
            return (getItemAt(index));
        }
        public function enableAutoUpdate():void{
            if (autoUpdateCounter > 0){
                autoUpdateCounter--;
                if (autoUpdateCounter == 0){
                    handlePendingUpdates();
                };
            };
        }
        mx_internal function reset():void{
            var _local1:CollectionEvent;
            internalRefresh(false);
            if (dispatchResetEvent){
                _local1 = new CollectionEvent(CollectionEvent.COLLECTION_CHANGE);
                _local1.kind = CollectionEventKind.RESET;
                dispatchEvent(_local1);
            };
        }
        public function toArray():Array{
            var _local1:Array;
            if (localIndex){
                _local1 = localIndex.concat();
            } else {
                _local1 = list.toArray();
            };
            return (_local1);
        }
        public function removeItemAt(_arg1:int):Object{
            var _local3:String;
            var _local4:Object;
            if ((((_arg1 < 0)) || ((_arg1 >= length)))){
                _local3 = resourceManager.getString("collections", "outOfBounds", [_arg1]);
                throw (new RangeError(_local3));
            };
            var _local2:int = _arg1;
            if (localIndex){
                _local4 = localIndex[_arg1];
                _local2 = list.getItemIndex(_local4);
            };
            return (list.removeItemAt(_local2));
        }
        override "http://www.adobe.com/2006/actionscript/flash/proxy"?? function callProperty(_arg1, ... _args){
            return (null);
        }
        public function initialized(_arg1:Object, _arg2:String):void{
            refresh();
        }
        override "http://www.adobe.com/2006/actionscript/flash/proxy"?? function setProperty(_arg1, _arg2):void{
            var n:* = NaN;
            var message:* = null;
            var name:* = _arg1;
            var value:* = _arg2;
            if ((name is QName)){
                name = name.localName;
            };
            var index:* = -1;
            try {
                n = parseInt(String(name));
                if (!isNaN(n)){
                    index = int(n);
                };
            } catch(e:Error) {
            };
            if (index == -1){
                message = resourceManager.getString("collections", "unknownProperty", [name]);
                throw (new Error(message));
            };
            setItemAt(value, index);
        }
        public function addItem(_arg1:Object):void{
            addItemAt(_arg1, length);
        }
        private function internalRefresh(_arg1:Boolean):Boolean{
            var tmp:* = null;
            var len:* = 0;
            var i:* = 0;
            var item:* = null;
            var refreshEvent:* = null;
            var dispatch:* = _arg1;
            if (((sort) || (!((filterFunction == null))))){
                try {
                    populateLocalIndex();
                } catch(pending:ItemPendingError) {
                    pending.addResponder(new ItemResponder(function (_arg1:Object, _arg2:Object=null):void{
                        internalRefresh(dispatch);
                    }, function (_arg1:Object, _arg2:Object=null):void{
                    }));
                    return (false);
                };
                if (filterFunction != null){
                    tmp = [];
                    len = localIndex.length;
                    i = 0;
                    while (i < len) {
                        item = localIndex[i];
                        if (filterFunction(item)){
                            tmp.push(item);
                        };
                        i = (i + 1);
                    };
                    localIndex = tmp;
                };
                if (sort){
                    sort.sort(localIndex);
                    dispatch = true;
                };
            } else {
                if (localIndex){
                    localIndex = null;
                };
            };
            revision++;
            pendingUpdates = null;
            if (dispatch){
                refreshEvent = new CollectionEvent(CollectionEvent.COLLECTION_CHANGE);
                refreshEvent.kind = CollectionEventKind.REFRESH;
                dispatchEvent(refreshEvent);
            };
            return (true);
        }
        public function set filterFunction(_arg1:Function):void{
            _filterFunction = _arg1;
            dispatchEvent(new Event("filterFunctionChanged"));
        }
        mx_internal function getBookmarkIndex(_arg1:CursorBookmark):int{
            var bm:* = null;
            var message:* = null;
            var bookmark:* = _arg1;
            if (((!((bookmark is ListCollectionViewBookmark))) || (!((ListCollectionViewBookmark(bookmark).view == this))))){
                message = resourceManager.getString("collections", "bookmarkNotFound");
                throw (new CollectionViewError(message));
            };
            bm = ListCollectionViewBookmark(bookmark);
            if (bm.viewRevision != revision){
                if ((((((bm.index < 0)) || ((bm.index >= length)))) || (!((getItemAt(bm.index) == bm.value))))){
                    try {
                        bm.index = getItemIndex(bm.value);
                    } catch(e:SortError) {
                        bm.index = getLocalItemIndex(bm.value);
                    };
                };
                bm.viewRevision = revision;
            };
            return (bm.index);
        }
        public function refresh():Boolean{
            return (internalRefresh(true));
        }
        public function get filterFunction():Function{
            return (_filterFunction);
        }
        public function createCursor():IViewCursor{
            return (new ListCollectionViewCursor(this));
        }
        public function hasEventListener(_arg1:String):Boolean{
            return (eventDispatcher.hasEventListener(_arg1));
        }
        public function get length():int{
            if (localIndex){
                return (localIndex.length);
            };
            if (list){
                return (list.length);
            };
            return (0);
        }
        override "http://www.adobe.com/2006/actionscript/flash/proxy"?? function nextNameIndex(_arg1:int):int{
            return ((((_arg1 < length)) ? (_arg1 + 1) : 0));
        }
        public function disableAutoUpdate():void{
            autoUpdateCounter++;
        }
        public function toString():String{
            if (localIndex){
                return (ObjectUtil.toString(localIndex));
            };
            if (((list) && (Object(list).toString))){
                return (Object(list).toString());
            };
            return (getQualifiedClassName(this));
        }
        private function listChangeHandler(_arg1:CollectionEvent):void{
            if (autoUpdateCounter > 0){
                if (!pendingUpdates){
                    pendingUpdates = [];
                };
                pendingUpdates.push(_arg1);
            } else {
                switch (_arg1.kind){
                    case CollectionEventKind.ADD:
                        addItemsToView(_arg1.items, _arg1.location);
                        break;
                    case CollectionEventKind.RESET:
                        reset();
                        break;
                    case CollectionEventKind.REMOVE:
                        removeItemsFromView(_arg1.items, _arg1.location);
                        break;
                    case CollectionEventKind.REPLACE:
                        replaceItemsInView(_arg1.items, _arg1.location);
                        break;
                    case CollectionEventKind.UPDATE:
                        handlePropertyChangeEvents(_arg1.items);
                        break;
                    default:
                        dispatchEvent(_arg1);
                };
            };
        }

    }
}//package mx.collections 

import flash.events.*;
import mx.events.*;
import mx.resources.*;
import mx.core.*;
import mx.collections.errors.*;

class ListCollectionViewBookmark extends CursorBookmark {

    mx_internal var viewRevision:int;
    mx_internal var index:int;
    mx_internal var view:ListCollectionView;

    public function ListCollectionViewBookmark(_arg1:Object, _arg2:ListCollectionView, _arg3:int, _arg4:int){
        super(_arg1);
        this.view = _arg2;
        this.viewRevision = _arg3;
        this.index = _arg4;
    }
    override public function getViewIndex():int{
        return (view.getBookmarkIndex(this));
    }

}
class ListCollectionViewCursor extends EventDispatcher implements IViewCursor {

    private static const BEFORE_FIRST_INDEX:int = -1;
    private static const AFTER_LAST_INDEX:int = -2;

    private var _view:ListCollectionView;
    private var invalid:Boolean;
    private var resourceManager:IResourceManager;
    private var currentIndex:int;
    private var currentValue:Object;

    public function ListCollectionViewCursor(_arg1:ListCollectionView){
        var view:* = _arg1;
        resourceManager = ResourceManager.getInstance();
        super();
        _view = view;
        _view.addEventListener(CollectionEvent.COLLECTION_CHANGE, collectionEventHandler, false, 0, true);
        currentIndex = (((view.length > 0)) ? 0 : AFTER_LAST_INDEX);
        if (currentIndex == 0){
            try {
                setCurrent(view.getItemAt(0), false);
            } catch(e:ItemPendingError) {
                currentIndex = BEFORE_FIRST_INDEX;
                setCurrent(null, false);
            };
        };
    }
    public function findAny(_arg1:Object):Boolean{
        var index:* = 0;
        var values:* = _arg1;
        checkValid();
        var lcView:* = ListCollectionView(view);
        try {
            index = lcView.findItem(values, Sort.ANY_INDEX_MODE);
        } catch(e:SortError) {
            throw (new CursorError(e.message));
        };
        if (index > -1){
            currentIndex = index;
            setCurrent(lcView.getItemAt(currentIndex));
        };
        return ((index > -1));
    }
    public function remove():Object{
        var oldIndex:* = 0;
        var message:* = null;
        if (((beforeFirst) || (afterLast))){
            message = resourceManager.getString("collections", "invalidRemove");
            throw (new CursorError(message));
        };
        oldIndex = currentIndex;
        currentIndex++;
        if (currentIndex >= view.length){
            currentIndex = AFTER_LAST_INDEX;
            setCurrent(null);
        } else {
            try {
                setCurrent(ListCollectionView(view).getItemAt(currentIndex));
            } catch(e:ItemPendingError) {
                setCurrent(null, false);
                ListCollectionView(view).removeItemAt(oldIndex);
                throw (e);
            };
        };
        var removed:* = ListCollectionView(view).removeItemAt(oldIndex);
        return (removed);
    }
    private function setCurrent(_arg1:Object, _arg2:Boolean=true):void{
        currentValue = _arg1;
        if (_arg2){
            dispatchEvent(new FlexEvent(FlexEvent.CURSOR_UPDATE));
        };
    }
    public function seek(_arg1:CursorBookmark, _arg2:int=0, _arg3:int=0):void{
        var message:* = null;
        var bookmark:* = _arg1;
        var offset:int = _arg2;
        var prefetch:int = _arg3;
        checkValid();
        if (view.length == 0){
            currentIndex = AFTER_LAST_INDEX;
            setCurrent(null, false);
            return;
        };
        var newIndex:* = currentIndex;
        if (bookmark == CursorBookmark.FIRST){
            newIndex = 0;
        } else {
            if (bookmark == CursorBookmark.LAST){
                newIndex = (view.length - 1);
            } else {
                if (bookmark != CursorBookmark.CURRENT){
                    try {
                        newIndex = ListCollectionView(view).getBookmarkIndex(bookmark);
                        if (newIndex < 0){
                            setCurrent(null);
                            message = resourceManager.getString("collections", "bookmarkInvalid");
                            throw (new CursorError(message));
                        };
                    } catch(bmError:CollectionViewError) {
                        message = resourceManager.getString("collections", "bookmarkInvalid");
                        throw (new CursorError(message));
                    };
                };
            };
        };
        newIndex = (newIndex + offset);
        var newCurrent:* = null;
        if (newIndex >= view.length){
            currentIndex = AFTER_LAST_INDEX;
        } else {
            if (newIndex < 0){
                currentIndex = BEFORE_FIRST_INDEX;
            } else {
                newCurrent = ListCollectionView(view).getItemAt(newIndex, prefetch);
                currentIndex = newIndex;
            };
        };
        setCurrent(newCurrent);
    }
    public function insert(_arg1:Object):void{
        var _local2:int;
        var _local3:String;
        if (afterLast){
            _local2 = view.length;
        } else {
            if (beforeFirst){
                if (view.length > 0){
                    _local3 = resourceManager.getString("collections", "invalidInsert");
                    throw (new CursorError(_local3));
                };
                _local2 = 0;
            } else {
                _local2 = currentIndex;
            };
        };
        ListCollectionView(view).addItemAt(_arg1, _local2);
    }
    public function get afterLast():Boolean{
        checkValid();
        return ((((currentIndex == AFTER_LAST_INDEX)) || ((view.length == 0))));
    }
    private function checkValid():void{
        var _local1:String;
        if (invalid){
            _local1 = resourceManager.getString("collections", "invalidCursor");
            throw (new CursorError(_local1));
        };
    }
    private function collectionEventHandler(_arg1:CollectionEvent):void{
        var event:* = _arg1;
        switch (event.kind){
            case CollectionEventKind.ADD:
                if (event.location <= currentIndex){
                    currentIndex = (currentIndex + event.items.length);
                };
                break;
            case CollectionEventKind.REMOVE:
                if (event.location < currentIndex){
                    currentIndex = (currentIndex - event.items.length);
                } else {
                    if (event.location == currentIndex){
                        if (currentIndex < view.length){
                            try {
                                setCurrent(ListCollectionView(view).getItemAt(currentIndex));
                            } catch(error:ItemPendingError) {
                                setCurrent(null, false);
                            };
                        } else {
                            currentIndex = AFTER_LAST_INDEX;
                            setCurrent(null);
                        };
                    };
                };
                break;
            case CollectionEventKind.MOVE:
                if (event.oldLocation == currentIndex){
                    currentIndex = event.location;
                } else {
                    if (event.oldLocation < currentIndex){
                        currentIndex = (currentIndex - event.items.length);
                    };
                    if (event.location <= currentIndex){
                        currentIndex = (currentIndex + event.items.length);
                    };
                };
                break;
            case CollectionEventKind.REFRESH:
                if (!((beforeFirst) || (afterLast))){
                    try {
                        currentIndex = ListCollectionView(view).getItemIndex(currentValue);
                    } catch(e:SortError) {
                        if (ListCollectionView(view).sort){
                            currentIndex = ListCollectionView(view).getLocalItemIndex(currentValue);
                        };
                    };
                    if (currentIndex == -1){
                        setCurrent(null);
                    };
                };
                break;
            case CollectionEventKind.REPLACE:
                if (event.location == currentIndex){
                    try {
                        setCurrent(ListCollectionView(view).getItemAt(currentIndex));
                    } catch(error:ItemPendingError) {
                        setCurrent(null, false);
                    };
                };
                break;
            case CollectionEventKind.RESET:
                currentIndex = BEFORE_FIRST_INDEX;
                setCurrent(null);
                break;
        };
    }
    public function moveNext():Boolean{
        if (afterLast){
            return (false);
        };
        var _local1:int = ((beforeFirst) ? 0 : (currentIndex + 1));
        if (_local1 >= view.length){
            _local1 = AFTER_LAST_INDEX;
            setCurrent(null);
        } else {
            setCurrent(ListCollectionView(view).getItemAt(_local1));
        };
        currentIndex = _local1;
        return (!(afterLast));
    }
    public function get view():ICollectionView{
        checkValid();
        return (_view);
    }
    public function movePrevious():Boolean{
        if (beforeFirst){
            return (false);
        };
        var _local1:int = ((afterLast) ? (view.length - 1) : (currentIndex - 1));
        if (_local1 == -1){
            _local1 = BEFORE_FIRST_INDEX;
            setCurrent(null);
        } else {
            setCurrent(ListCollectionView(view).getItemAt(_local1));
        };
        currentIndex = _local1;
        return (!(beforeFirst));
    }
    public function findLast(_arg1:Object):Boolean{
        var index:* = 0;
        var values:* = _arg1;
        checkValid();
        var lcView:* = ListCollectionView(view);
        try {
            index = lcView.findItem(values, Sort.LAST_INDEX_MODE);
        } catch(sortError:SortError) {
            throw (new CursorError(sortError.message));
        };
        if (index > -1){
            currentIndex = index;
            setCurrent(lcView.getItemAt(currentIndex));
        };
        return ((index > -1));
    }
    public function get beforeFirst():Boolean{
        checkValid();
        return ((((currentIndex == BEFORE_FIRST_INDEX)) || ((view.length == 0))));
    }
    public function get bookmark():CursorBookmark{
        checkValid();
        if ((((view.length == 0)) || (beforeFirst))){
            return (CursorBookmark.FIRST);
        };
        if (afterLast){
            return (CursorBookmark.LAST);
        };
        return (ListCollectionView(view).getBookmark(currentIndex));
    }
    public function findFirst(_arg1:Object):Boolean{
        var index:* = 0;
        var values:* = _arg1;
        checkValid();
        var lcView:* = ListCollectionView(view);
        try {
            index = lcView.findItem(values, Sort.FIRST_INDEX_MODE);
        } catch(sortError:SortError) {
            throw (new CursorError(sortError.message));
        };
        if (index > -1){
            currentIndex = index;
            setCurrent(lcView.getItemAt(currentIndex));
        };
        return ((index > -1));
    }
    public function get current():Object{
        checkValid();
        return (currentValue);
    }

}
﻿package mx.collections.errors {
    import mx.core.*;

    public class CursorError extends Error {

        mx_internal static const VERSION:String = "3.5.0.12683";

        public function CursorError(_arg1:String){
            super(_arg1);
        }
    }
}//package mx.collections.errors 
﻿package mx.collections.errors {
    import mx.core.*;

    public class SortError extends Error {

        mx_internal static const VERSION:String = "3.5.0.12683";

        public function SortError(_arg1:String){
            super(_arg1);
        }
    }
}//package mx.collections.errors 
﻿package mx.collections.errors {
    import mx.rpc.*;
    import mx.core.*;

    public class ItemPendingError extends Error {

        mx_internal static const VERSION:String = "3.5.0.12683";

        private var _responders:Array;

        public function ItemPendingError(_arg1:String){
            super(_arg1);
        }
        public function get responders():Array{
            return (_responders);
        }
        public function addResponder(_arg1:IResponder):void{
            if (!_responders){
                _responders = [];
            };
            _responders.push(_arg1);
        }

    }
}//package mx.collections.errors 
﻿package mx.collections.errors {
    import mx.core.*;

    public class CollectionViewError extends Error {

        mx_internal static const VERSION:String = "3.5.0.12683";

        public function CollectionViewError(_arg1:String){
            super(_arg1);
        }
    }
}//package mx.collections.errors 
﻿package mx.collections {
    import flash.events.*;

    public interface ICollectionView extends IEventDispatcher {

        function set filterFunction(_arg1:Function):void;
        function enableAutoUpdate():void;
        function get length():int;
        function disableAutoUpdate():void;
        function itemUpdated(_arg1:Object, _arg2:Object=null, _arg3:Object=null, _arg4:Object=null):void;
        function get filterFunction():Function;
        function createCursor():IViewCursor;
        function refresh():Boolean;
        function set sort(_arg1:Sort):void;
        function get sort():Sort;
        function contains(_arg1:Object):Boolean;

    }
}//package mx.collections 
﻿package mx.collections {
    import flash.utils.*;
    import mx.core.*;

    public class ArrayCollection extends ListCollectionView implements IExternalizable {

        mx_internal static const VERSION:String = "3.5.0.12683";

        public function ArrayCollection(_arg1:Array=null){
            this.source = _arg1;
        }
        public function set source(_arg1:Array):void{
            list = new ArrayList(_arg1);
        }
        public function readExternal(_arg1:IDataInput):void{
            if ((list is IExternalizable)){
                IExternalizable(list).readExternal(_arg1);
            } else {
                source = (_arg1.readObject() as Array);
            };
        }
        public function writeExternal(_arg1:IDataOutput):void{
            if ((list is IExternalizable)){
                IExternalizable(list).writeExternal(_arg1);
            } else {
                _arg1.writeObject(source);
            };
        }
        public function get source():Array{
            if (((list) && ((list is ArrayList)))){
                return (ArrayList(list).source);
            };
            return (null);
        }

    }
}//package mx.collections 
﻿package mx.netmon {
    import flash.events.*;
    import flash.net.*;

    public class NetworkMonitor {

        public static var monitorEventImpl:Function;
        public static var adjustNetConnectionURLImpl:Function;
        public static var monitorFaultImpl:Function;
        public static var monitorInvocationImpl:Function;
        public static var adjustURLRequestImpl:Function;
        public static var isMonitoringImpl:Function;
        public static var monitorResultImpl:Function;

        public static function monitorInvocation(_arg1:String, _arg2:Object, _arg3:Object):void{
            if (monitorInvocationImpl != null){
                monitorInvocationImpl(_arg1, _arg2, _arg3);
            };
        }
        public static function monitorFault(_arg1:Object, _arg2:Object):void{
            if (monitorFaultImpl != null){
                monitorFaultImpl(_arg1, _arg2);
            };
        }
        public static function adjustURLRequest(_arg1:URLRequest, _arg2:String, _arg3:String):void{
            if (adjustURLRequestImpl != null){
                adjustURLRequestImpl(_arg1, _arg2, _arg3);
            };
        }
        public static function monitorEvent(_arg1:Event, _arg2:String):void{
            if (monitorEventImpl != null){
                monitorEventImpl(_arg1, _arg2);
            };
        }
        public static function isMonitoring():Boolean{
            return (((isMonitoringImpl)!=null) ? isMonitoringImpl() : false);
        }
        public static function adjustNetConnectionURL(_arg1:String, _arg2:String):String{
            if (adjustNetConnectionURLImpl != null){
                return (adjustNetConnectionURLImpl(_arg1, _arg2));
            };
            return (null);
        }
        public static function monitorResult(_arg1:Object, _arg2:Object):void{
            if (monitorResultImpl != null){
                monitorResultImpl(_arg1, _arg2);
            };
        }

    }
}//package mx.netmon 
﻿package mx.resources {
    import mx.core.*;

    public class LocaleSorter {

        mx_internal static const VERSION:String = "3.5.0.12683";

        private static function normalizeLocale(_arg1:String):String{
            return (_arg1.toLowerCase().replace(/-/g, "_"));
        }
        public static function sortLocalesByPreference(_arg1:Array, _arg2:Array, _arg3:String=null, _arg4:Boolean=false):Array{
            var result:* = null;
            var hasLocale:* = null;
            var i:* = 0;
            var j:* = 0;
            var k:* = 0;
            var l:* = 0;
            var locale:* = null;
            var plocale:* = null;
            var appLocales:* = _arg1;
            var systemPreferences:* = _arg2;
            var ultimateFallbackLocale = _arg3;
            var addAll:Boolean = _arg4;
            var promote:* = function (_arg1:String):void{
                if (typeof(hasLocale[_arg1]) != "undefined"){
                    result.push(appLocales[hasLocale[_arg1]]);
                    delete hasLocale[_arg1];
                };
            };
            result = [];
            hasLocale = {};
            var locales:* = trimAndNormalize(appLocales);
            var preferenceLocales:* = trimAndNormalize(systemPreferences);
            addUltimateFallbackLocale(preferenceLocales, ultimateFallbackLocale);
            j = 0;
            while (j < locales.length) {
                hasLocale[locales[j]] = j;
                j = (j + 1);
            };
            i = 0;
            l = preferenceLocales.length;
            while (i < l) {
                plocale = LocaleID.fromString(preferenceLocales[i]);
                promote(preferenceLocales[i]);
                promote(plocale.toString());
                while (plocale.transformToParent()) {
                    promote(plocale.toString());
                };
                plocale = LocaleID.fromString(preferenceLocales[i]);
                j = 0;
                while (j < l) {
                    locale = preferenceLocales[j];
                    if (plocale.isSiblingOf(LocaleID.fromString(locale))){
                        promote(locale);
                    };
                    j = (j + 1);
                };
                j = 0;
                k = locales.length;
                while (j < k) {
                    locale = locales[j];
                    if (plocale.isSiblingOf(LocaleID.fromString(locale))){
                        promote(locale);
                    };
                    j = (j + 1);
                };
                i = (i + 1);
            };
            if (addAll){
                j = 0;
                k = locales.length;
                while (j < k) {
                    promote(locales[j]);
                    j = (j + 1);
                };
            };
            return (result);
        }
        private static function addUltimateFallbackLocale(_arg1:Array, _arg2:String):void{
            var _local3:String;
            if (((!((_arg2 == null))) && (!((_arg2 == ""))))){
                _local3 = normalizeLocale(_arg2);
                if (_arg1.indexOf(_local3) == -1){
                    _arg1.push(_local3);
                };
            };
        }
        private static function trimAndNormalize(_arg1:Array):Array{
            var _local2:Array = [];
            var _local3:int;
            while (_local3 < _arg1.length) {
                _local2.push(normalizeLocale(_arg1[_local3]));
                _local3++;
            };
            return (_local2);
        }

    }
}//package mx.resources 

class LocaleID {

    public static const STATE_PRIMARY_LANGUAGE:int = 0;
    public static const STATE_REGION:int = 3;
    public static const STATE_EXTENDED_LANGUAGES:int = 1;
    public static const STATE_EXTENSIONS:int = 5;
    public static const STATE_SCRIPT:int = 2;
    public static const STATE_VARIANTS:int = 4;
    public static const STATE_PRIVATES:int = 6;

    private var privateLangs:Boolean = false;
    private var script:String = "";
    private var variants:Array;
    private var privates:Array;
    private var extensions:Object;
    private var lang:String = "";
    private var region:String = "";
    private var extended_langs:Array;

    public function LocaleID(){
        extended_langs = [];
        variants = [];
        extensions = {};
        privates = [];
        super();
    }
    private static function appendElements(_arg1:Array, _arg2:Array):void{
        var _local3:uint;
        var _local4:uint = _arg2.length;
        while (_local3 < _local4) {
            _arg1.push(_arg2[_local3]);
            _local3++;
        };
    }
    public static function fromString(_arg1:String):LocaleID{
        var _local5:Array;
        var _local8:String;
        var _local9:int;
        var _local10:String;
        var _local2:LocaleID = new (LocaleID)();
        var _local3:int = STATE_PRIMARY_LANGUAGE;
        var _local4:Array = _arg1.replace(/-/g, "_").split("_");
        var _local6:int;
        var _local7:int = _local4.length;
        while (_local6 < _local7) {
            _local8 = _local4[_local6].toLowerCase();
            if (_local3 == STATE_PRIMARY_LANGUAGE){
                if (_local8 == "x"){
                    _local2.privateLangs = true;
                } else {
                    if (_local8 == "i"){
                        _local2.lang = (_local2.lang + "i-");
                    } else {
                        _local2.lang = (_local2.lang + _local8);
                        _local3 = STATE_EXTENDED_LANGUAGES;
                    };
                };
            } else {
                _local9 = _local8.length;
                if (_local9 == 0){
                } else {
                    _local10 = _local8.charAt(0).toLowerCase();
                    if ((((_local3 <= STATE_EXTENDED_LANGUAGES)) && ((_local9 == 3)))){
                        _local2.extended_langs.push(_local8);
                        if (_local2.extended_langs.length == 3){
                            _local3 = STATE_SCRIPT;
                        };
                    } else {
                        if ((((_local3 <= STATE_SCRIPT)) && ((_local9 == 4)))){
                            _local2.script = _local8;
                            _local3 = STATE_REGION;
                        } else {
                            if ((((_local3 <= STATE_REGION)) && ((((_local9 == 2)) || ((_local9 == 3)))))){
                                _local2.region = _local8;
                                _local3 = STATE_VARIANTS;
                            } else {
                                if ((((_local3 <= STATE_VARIANTS)) && ((((((((_local10 >= "a")) && ((_local10 <= "z")))) && ((_local9 >= 5)))) || ((((((_local10 >= "0")) && ((_local10 <= "9")))) && ((_local9 >= 4)))))))){
                                    _local2.variants.push(_local8);
                                    _local3 = STATE_VARIANTS;
                                } else {
                                    if ((((_local3 < STATE_PRIVATES)) && ((_local9 == 1)))){
                                        if (_local8 == "x"){
                                            _local3 = STATE_PRIVATES;
                                            _local5 = _local2.privates;
                                        } else {
                                            _local3 = STATE_EXTENSIONS;
                                            _local5 = ((_local2.extensions[_local8]) || ([]));
                                            _local2.extensions[_local8] = _local5;
                                        };
                                    } else {
                                        if (_local3 >= STATE_EXTENSIONS){
                                            _local5.push(_local8);
                                        };
                                    };
                                };
                            };
                        };
                    };
                };
            };
            _local6++;
        };
        _local2.canonicalize();
        return (_local2);
    }

    public function equals(_arg1:LocaleID):Boolean{
        return ((toString() == _arg1.toString()));
    }
    public function canonicalize():void{
        var _local1:String;
        for (_local1 in extensions) {
            if (extensions.hasOwnProperty(_local1)){
                if (extensions[_local1].length == 0){
                    delete extensions[_local1];
                } else {
                    extensions[_local1] = extensions[_local1].sort();
                };
            };
        };
        extended_langs = extended_langs.sort();
        variants = variants.sort();
        privates = privates.sort();
        if (script == ""){
            script = LocaleRegistry.getScriptByLang(lang);
        };
        if ((((script == "")) && (!((region == ""))))){
            script = LocaleRegistry.getScriptByLangAndRegion(lang, region);
        };
        if ((((region == "")) && (!((script == ""))))){
            region = LocaleRegistry.getDefaultRegionForLangAndScript(lang, script);
        };
    }
    public function toString():String{
        var _local2:String;
        var _local1:Array = [lang];
        appendElements(_local1, extended_langs);
        if (script != ""){
            _local1.push(script);
        };
        if (region != ""){
            _local1.push(region);
        };
        appendElements(_local1, variants);
        for (_local2 in extensions) {
            if (extensions.hasOwnProperty(_local2)){
                _local1.push(_local2);
                appendElements(_local1, extensions[_local2]);
            };
        };
        if (privates.length > 0){
            _local1.push("x");
            appendElements(_local1, privates);
        };
        return (_local1.join("_"));
    }
    public function isSiblingOf(_arg1:LocaleID):Boolean{
        return ((((lang == _arg1.lang)) && ((script == _arg1.script))));
    }
    public function transformToParent():Boolean{
        var _local2:String;
        var _local3:Array;
        var _local4:String;
        if (privates.length > 0){
            privates.splice((privates.length - 1), 1);
            return (true);
        };
        var _local1:String;
        for (_local2 in extensions) {
            if (extensions.hasOwnProperty(_local2)){
                _local1 = _local2;
            };
        };
        if (_local1){
            _local3 = extensions[_local1];
            if (_local3.length == 1){
                delete extensions[_local1];
                return (true);
            };
            _local3.splice((_local3.length - 1), 1);
            return (true);
        };
        if (variants.length > 0){
            variants.splice((variants.length - 1), 1);
            return (true);
        };
        if (script != ""){
            if (LocaleRegistry.getScriptByLang(lang) != ""){
                script = "";
                return (true);
            };
            if (region == ""){
                _local4 = LocaleRegistry.getDefaultRegionForLangAndScript(lang, script);
                if (_local4 != ""){
                    region = _local4;
                    script = "";
                    return (true);
                };
            };
        };
        if (region != ""){
            if (!(((script == "")) && ((LocaleRegistry.getScriptByLang(lang) == "")))){
                region = "";
                return (true);
            };
        };
        if (extended_langs.length > 0){
            extended_langs.splice((extended_langs.length - 1), 1);
            return (true);
        };
        return (false);
    }

}
class LocaleRegistry {

    private static const SCRIPT_ID_BY_LANG:Object = {
        ab:5,
        af:1,
        am:2,
        ar:3,
        as:4,
        ay:1,
        be:5,
        bg:5,
        bn:4,
        bs:1,
        ca:1,
        ch:1,
        cs:1,
        cy:1,
        da:1,
        de:1,
        dv:6,
        dz:7,
        el:8,
        en:1,
        eo:1,
        es:1,
        et:1,
        eu:1,
        fa:3,
        fi:1,
        fj:1,
        fo:1,
        fr:1,
        frr:1,
        fy:1,
        ga:1,
        gl:1,
        gn:1,
        gu:9,
        gv:1,
        he:10,
        hi:11,
        hr:1,
        ht:1,
        hu:1,
        hy:12,
        id:1,
        in:1,
        is:1,
        it:1,
        iw:10,
        ja:13,
        ka:14,
        kk:5,
        kl:1,
        km:15,
        kn:16,
        ko:17,
        la:1,
        lb:1,
        ln:1,
        lo:18,
        lt:1,
        lv:1,
        mg:1,
        mh:1,
        mk:5,
        ml:19,
        mo:1,
        mr:11,
        ms:1,
        mt:1,
        my:20,
        na:1,
        nb:1,
        nd:1,
        ne:11,
        nl:1,
        nn:1,
        no:1,
        nr:1,
        ny:1,
        om:1,
        or:21,
        pa:22,
        pl:1,
        ps:3,
        pt:1,
        qu:1,
        rn:1,
        ro:1,
        ru:5,
        rw:1,
        sg:1,
        si:23,
        sk:1,
        sl:1,
        sm:1,
        so:1,
        sq:1,
        ss:1,
        st:1,
        sv:1,
        sw:1,
        ta:24,
        te:25,
        th:26,
        ti:2,
        tl:1,
        tn:1,
        to:1,
        tr:1,
        ts:1,
        uk:5,
        ur:3,
        ve:1,
        vi:1,
        wo:1,
        xh:1,
        yi:10,
        zu:1,
        cpe:1,
        dsb:1,
        frs:1,
        gsw:1,
        hsb:1,
        kok:11,
        mai:11,
        men:1,
        nds:1,
        niu:1,
        nqo:27,
        nso:1,
        son:1,
        tem:1,
        tkl:1,
        tmh:1,
        tpi:1,
        tvl:1,
        zbl:28
    };
    private static const SCRIPTS:Array = ["", "latn", "ethi", "arab", "beng", "cyrl", "thaa", "tibt", "grek", "gujr", "hebr", "deva", "armn", "jpan", "geor", "khmr", "knda", "kore", "laoo", "mlym", "mymr", "orya", "guru", "sinh", "taml", "telu", "thai", "nkoo", "blis", "hans", "hant", "mong", "syrc"];
    private static const DEFAULT_REGION_BY_LANG_AND_SCRIPT:Object = {
        bg:{5:"bg"},
        ca:{1:"es"},
        zh:{
            30:"tw",
            29:"cn"
        },
        cs:{1:"cz"},
        da:{1:"dk"},
        de:{1:"de"},
        el:{8:"gr"},
        en:{1:"us"},
        es:{1:"es"},
        fi:{1:"fi"},
        fr:{1:"fr"},
        he:{10:"il"},
        hu:{1:"hu"},
        is:{1:"is"},
        it:{1:"it"},
        ja:{13:"jp"},
        ko:{17:"kr"},
        nl:{1:"nl"},
        nb:{1:"no"},
        pl:{1:"pl"},
        pt:{1:"br"},
        ro:{1:"ro"},
        ru:{5:"ru"},
        hr:{1:"hr"},
        sk:{1:"sk"},
        sq:{1:"al"},
        sv:{1:"se"},
        th:{26:"th"},
        tr:{1:"tr"},
        ur:{3:"pk"},
        id:{1:"id"},
        uk:{5:"ua"},
        be:{5:"by"},
        sl:{1:"si"},
        et:{1:"ee"},
        lv:{1:"lv"},
        lt:{1:"lt"},
        fa:{3:"ir"},
        vi:{1:"vn"},
        hy:{12:"am"},
        az:{
            1:"az",
            5:"az"
        },
        eu:{1:"es"},
        mk:{5:"mk"},
        af:{1:"za"},
        ka:{14:"ge"},
        fo:{1:"fo"},
        hi:{11:"in"},
        ms:{1:"my"},
        kk:{5:"kz"},
        ky:{5:"kg"},
        sw:{1:"ke"},
        uz:{
            1:"uz",
            5:"uz"
        },
        tt:{5:"ru"},
        pa:{22:"in"},
        gu:{9:"in"},
        ta:{24:"in"},
        te:{25:"in"},
        kn:{16:"in"},
        mr:{11:"in"},
        sa:{11:"in"},
        mn:{5:"mn"},
        gl:{1:"es"},
        kok:{11:"in"},
        syr:{32:"sy"},
        dv:{6:"mv"},
        nn:{1:"no"},
        sr:{
            1:"cs",
            5:"cs"
        },
        cy:{1:"gb"},
        mi:{1:"nz"},
        mt:{1:"mt"},
        quz:{1:"bo"},
        tn:{1:"za"},
        xh:{1:"za"},
        zu:{1:"za"},
        nso:{1:"za"},
        se:{1:"no"},
        smj:{1:"no"},
        sma:{1:"no"},
        sms:{1:"fi"},
        smn:{1:"fi"},
        bs:{1:"ba"}
    };
    private static const SCRIPT_BY_ID:Object = {
        latn:1,
        ethi:2,
        arab:3,
        beng:4,
        cyrl:5,
        thaa:6,
        tibt:7,
        grek:8,
        gujr:9,
        hebr:10,
        deva:11,
        armn:12,
        jpan:13,
        geor:14,
        khmr:15,
        knda:16,
        kore:17,
        laoo:18,
        mlym:19,
        mymr:20,
        orya:21,
        guru:22,
        sinh:23,
        taml:24,
        telu:25,
        thai:26,
        nkoo:27,
        blis:28,
        hans:29,
        hant:30,
        mong:31,
        syrc:32
    };
    private static const SCRIPT_ID_BY_LANG_AND_REGION:Object = {
        zh:{
            cn:29,
            sg:29,
            tw:30,
            hk:30,
            mo:30
        },
        mn:{
            cn:31,
            sg:5
        },
        pa:{
            pk:3,
            in:22
        },
        ha:{
            gh:1,
            ne:1
        }
    };

    public function LocaleRegistry(){
    }
    public static function getScriptByLangAndRegion(_arg1:String, _arg2:String):String{
        var _local3:Object = SCRIPT_ID_BY_LANG_AND_REGION[_arg1];
        if (_local3 == null){
            return ("");
        };
        var _local4:Object = _local3[_arg2];
        if (_local4 == null){
            return ("");
        };
        return (SCRIPTS[int(_local4)].toLowerCase());
    }
    public static function getScriptByLang(_arg1:String):String{
        var _local2:Object = SCRIPT_ID_BY_LANG[_arg1];
        if (_local2 == null){
            return ("");
        };
        return (SCRIPTS[int(_local2)].toLowerCase());
    }
    public static function getDefaultRegionForLangAndScript(_arg1:String, _arg2:String):String{
        var _local3:Object = DEFAULT_REGION_BY_LANG_AND_SCRIPT[_arg1];
        var _local4:Object = SCRIPT_BY_ID[_arg2];
        if ((((_local3 == null)) || ((_local4 == null)))){
            return ("");
        };
        return (((_local3[int(_local4)]) || ("")));
    }

}
﻿package mx.resources {
    import flash.events.*;
    import flash.system.*;

    public interface IResourceManager extends IEventDispatcher {

        function loadResourceModule(_arg1:String, _arg2:Boolean=true, _arg3:ApplicationDomain=null, _arg4:SecurityDomain=null):IEventDispatcher;
        function getBoolean(_arg1:String, _arg2:String, _arg3:String=null):Boolean;
        function getClass(_arg1:String, _arg2:String, _arg3:String=null):Class;
        function getLocales():Array;
        function removeResourceBundlesForLocale(_arg1:String):void;
        function getResourceBundle(_arg1:String, _arg2:String):IResourceBundle;
        function get localeChain():Array;
        function getInt(_arg1:String, _arg2:String, _arg3:String=null):int;
        function update():void;
        function set localeChain(_arg1:Array):void;
        function getUint(_arg1:String, _arg2:String, _arg3:String=null):uint;
        function addResourceBundle(_arg1:IResourceBundle):void;
        function getStringArray(_arg1:String, _arg2:String, _arg3:String=null):Array;
        function getBundleNamesForLocale(_arg1:String):Array;
        function removeResourceBundle(_arg1:String, _arg2:String):void;
        function getObject(_arg1:String, _arg2:String, _arg3:String=null);
        function getString(_arg1:String, _arg2:String, _arg3:Array=null, _arg4:String=null):String;
        function installCompiledResourceBundles(_arg1:ApplicationDomain, _arg2:Array, _arg3:Array):void;
        function unloadResourceModule(_arg1:String, _arg2:Boolean=true):void;
        function getPreferredLocaleChain():Array;
        function findResourceBundleWithResource(_arg1:String, _arg2:String):IResourceBundle;
        function initializeLocaleChain(_arg1:Array):void;
        function getNumber(_arg1:String, _arg2:String, _arg3:String=null):Number;

    }
}//package mx.resources 
﻿package mx.resources {
    import flash.system.*;
    import mx.utils.*;
    import mx.core.*;

    public class ResourceBundle implements IResourceBundle {

        mx_internal static var backupApplicationDomain:ApplicationDomain;
        mx_internal static var locale:String;

        mx_internal var _locale:String;
        private var _content:Object;
        mx_internal var _bundleName:String;

        public function ResourceBundle(_arg1:String=null, _arg2:String=null){
            _content = {};
            super();
            mx_internal::_locale = _arg1;
            mx_internal::_bundleName = _arg2;
            _content = getContent();
        }
        private static function getClassByName(_arg1:String, _arg2:ApplicationDomain):Class{
            var _local3:Class;
            if (_arg2.hasDefinition(_arg1)){
                _local3 = (_arg2.getDefinition(_arg1) as Class);
            };
            return (_local3);
        }
        public static function getResourceBundle(_arg1:String, _arg2:ApplicationDomain=null):ResourceBundle{
            var _local3:String;
            var _local4:Class;
            var _local5:Object;
            var _local6:ResourceBundle;
            if (!_arg2){
                _arg2 = ApplicationDomain.currentDomain;
            };
            _local3 = (((mx_internal::locale + "$") + _arg1) + "_properties");
            _local4 = getClassByName(_local3, _arg2);
            if (!_local4){
                _local3 = (_arg1 + "_properties");
                _local4 = getClassByName(_local3, _arg2);
            };
            if (!_local4){
                _local3 = _arg1;
                _local4 = getClassByName(_local3, _arg2);
            };
            if (((!(_local4)) && (mx_internal::backupApplicationDomain))){
                _local3 = (_arg1 + "_properties");
                _local4 = getClassByName(_local3, mx_internal::backupApplicationDomain);
                if (!_local4){
                    _local3 = _arg1;
                    _local4 = getClassByName(_local3, mx_internal::backupApplicationDomain);
                };
            };
            if (_local4){
                _local5 = new (_local4)();
                if ((_local5 is ResourceBundle)){
                    _local6 = ResourceBundle(_local5);
                    return (_local6);
                };
            };
            throw (new Error(("Could not find resource bundle " + _arg1)));
        }

        protected function getContent():Object{
            return ({});
        }
        public function getString(_arg1:String):String{
            return (String(_getObject(_arg1)));
        }
        public function get content():Object{
            return (_content);
        }
        public function getBoolean(_arg1:String, _arg2:Boolean=true):Boolean{
            var _local3:String = _getObject(_arg1).toLowerCase();
            if (_local3 == "false"){
                return (false);
            };
            if (_local3 == "true"){
                return (true);
            };
            return (_arg2);
        }
        public function getStringArray(_arg1:String):Array{
            var _local2:Array = _getObject(_arg1).split(",");
            var _local3:int = _local2.length;
            var _local4:int;
            while (_local4 < _local3) {
                _local2[_local4] = StringUtil.trim(_local2[_local4]);
                _local4++;
            };
            return (_local2);
        }
        public function getObject(_arg1:String):Object{
            return (_getObject(_arg1));
        }
        private function _getObject(_arg1:String):Object{
            var _local2:Object = content[_arg1];
            if (!_local2){
                throw (new Error(((("Key " + _arg1) + " was not found in resource bundle ") + bundleName)));
            };
            return (_local2);
        }
        public function get locale():String{
            return (mx_internal::_locale);
        }
        public function get bundleName():String{
            return (mx_internal::_bundleName);
        }
        public function getNumber(_arg1:String):Number{
            return (Number(_getObject(_arg1)));
        }

    }
}//package mx.resources 
﻿package mx.resources {
    import flash.events.*;
    import mx.events.*;
    import flash.utils.*;
    import flash.system.*;
    import mx.utils.*;
    import mx.modules.*;
    import mx.core.*;

    public class ResourceManagerImpl extends EventDispatcher implements IResourceManager {

        mx_internal static const VERSION:String = "3.5.0.12683";

        private static var instance:IResourceManager;

        private var resourceModules:Object;
        private var initializedForNonFrameworkApp:Boolean = false;
        private var localeMap:Object;
        private var _localeChain:Array;

        public function ResourceManagerImpl(){
            localeMap = {};
            resourceModules = {};
            super();
        }
        public static function getInstance():IResourceManager{
            if (!instance){
                instance = new (ResourceManagerImpl)();
            };
            return (instance);
        }

        public function get localeChain():Array{
            return (_localeChain);
        }
        public function set localeChain(_arg1:Array):void{
            _localeChain = _arg1;
            update();
        }
        public function getStringArray(_arg1:String, _arg2:String, _arg3:String=null):Array{
            var _local4:IResourceBundle = findBundle(_arg1, _arg2, _arg3);
            if (!_local4){
                return (null);
            };
            var _local5:* = _local4.content[_arg2];
            var _local6:Array = String(_local5).split(",");
            var _local7:int = _local6.length;
            var _local8:int;
            while (_local8 < _local7) {
                _local6[_local8] = StringUtil.trim(_local6[_local8]);
                _local8++;
            };
            return (_local6);
        }
        mx_internal function installCompiledResourceBundle(_arg1:ApplicationDomain, _arg2:String, _arg3:String):void{
            var _local4:String;
            var _local5:String = _arg3;
            var _local6:int = _arg3.indexOf(":");
            if (_local6 != -1){
                _local4 = _arg3.substring(0, _local6);
                _local5 = _arg3.substring((_local6 + 1));
            };
            if (getResourceBundle(_arg2, _arg3)){
                return;
            };
            var _local7 = (((_arg2 + "$") + _local5) + "_properties");
            if (_local4 != null){
                _local7 = ((_local4 + ".") + _local7);
            };
            var _local8:Class;
            if (_arg1.hasDefinition(_local7)){
                _local8 = Class(_arg1.getDefinition(_local7));
            };
            if (!_local8){
                _local7 = _arg3;
                if (_arg1.hasDefinition(_local7)){
                    _local8 = Class(_arg1.getDefinition(_local7));
                };
            };
            if (!_local8){
                _local7 = (_arg3 + "_properties");
                if (_arg1.hasDefinition(_local7)){
                    _local8 = Class(_arg1.getDefinition(_local7));
                };
            };
            if (!_local8){
                throw (new Error((((("Could not find compiled resource bundle '" + _arg3) + "' for locale '") + _arg2) + "'.")));
            };
            var _local9:ResourceBundle = ResourceBundle(new (_local8)());
            _local9.mx_internal::_locale = _arg2;
            _local9.mx_internal::_bundleName = _arg3;
            addResourceBundle(_local9);
        }
        public function getString(_arg1:String, _arg2:String, _arg3:Array=null, _arg4:String=null):String{
            var _local5:IResourceBundle = findBundle(_arg1, _arg2, _arg4);
            if (!_local5){
                return (null);
            };
            var _local6:String = String(_local5.content[_arg2]);
            if (_arg3){
                _local6 = StringUtil.substitute(_local6, _arg3);
            };
            return (_local6);
        }
        public function loadResourceModule(_arg1:String, _arg2:Boolean=true, _arg3:ApplicationDomain=null, _arg4:SecurityDomain=null):IEventDispatcher{
            var moduleInfo:* = null;
            var resourceEventDispatcher:* = null;
            var timer:* = null;
            var timerHandler:* = null;
            var url:* = _arg1;
            var updateFlag:Boolean = _arg2;
            var applicationDomain = _arg3;
            var securityDomain = _arg4;
            moduleInfo = ModuleManager.getModule(url);
            resourceEventDispatcher = new ResourceEventDispatcher(moduleInfo);
            var readyHandler:* = function (_arg1:ModuleEvent):void{
                var _local2:* = _arg1.module.factory.create();
                resourceModules[_arg1.module.url].resourceModule = _local2;
                if (updateFlag){
                    update();
                };
            };
            moduleInfo.addEventListener(ModuleEvent.READY, readyHandler, false, 0, true);
            var errorHandler:* = function (_arg1:ModuleEvent):void{
                var _local3:ResourceEvent;
                var _local2:String = ("Unable to load resource module from " + url);
                if (resourceEventDispatcher.willTrigger(ResourceEvent.ERROR)){
                    _local3 = new ResourceEvent(ResourceEvent.ERROR, _arg1.bubbles, _arg1.cancelable);
                    _local3.bytesLoaded = 0;
                    _local3.bytesTotal = 0;
                    _local3.errorText = _local2;
                    resourceEventDispatcher.dispatchEvent(_local3);
                } else {
                    throw (new Error(_local2));
                };
            };
            moduleInfo.addEventListener(ModuleEvent.ERROR, errorHandler, false, 0, true);
            resourceModules[url] = new ResourceModuleInfo(moduleInfo, readyHandler, errorHandler);
            timer = new Timer(0);
            timerHandler = function (_arg1:TimerEvent):void{
                timer.removeEventListener(TimerEvent.TIMER, timerHandler);
                timer.stop();
                moduleInfo.load(applicationDomain, securityDomain);
            };
            timer.addEventListener(TimerEvent.TIMER, timerHandler, false, 0, true);
            timer.start();
            return (resourceEventDispatcher);
        }
        public function getLocales():Array{
            var _local2:String;
            var _local1:Array = [];
            for (_local2 in localeMap) {
                _local1.push(_local2);
            };
            return (_local1);
        }
        public function removeResourceBundlesForLocale(_arg1:String):void{
            delete localeMap[_arg1];
        }
        public function getResourceBundle(_arg1:String, _arg2:String):IResourceBundle{
            var _local3:Object = localeMap[_arg1];
            if (!_local3){
                return (null);
            };
            return (_local3[_arg2]);
        }
        private function dumpResourceModule(_arg1):void{
            var _local2:ResourceBundle;
            var _local3:String;
            for each (_local2 in _arg1.resourceBundles) {
                trace(_local2.locale, _local2.bundleName);
                for (_local3 in _local2.content) {
                };
            };
        }
        public function addResourceBundle(_arg1:IResourceBundle):void{
            var _local2:String = _arg1.locale;
            var _local3:String = _arg1.bundleName;
            if (!localeMap[_local2]){
                localeMap[_local2] = {};
            };
            localeMap[_local2][_local3] = _arg1;
        }
        public function getObject(_arg1:String, _arg2:String, _arg3:String=null){
            var _local4:IResourceBundle = findBundle(_arg1, _arg2, _arg3);
            if (!_local4){
                return (undefined);
            };
            return (_local4.content[_arg2]);
        }
        public function getInt(_arg1:String, _arg2:String, _arg3:String=null):int{
            var _local4:IResourceBundle = findBundle(_arg1, _arg2, _arg3);
            if (!_local4){
                return (0);
            };
            var _local5:* = _local4.content[_arg2];
            return (int(_local5));
        }
        private function findBundle(_arg1:String, _arg2:String, _arg3:String):IResourceBundle{
            supportNonFrameworkApps();
            return (((_arg3)!=null) ? getResourceBundle(_arg3, _arg1) : findResourceBundleWithResource(_arg1, _arg2));
        }
        private function supportNonFrameworkApps():void{
            if (initializedForNonFrameworkApp){
                return;
            };
            initializedForNonFrameworkApp = true;
            if (getLocales().length > 0){
                return;
            };
            var _local1:ApplicationDomain = ApplicationDomain.currentDomain;
            if (!_local1.hasDefinition("_CompiledResourceBundleInfo")){
                return;
            };
            var _local2:Class = Class(_local1.getDefinition("_CompiledResourceBundleInfo"));
            var _local3:Array = _local2.compiledLocales;
            var _local4:Array = _local2.compiledResourceBundleNames;
            installCompiledResourceBundles(_local1, _local3, _local4);
            localeChain = _local3;
        }
        public function getBundleNamesForLocale(_arg1:String):Array{
            var _local3:String;
            var _local2:Array = [];
            for (_local3 in localeMap[_arg1]) {
                _local2.push(_local3);
            };
            return (_local2);
        }
        public function getPreferredLocaleChain():Array{
            return (LocaleSorter.sortLocalesByPreference(getLocales(), getSystemPreferredLocales(), null, true));
        }
        public function getNumber(_arg1:String, _arg2:String, _arg3:String=null):Number{
            var _local4:IResourceBundle = findBundle(_arg1, _arg2, _arg3);
            if (!_local4){
                return (NaN);
            };
            var _local5:* = _local4.content[_arg2];
            return (Number(_local5));
        }
        public function update():void{
            dispatchEvent(new Event(Event.CHANGE));
        }
        public function getClass(_arg1:String, _arg2:String, _arg3:String=null):Class{
            var _local4:IResourceBundle = findBundle(_arg1, _arg2, _arg3);
            if (!_local4){
                return (null);
            };
            var _local5:* = _local4.content[_arg2];
            return ((_local5 as Class));
        }
        public function removeResourceBundle(_arg1:String, _arg2:String):void{
            delete localeMap[_arg1][_arg2];
            if (getBundleNamesForLocale(_arg1).length == 0){
                delete localeMap[_arg1];
            };
        }
        public function initializeLocaleChain(_arg1:Array):void{
            localeChain = LocaleSorter.sortLocalesByPreference(_arg1, getSystemPreferredLocales(), null, true);
        }
        public function findResourceBundleWithResource(_arg1:String, _arg2:String):IResourceBundle{
            var _local5:String;
            var _local6:Object;
            var _local7:ResourceBundle;
            if (!_localeChain){
                return (null);
            };
            var _local3:int = _localeChain.length;
            var _local4:int;
            while (_local4 < _local3) {
                _local5 = localeChain[_local4];
                _local6 = localeMap[_local5];
                if (!_local6){
                } else {
                    _local7 = _local6[_arg1];
                    if (!_local7){
                    } else {
                        if ((_arg2 in _local7.content)){
                            return (_local7);
                        };
                    };
                };
                _local4++;
            };
            return (null);
        }
        public function getUint(_arg1:String, _arg2:String, _arg3:String=null):uint{
            var _local4:IResourceBundle = findBundle(_arg1, _arg2, _arg3);
            if (!_local4){
                return (0);
            };
            var _local5:* = _local4.content[_arg2];
            return (uint(_local5));
        }
        private function getSystemPreferredLocales():Array{
            var _local1:Array;
            if (Capabilities["languages"]){
                _local1 = Capabilities["languages"];
            } else {
                _local1 = [Capabilities.language];
            };
            return (_local1);
        }
        public function installCompiledResourceBundles(_arg1:ApplicationDomain, _arg2:Array, _arg3:Array):void{
            var _local7:String;
            var _local8:int;
            var _local9:String;
            var _local4:int = ((_arg2) ? _arg2.length : 0);
            var _local5:int = ((_arg3) ? _arg3.length : 0);
            var _local6:int;
            while (_local6 < _local4) {
                _local7 = _arg2[_local6];
                _local8 = 0;
                while (_local8 < _local5) {
                    _local9 = _arg3[_local8];
                    mx_internal::installCompiledResourceBundle(_arg1, _local7, _local9);
                    _local8++;
                };
                _local6++;
            };
        }
        public function getBoolean(_arg1:String, _arg2:String, _arg3:String=null):Boolean{
            var _local4:IResourceBundle = findBundle(_arg1, _arg2, _arg3);
            if (!_local4){
                return (false);
            };
            var _local5:* = _local4.content[_arg2];
            return ((String(_local5).toLowerCase() == "true"));
        }
        public function unloadResourceModule(_arg1:String, _arg2:Boolean=true):void{
            var _local4:Array;
            var _local5:int;
            var _local6:int;
            var _local7:String;
            var _local8:String;
            var _local3:ResourceModuleInfo = resourceModules[_arg1];
            if (!_local3){
                return;
            };
            if (_local3.resourceModule){
                _local4 = _local3.resourceModule.resourceBundles;
                if (_local4){
                    _local5 = _local4.length;
                    _local6 = 0;
                    while (_local6 < _local5) {
                        _local7 = _local4[_local6].locale;
                        _local8 = _local4[_local6].bundleName;
                        removeResourceBundle(_local7, _local8);
                        _local6++;
                    };
                };
            };
            resourceModules[_arg1] = null;
            delete resourceModules[_arg1];
            _local3.moduleInfo.unload();
            if (_arg2){
                this.update();
            };
        }

    }
}//package mx.resources 

import flash.events.*;
import mx.events.*;
import mx.modules.*;

class ResourceModuleInfo {

    public var resourceModule:IResourceModule;
    public var errorHandler:Function;
    public var readyHandler:Function;
    public var moduleInfo:IModuleInfo;

    public function ResourceModuleInfo(_arg1:IModuleInfo, _arg2:Function, _arg3:Function){
        this.moduleInfo = _arg1;
        this.readyHandler = _arg2;
        this.errorHandler = _arg3;
    }
}
class ResourceEventDispatcher extends EventDispatcher {

    public function ResourceEventDispatcher(_arg1:IModuleInfo){
        _arg1.addEventListener(ModuleEvent.ERROR, moduleInfo_errorHandler, false, 0, true);
        _arg1.addEventListener(ModuleEvent.PROGRESS, moduleInfo_progressHandler, false, 0, true);
        _arg1.addEventListener(ModuleEvent.READY, moduleInfo_readyHandler, false, 0, true);
    }
    private function moduleInfo_progressHandler(_arg1:ModuleEvent):void{
        var _local2:ResourceEvent = new ResourceEvent(ResourceEvent.PROGRESS, _arg1.bubbles, _arg1.cancelable);
        _local2.bytesLoaded = _arg1.bytesLoaded;
        _local2.bytesTotal = _arg1.bytesTotal;
        dispatchEvent(_local2);
    }
    private function moduleInfo_readyHandler(_arg1:ModuleEvent):void{
        var _local2:ResourceEvent = new ResourceEvent(ResourceEvent.COMPLETE);
        dispatchEvent(_local2);
    }
    private function moduleInfo_errorHandler(_arg1:ModuleEvent):void{
        var _local2:ResourceEvent = new ResourceEvent(ResourceEvent.ERROR, _arg1.bubbles, _arg1.cancelable);
        _local2.bytesLoaded = _arg1.bytesLoaded;
        _local2.bytesTotal = _arg1.bytesTotal;
        _local2.errorText = _arg1.errorText;
        dispatchEvent(_local2);
    }

}
﻿package mx.resources {
    import mx.core.*;

    public class ResourceManager {

        mx_internal static const VERSION:String = "3.5.0.12683";

        private static var implClassDependency:ResourceManagerImpl;
        private static var instance:IResourceManager;

        public static function getInstance():IResourceManager{
            if (!instance){
                try {
                    instance = IResourceManager(Singleton.getInstance("mx.resources::IResourceManager"));
                } catch(e:Error) {
                    instance = new ResourceManagerImpl();
                };
            };
            return (instance);
        }

    }
}//package mx.resources 
﻿package mx.resources {

    public interface IResourceModule {

        function get resourceBundles():Array;

    }
}//package mx.resources 
﻿package mx.resources {

    public interface IResourceBundle {

        function get content():Object;
        function get locale():String;
        function get bundleName():String;

    }
}//package mx.resources 
﻿package {
    import mx.resources.*;

    public class en_US$collections_properties extends ResourceBundle {

        public function en_US$collections_properties(){
            super("en_US", "collections");
        }
        override protected function getContent():Object{
            var _local1:Object = {
                findCondition:"Find criteria must contain all sort fields leading up to '{0}'.",
                noComparatorSortField:"Cannot determine comparator for SortField with name '{0}'.",
                outOfBounds:"Index '{0}' specified is out of bounds.",
                nonUnique:"Non-unique values in items.",
                incorrectAddition:"Attempt to add an item already in the view.",
                findRestriction:"Find criteria must contain at least one sort field value.",
                invalidType:"Incorrect type. Must be of type XML or a XMLList that contains one XML object. ",
                unknownMode:"Unknown find mode.",
                invalidIndex:"Invalid index: '{0}'.",
                invalidRemove:"Cannot remove when current is beforeFirst or afterLast.",
                unknownProperty:"Unknown Property: '{0}'.",
                invalidInsert:"Cannot insert when current is beforeFirst.",
                itemNotFound:"Cannot find when view is not sorted.",
                bookmarkInvalid:"Bookmark no longer valid.",
                noComparator:"Cannot determine comparator for '{0}'.",
                invalidCursor:"Cursor no longer valid.",
                noItems:"No items to search.",
                bookmarkNotFound:"Bookmark is not from this view."
            };
            return (_local1);
        }

    }
}//package 
﻿package {
    import mx.resources.*;

    public class en_US$messaging_properties extends ResourceBundle {

        public function en_US$messaging_properties(){
            super("en_US", "messaging");
        }
        override protected function getContent():Object{
            var _local1:Object = {
                httpRequestError.details:"Error: {0}",
                errorReadingIExternalizable:"Error encountered while reading IExternalizable. {0}",
                couldNotLoadCache:"The cache could not be loaded into the message store.",
                cannotRemoveWhenConfigured:"Channels cannot be removed from a ChannelSet that targets a configured destination.",
                deliveryInDoubt.details:"Channel disconnected before an acknowledgement was received",
                requestTimedOut:"Request timed out",
                securityError:"Security error accessing url",
                invalidURL:"Invalid URL",
                messageQueueFailedInitialize:"Message store initialization failed.",
                noErrorForMessage.details:"Was expecting message '{0}' but received '{1}'.",
                couldNotSaveCache:"The cache could not be saved.",
                unknownChannelWithId:"Channel '{0}' does not exist in the configuration.",
                producerConnectError:"Producer connect error",
                noAckMessage.details:"Was expecting mx.messaging.messages.AcknowledgeMessage, but received {0}",
                destinationNotSet:"The MessageAgent's destination must be set to send messages.",
                requestTimedOut.details:"The request timeout for the sent message was reached without receiving a response from the server.",
                couldNotRemoveMessageFromQueue:"The message could not be removed from the message store before being sent.",
                unknownReference:"Unknown reference {0}",
                noDestinationSpecified:"A destination name must be specified.",
                wrongMessageQueueForProducerDetails:"The message did not come from the message store associated with this producer.",
                emptySessionClientId:"Session clientId's must be non-zero in length.",
                unknownTraitReference:"Unknown trait reference {0}",
                producerSendErrorDetails:"The producer is not connected and the message cannot be sent.",
                connectTimedOut:"Connect attempt timed out.",
                httpRequestError:"HTTP request error",
                noErrorForMessage:"Didn't receive an error for message",
                pollingNotSupportedAMF:"StreamingAMFChannel does not support polling. ",
                pollingNotSupportedHTTP:"StreamingHTTPChannel does not support polling. ",
                noAvailableChannels:"No Channels are available for use.",
                ackFailed.details:"Was expecting message '{0}' but received '{1}'.",
                couldNotLoadCacheIds:"The list of cache ids could not be loaded.",
                noAMFXBody:"Invalid AMFX packet. Could not find message body",
                couldNotClearCache:"The cache could not be cleared.",
                unknownDestination:"Unknown destination '{0}'.",
                invalidRequestMethod:"Invalid method specified.",
                failedToSubscribe:"The consumer was not able to subscribe to its target destination.",
                destinationWithInvalidMessageType:"Destination '{0}' cannot service messages of type '{1}'.",
                couldNotAddMessageToQueue:"The message store could not store the message and the producer is not connected. The FaultEvent dispatched by the message store provides additional information.",
                unsupportedAMFXVersion:"Unsupported AMFX version: {0}",
                producerSendError:"Send failed",
                noURLSpecified:"No url was specified for the channel.",
                cannotAddWhenConfigured:"Channels cannot be added to a ChannelSet that targets a configured destination.",
                unknownChannelClass:"The channel class '{0}' specified was not found.",
                pollingIntervalNonPositive:"Channel pollingInterval may only be set to a positive value.",
                cannotAddNullIdChannelWhenClustered:"Cannot add a channel with null id to ChannelSet when its clustered property is true.",
                securityError.details:"Destination: {0}",
                referenceMissingId:"A reference must have an id.",
                sendFailed:"Send failed",
                lsoStorageNotAllowed:"The message store cannot initialize because local storage is not allowed. Please ensure that local storage is enabled for the Flash Player and that sufficient storage space is configured.",
                ackFailed:"Didn't receive an acknowledgement of message",
                cannotSetClusteredWithdNullChannelIds:"Cannot change clustered property of ChannelSet to true when it contains channels with null ids. ",
                cannotConnectToDestination:"No connection could be made to the message destination.",
                reconnectIntervalNegative:"reconnectInterval cannot take a negative value.",
                noURIAllowed:"Error for DirectHTTPChannel. No URI can be specified.",
                messageQueueSendError:"Send failed",
                noServiceForMessageType:"No service is configured to handle messages of type '{0}'.",
                AMFXTraitsNotFirst:"Invalid object. A single set of traits must be supplied as the first entry in an object.",
                consumerSubscribeError:"Consumer subscribe error",
                noChannelForDestination:"Destination '{0}' either does not exist or the destination has no channels defined (and the application does not define any default channels.)",
                emptyDestinationName:"'{0}' is not a valid destination.",
                failedToConnect:"The producer was not able to connect to its target destination.",
                noAMFXNode:"Invalid AMFX packet. Content must start with an <amfx> node",
                resubscribeIntervalNegative:"resubscribeInterval cannot take a negative value.",
                noAckMessage:"Didn't receive an acknowledge message",
                pollingRequestNotAllowed:"Poll request made on '{0}' when polling is not enabled.",
                queuedMessagesNotAllowedDetails:"This producer does not have an assigned message queue so queued messages cannot be sent.",
                unknownStringReference:"Unknown string reference {0}",
                authenticationNotSupported:"Authentication not supported on DirectHTTPChannel (no proxy).",
                deliveryInDoubt:"Channel disconnected",
                messageQueueNotInitialized:"The message store has not been initialized.",
                notImplementingIExternalizable:"Class {0} must implement flash.util.IExternalizable.",
                receivedNull:"Received null.",
                unknownDestinationForService:"Unknown destination '{1}' for service with id '{0}'."
            };
            return (_local1);
        }

    }
}//package 
﻿package {
    import mx.resources.*;

    public class en_US$core_properties extends ResourceBundle {

        public function en_US$core_properties(){
            super("en_US", "core");
        }
        override protected function getContent():Object{
            var _local1:Object = {
                multipleChildSets_ClassAndInstance:"Multiple sets of visual children have been specified for this component (component definition and component instance).",
                truncationIndicator:"...",
                notExecuting:"Repeater is not executing.",
                versionAlreadyRead:"Compatibility version has already been read.",
                multipleChildSets_ClassAndSubclass:"Multiple sets of visual children have been specified for this component (base component definition and derived component definition).",
                viewSource:"View Source",
                badFile:"File does not exist.",
                stateUndefined:"Undefined state '{0}'.",
                versionAlreadySet:"Compatibility version has already been set."
            };
            return (_local1);
        }

    }
}//package